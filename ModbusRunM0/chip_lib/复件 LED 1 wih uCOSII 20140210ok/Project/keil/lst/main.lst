L 1 "..\main.c"
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2010 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "ucos_ii.h"
L 1 "..\..\uCOS-II\Source\ucos_ii.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/OS-II
N*                                          The Real-Time Kernel
N*
N*                              (c) Copyright 1992-2010, Micrium, Weston, FL
N*                                           All Rights Reserved
N*
N* File    : uCOS_II.H
N* By      : Jean J. Labrosse
N* Version : V2.92
N*
N* LICENSING TERMS:
N* ---------------
N*   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
N* If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
N* its use in your product. We provide ALL the source code for your convenience and to help you experience
N* uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
N* licensing fee.
N*********************************************************************************************************
N*/
N
N#ifndef   OS_uCOS_II_H
N#define   OS_uCOS_II_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*
N*********************************************************************************************************
N*                                          uC/OS-II VERSION NUMBER
N*********************************************************************************************************
N*/
N
N#define  OS_VERSION                 292u                /* Version of uC/OS-II (Vx.yy mult. by 100)    */
N
N/*
N*********************************************************************************************************
N*                                           INCLUDE HEADER FILES
N*********************************************************************************************************
N*/
N
N#include <app_cfg.h>
L 1 "..\..\Project\app_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                              EXAMPLE CODE
N*
N*                          (c) Copyright 2003-2013; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      APPLICATION CONFIGURATION
N*
N*                                     ST Microelectronics STM32
N*                                              on the
N*
N*                                     Micrium uC-Eval-STM32F107
N*                                        Evaluation Board
N*
N* Filename      : app_cfg.h
N* Version       : V1.00
N* Programmer(s) : EHS
N*********************************************************************************************************
N*/
N
N#ifndef  __APP_CFG_H__
N#define  __APP_CFG_H__
N
N
N/*
N*********************************************************************************************************
N*                                       MODULE ENABLE / DISABLE
N*********************************************************************************************************
N*/
N
N#define  APP_CFG_SERIAL_EN                          DEF_ENABLED
N
N
N//#define  BSP_CFG_LED_SPI2_EN                        DEF_ENABLED       /* Enable/disable LEDs on SPI port.                     */
N//#define  BSP_CFG_LED_PIOC_EN                        DEF_ENABLED       /* Enable/disable PIOC LEDs.                            */
N
N
N/*
N*********************************************************************************************************
N*                                              TASKS NAMES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            TASK PRIORITIES
N*********************************************************************************************************
N*/
N
N#define  APP_TASK_START_PRIO                        4
N#define  APP_Test_PRIO                              5
N#define  APP_Test1_PRIO                             6
N
N#define  OS_TASK_TMR_PRIO                   (OS_LOWEST_PRIO - 2)
N
N
N/*
N*********************************************************************************************************
N*                                            TASK STACK SIZES
N*                             Size of the task stacks (# of OS_STK entries)
N*********************************************************************************************************
N*/
N
N#define  APP_TASK_START_STK_SIZE                    30
N#define  APP_TASK_Test_SIZE                         30
N#define  APP_TASK_Test1_SIZE                        30
N// #define  BUFF_SIZE                                  1000
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N/*
N*********************************************************************************************************
N*                                    BSP CONFIGURATION: RS-232
N*********************************************************************************************************
N*/
N
N//#define  BSP_CFG_SER_COMM_SEL             			BSP_SER_COMM_UART_02
N//#define  BSP_CFG_TS_TMR_SEL                    		2
N
N
N/*
N*********************************************************************************************************
N*                                     TRACE / DEBUG CONFIGURATION
N*********************************************************************************************************
N*/
N
N#if 0
S#define  TRACE_LEVEL_OFF                       		0
S#define  TRACE_LEVEL_INFO                      		1
S#define  TRACE_LEVEL_DEBUG                     		2
N#endif
N
N#define  APP_TRACE_LEVEL                			TRACE_LEVEL_INFO
N#define  APP_TRACE                      			BSP_Ser_Printf
N
N#define  APP_TRACE_INFO(x)            ((APP_TRACE_LEVEL >= TRACE_LEVEL_INFO)  ? (void)(APP_TRACE x) : (void)0)
N#define  APP_TRACE_DEBUG(x)           ((APP_TRACE_LEVEL >= TRACE_LEVEL_DEBUG) ? (void)(APP_TRACE x) : (void)0)
N
N
N
N#endif
L 45 "..\..\uCOS-II\Source\ucos_ii.h" 2
N#include <os_cfg.h>
L 1 "..\..\Project\os_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/OS-II
N*                                          The Real-Time Kernel
N*                                  uC/OS-II Configuration File for V2.9x
N*
N*                               (c) Copyright 2005-2012, Micrium, Weston, FL
N*                                          All Rights Reserved
N*
N*
N* File    : OS_CFG.H
N* By      : JJL
N*
N* Version : V2.92.00
N*
N* LICENSING TERMS:
N* ---------------
N*   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
N* If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
N* its use in your product. We provide ALL the source code for your convenience and to help you experience
N* uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
N* licensing fee.
N*********************************************************************************************************
N*/
N
N#ifndef OS_CFG_H
N#define OS_CFG_H
N
N
N                                       /* ---------------------- MISCELLANEOUS ----------------------- */
N#define OS_APP_HOOKS_EN           1u   /* Application-defined hooks are called from the uC/OS-II hooks */
N#define OS_ARG_CHK_EN             0u   /* Enable (1) or Disable (0) argument checking                  */
N#define OS_CPU_HOOKS_EN           1u   /* uC/OS-II hooks are found in the processor port files         */
N
N#define OS_DEBUG_EN               1u   /* Enable(1) debug variables                                    */
N
N#define OS_EVENT_MULTI_EN         1u   /* Include code for OSEventPendMulti()                          */
N#define OS_EVENT_NAME_EN          1u   /* Enable names for Sem, Mutex, Mbox and Q                      */
N
N#define OS_LOWEST_PRIO            10u   /* Defines the lowest priority that can be assigned ...         */
N                                       /* ... MUST NEVER be higher than 254!                           */
N
N#define OS_MAX_EVENTS            10u   /* Max. number of event control blocks in your application      */
N#define OS_MAX_FLAGS              5u   /* Max. number of Event Flag Groups    in your application      */
N#define OS_MAX_MEM_PART           5u   /* Max. number of memory partitions                             */
N#define OS_MAX_QS                 3u   /* Max. number of queue control blocks in your application      */
N#define OS_MAX_TASKS              7u   /* Max. number of tasks in your application, MUST be >= 2       */
N
N#define OS_SCHED_LOCK_EN          1u   /* Include code for OSSchedLock() and OSSchedUnlock()           */
N
N#define OS_TICK_STEP_EN           1u   /* Enable tick stepping feature for uC/OS-View                  */
N#define OS_TICKS_PER_SEC       1000u   /* Set the number of ticks in one second                        */
N
N
N                                       /* --------------------- TASK STACK SIZE ---------------------- */
N#define OS_TASK_TMR_STK_SIZE    15u   /* Timer      task stack size (# of OS_STK wide entries)        */
N#define OS_TASK_STAT_STK_SIZE   15u   /* Statistics task stack size (# of OS_STK wide entries)        */
N#define OS_TASK_IDLE_STK_SIZE   15u   /* Idle       task stack size (# of OS_STK wide entries)        */
N
N
N                                       /* --------------------- TASK MANAGEMENT ---------------------- */
N#define OS_TASK_CHANGE_PRIO_EN    1u   /*     Include code for OSTaskChangePrio()                      */
N#define OS_TASK_CREATE_EN         1u   /*     Include code for OSTaskCreate()                          */
N#define OS_TASK_CREATE_EXT_EN     1u   /*     Include code for OSTaskCreateExt()                       */
N#define OS_TASK_DEL_EN            1u   /*     Include code for OSTaskDel()                             */
N#define OS_TASK_NAME_EN           1u   /*     Enable task names                                        */
N#define OS_TASK_PROFILE_EN        1u   /*     Include variables in OS_TCB for profiling                */
N#define OS_TASK_QUERY_EN          1u   /*     Include code for OSTaskQuery()                           */
N#define OS_TASK_REG_TBL_SIZE      1u   /*     Size of task variables array (#of INT32U entries)        */
N#define OS_TASK_STAT_EN           1u   /*     Enable (1) or Disable(0) the statistics task             */
N#define OS_TASK_STAT_STK_CHK_EN   1u   /*     Check task stacks from statistic task                    */
N#define OS_TASK_SUSPEND_EN        1u   /*     Include code for OSTaskSuspend() and OSTaskResume()      */
N#define OS_TASK_SW_HOOK_EN        1u   /*     Include code for OSTaskSwHook()                          */
N
N
N                                       /* ----------------------- EVENT FLAGS ------------------------ */
N#define OS_FLAG_EN                1u   /* Enable (1) or Disable (0) code generation for EVENT FLAGS    */
N#define OS_FLAG_ACCEPT_EN         1u   /*     Include code for OSFlagAccept()                          */
N#define OS_FLAG_DEL_EN            1u   /*     Include code for OSFlagDel()                             */
N#define OS_FLAG_NAME_EN           1u   /*     Enable names for event flag group                        */
N#define OS_FLAG_QUERY_EN          1u   /*     Include code for OSFlagQuery()                           */
N#define OS_FLAG_WAIT_CLR_EN       1u   /* Include code for Wait on Clear EVENT FLAGS                   */
N#define OS_FLAGS_NBITS            8u   /* Size in #bits of OS_FLAGS data type (8, 16 or 32)            */
N
N
N                                       /* -------------------- MESSAGE MAILBOXES --------------------- */
N#define OS_MBOX_EN                1u   /* Enable (1) or Disable (0) code generation for MAILBOXES      */
N#define OS_MBOX_ACCEPT_EN         1u   /*     Include code for OSMboxAccept()                          */
N#define OS_MBOX_DEL_EN            1u   /*     Include code for OSMboxDel()                             */
N#define OS_MBOX_PEND_ABORT_EN     1u   /*     Include code for OSMboxPendAbort()                       */
N#define OS_MBOX_POST_EN           1u   /*     Include code for OSMboxPost()                            */
N#define OS_MBOX_POST_OPT_EN       1u   /*     Include code for OSMboxPostOpt()                         */
N#define OS_MBOX_QUERY_EN          1u   /*     Include code for OSMboxQuery()                           */
N
N
N                                       /* --------------------- MEMORY MANAGEMENT -------------------- */
N#define OS_MEM_EN                 1u   /* Enable (1) or Disable (0) code generation for MEMORY MANAGER */
N#define OS_MEM_NAME_EN            1u   /*     Enable memory partition names                            */
N#define OS_MEM_QUERY_EN           1u   /*     Include code for OSMemQuery()                            */
N
N
N                                       /* ---------------- MUTUAL EXCLUSION SEMAPHORES --------------- */
N#define OS_MUTEX_EN               1u   /* Enable (1) or Disable (0) code generation for MUTEX          */
N#define OS_MUTEX_ACCEPT_EN        1u   /*     Include code for OSMutexAccept()                         */
N#define OS_MUTEX_DEL_EN           1u   /*     Include code for OSMutexDel()                            */
N#define OS_MUTEX_QUERY_EN         1u   /*     Include code for OSMutexQuery()                          */
N
N
N                                       /* ---------------------- MESSAGE QUEUES ---------------------- */
N#define OS_Q_EN                   0u   /* Enable (1) or Disable (0) code generation for QUEUES         */
N#define OS_Q_ACCEPT_EN            1u   /*     Include code for OSQAccept()                             */
N#define OS_Q_DEL_EN               1u   /*     Include code for OSQDel()                                */
N#define OS_Q_FLUSH_EN             1u   /*     Include code for OSQFlush()                              */
N#define OS_Q_PEND_ABORT_EN        1u   /*     Include code for OSQPendAbort()                          */
N#define OS_Q_POST_EN              1u   /*     Include code for OSQPost()                               */
N#define OS_Q_POST_FRONT_EN        1u   /*     Include code for OSQPostFront()                          */
N#define OS_Q_POST_OPT_EN          1u   /*     Include code for OSQPostOpt()                            */
N#define OS_Q_QUERY_EN             1u   /*     Include code for OSQQuery()                              */
N
N
N                                       /* ------------------------ SEMAPHORES ------------------------ */
N#define OS_SEM_EN                 1u   /* Enable (1) or Disable (0) code generation for SEMAPHORES     */
N#define OS_SEM_ACCEPT_EN          1u   /*    Include code for OSSemAccept()                            */
N#define OS_SEM_DEL_EN             1u   /*    Include code for OSSemDel()                               */
N#define OS_SEM_PEND_ABORT_EN      1u   /*    Include code for OSSemPendAbort()                         */
N#define OS_SEM_QUERY_EN           1u   /*    Include code for OSSemQuery()                             */
N#define OS_SEM_SET_EN             1u   /*    Include code for OSSemSet()                               */
N
N
N                                       /* --------------------- TIME MANAGEMENT ---------------------- */
N#define OS_TIME_DLY_HMSM_EN       1u   /*     Include code for OSTimeDlyHMSM()                         */
N#define OS_TIME_DLY_RESUME_EN     1u   /*     Include code for OSTimeDlyResume()                       */
N#define OS_TIME_GET_SET_EN        1u   /*     Include code for OSTimeGet() and OSTimeSet()             */
N#define OS_TIME_TICK_HOOK_EN      1u   /*     Include code for OSTimeTickHook()                        */
N
N
N                                       /* --------------------- TIMER MANAGEMENT --------------------- */
N#define OS_TMR_EN                 1u   /* Enable (1) or Disable (0) code generation for TIMERS         */
N#define OS_TMR_CFG_MAX            8u   /*     Maximum number of timers                                 */
N#define OS_TMR_CFG_NAME_EN        1u   /*     Determine timer names                                    */
N#define OS_TMR_CFG_WHEEL_SIZE     8u   /*     Size of timer wheel (#Spokes)                            */
N#define OS_TMR_CFG_TICKS_PER_SEC 10u   /*     Rate at which timer management task runs (Hz)            */
N
N#endif
L 46 "..\..\uCOS-II\Source\ucos_ii.h" 2
N#include <os_cpu.h>
L 1 "..\..\uCOS-II\Ports\ARM-Cortex-M0\Generic\RealView\os_cpu.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/OS-II
N*                                         The Real-Time Kernel
N*
N*
N*                              (c) Copyright 2006-2012, Micrium, Weston, FL
N*                                          All Rights Reserved
N*
N*                                           ARM Cortex-M0 Port
N*
N* File      : OS_CPU.H
N* Version   : V2.92.07.00
N* By        : Jean J. Labrosse
N*             yng
N*
N* For       : ARMv6M Cortex-M0
N* Mode      : Thumb2
N* Toolchain : RealView Development Suite
N*             RealView Microcontroller Development Kit (MDK)
N*             ARM Developer Suite (ADS)
N*             Keil uVision
N*********************************************************************************************************
N*/
N
N#ifndef  OS_CPU_H
N#define  OS_CPU_H
N
N
N#ifdef   OS_CPU_GLOBALS
S#define  OS_CPU_EXT
N#else
N#define  OS_CPU_EXT  extern
N#endif
N
N#ifndef  OS_CPU_EXCEPT_STK_SIZE
N#define  OS_CPU_EXCEPT_STK_SIZE    64u          /* Default exception stack size is 128 OS_STK entries */
N#endif
N
N/*
N*********************************************************************************************************
N*                                              DATA TYPES
N*                                         (Compiler Specific)
N*********************************************************************************************************
N*/
N
Ntypedef unsigned char  BOOLEAN;
Ntypedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
Ntypedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
Ntypedef unsigned short INT16U;                   /* Unsigned 16 bit quantity                           */
Ntypedef signed   short INT16S;                   /* Signed   16 bit quantity                           */
Ntypedef unsigned int   INT32U;                   /* Unsigned 32 bit quantity                           */
Ntypedef signed   int   INT32S;                   /* Signed   32 bit quantity                           */
Ntypedef float          FP32;                     /* Single precision floating point                    */
Ntypedef double         FP64;                     /* Double precision floating point                    */
N
Ntypedef unsigned int   OS_STK;                   /* Each stack entry is 32-bit wide                    */
Ntypedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (PSR = 32 bits) */
N
N/*
N*********************************************************************************************************
N*                                              Cortex-M3
N*                                      Critical Section Management
N*
N* Method #1:  Disable/Enable interrupts using simple instructions.  After critical section, interrupts
N*             will be enabled even if they were disabled before entering the critical section.
N*             NOT IMPLEMENTED
N*
N* Method #2:  Disable/Enable interrupts by preserving the state of interrupts.  In other words, if
N*             interrupts were disabled before entering the critical section, they will be disabled when
N*             leaving the critical section.
N*             NOT IMPLEMENTED
N*
N* Method #3:  Disable/Enable interrupts by preserving the state of interrupts.  Generally speaking you
N*             would store the state of the interrupt disable flag in the local variable 'cpu_sr' and then
N*             disable interrupts.  'cpu_sr' is allocated in all of uC/OS-II's functions that need to
N*             disable interrupts.  You would restore the interrupt disable state by copying back 'cpu_sr'
N*             into the CPU's status register.
N*********************************************************************************************************
N*/
N
N#define  OS_CRITICAL_METHOD   3u
N
N#if OS_CRITICAL_METHOD == 3u
X#if 3u == 3u
N#define  OS_ENTER_CRITICAL()  {cpu_sr = OS_CPU_SR_Save();}
N#define  OS_EXIT_CRITICAL()   {OS_CPU_SR_Restore(cpu_sr);}
N#endif
N
N/*
N*********************************************************************************************************
N*                                        Cortex-M3 Miscellaneous
N*********************************************************************************************************
N*/
N
N#define  OS_STK_GROWTH        1u                  /* Stack grows from HIGH to LOW memory on ARM        */
N
N#define  OS_TASK_SW()         OSCtxSw()
N
N/*
N*********************************************************************************************************
N*                                            GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
NOS_CPU_EXT  OS_STK   OS_CPU_ExceptStk[OS_CPU_EXCEPT_STK_SIZE];
Xextern  OS_STK   OS_CPU_ExceptStk[64u];
NOS_CPU_EXT  OS_STK  *OS_CPU_ExceptStkBase;
Xextern  OS_STK  *OS_CPU_ExceptStkBase;
N
N/*
N*********************************************************************************************************
N*                                              PROTOTYPES
N*********************************************************************************************************
N*/
N
N#if OS_CRITICAL_METHOD == 3u                      /* See OS_CPU_A.ASM                                  */
X#if 3u == 3u                       
NOS_CPU_SR  OS_CPU_SR_Save(void);
Nvoid       OS_CPU_SR_Restore(OS_CPU_SR cpu_sr);
N#endif
N
Nvoid       OSCtxSw(void);
Nvoid       OSIntCtxSw(void);
Nvoid       OSStartHighRdy(void);
N
Nvoid       OS_CPU_PendSVHandler(void);
N
N                                                  /* See OS_CPU_C.C                                    */
Nvoid       OS_CPU_SysTickHandler(void);
Nvoid       OS_CPU_SysTickInit(INT32U  cnts);
N#endif
L 47 "..\..\uCOS-II\Source\ucos_ii.h" 2
N
N/*
N*********************************************************************************************************
N*                                             MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#ifdef   OS_GLOBALS
S#define  OS_EXT
N#else
N#define  OS_EXT  extern
N#endif
N
N#ifndef  OS_FALSE
N#define  OS_FALSE                       0u
N#endif
N
N#ifndef  OS_TRUE
N#define  OS_TRUE                        1u
N#endif
N
N#define  OS_ASCII_NUL            (INT8U)0
N
N#define  OS_PRIO_SELF                0xFFu              /* Indicate SELF priority                      */
N
N#if OS_TASK_STAT_EN > 0u
X#if 1u > 0u
N#define  OS_N_SYS_TASKS                 2u              /* Number of system tasks                      */
N#else
S#define  OS_N_SYS_TASKS                 1u
N#endif
N
N#define  OS_TASK_STAT_PRIO  (OS_LOWEST_PRIO - 1u)       /* Statistic task priority                     */
N#define  OS_TASK_IDLE_PRIO  (OS_LOWEST_PRIO)            /* IDLE      task priority                     */
N
N#if OS_LOWEST_PRIO <= 63u
X#if 10u <= 63u
N#define  OS_EVENT_TBL_SIZE ((OS_LOWEST_PRIO) / 8u + 1u) /* Size of event table                         */
N#define  OS_RDY_TBL_SIZE   ((OS_LOWEST_PRIO) / 8u + 1u) /* Size of ready table                         */
N#else
S#define  OS_EVENT_TBL_SIZE ((OS_LOWEST_PRIO) / 16u + 1u)/* Size of event table                         */
S#define  OS_RDY_TBL_SIZE   ((OS_LOWEST_PRIO) / 16u + 1u)/* Size of ready table                         */
N#endif
N
N#define  OS_TASK_IDLE_ID            65535u              /* ID numbers for Idle, Stat and Timer tasks   */
N#define  OS_TASK_STAT_ID            65534u
N#define  OS_TASK_TMR_ID             65533u
N
N#define  OS_EVENT_EN           (((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u) || (OS_SEM_EN > 0u) || (OS_MUTEX_EN > 0u))
N
N#define  OS_TCB_RESERVED        ((OS_TCB *)1)
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                              TASK STATUS (Bit definition for OSTCBStat)
N*********************************************************************************************************
N*/
N#define  OS_STAT_RDY                 0x00u  /* Ready to run                                            */
N#define  OS_STAT_SEM                 0x01u  /* Pending on semaphore                                    */
N#define  OS_STAT_MBOX                0x02u  /* Pending on mailbox                                      */
N#define  OS_STAT_Q                   0x04u  /* Pending on queue                                        */
N#define  OS_STAT_SUSPEND             0x08u  /* Task is suspended                                       */
N#define  OS_STAT_MUTEX               0x10u  /* Pending on mutual exclusion semaphore                   */
N#define  OS_STAT_FLAG                0x20u  /* Pending on event flag group                             */
N#define  OS_STAT_MULTI               0x80u  /* Pending on multiple events                              */
N
N#define  OS_STAT_PEND_ANY         (OS_STAT_SEM | OS_STAT_MBOX | OS_STAT_Q | OS_STAT_MUTEX | OS_STAT_FLAG)
N
N/*
N*********************************************************************************************************
N*                           TASK PEND STATUS (Status codes for OSTCBStatPend)
N*********************************************************************************************************
N*/
N#define  OS_STAT_PEND_OK                0u  /* Pending status OK, not pending, or pending complete     */
N#define  OS_STAT_PEND_TO                1u  /* Pending timed out                                       */
N#define  OS_STAT_PEND_ABORT             2u  /* Pending aborted                                         */
N
N/*
N*********************************************************************************************************
N*                                        OS_EVENT types
N*********************************************************************************************************
N*/
N#define  OS_EVENT_TYPE_UNUSED           0u
N#define  OS_EVENT_TYPE_MBOX             1u
N#define  OS_EVENT_TYPE_Q                2u
N#define  OS_EVENT_TYPE_SEM              3u
N#define  OS_EVENT_TYPE_MUTEX            4u
N#define  OS_EVENT_TYPE_FLAG             5u
N
N#define  OS_TMR_TYPE                  100u  /* Used to identify Timers ...                             */
N                                            /* ... (Must be different value than OS_EVENT_TYPE_xxx)    */
N
N/*
N*********************************************************************************************************
N*                                         EVENT FLAGS
N*********************************************************************************************************
N*/
N#define  OS_FLAG_WAIT_CLR_ALL           0u  /* Wait for ALL    the bits specified to be CLR (i.e. 0)   */
N#define  OS_FLAG_WAIT_CLR_AND           0u
N
N#define  OS_FLAG_WAIT_CLR_ANY           1u  /* Wait for ANY of the bits specified to be CLR (i.e. 0)   */
N#define  OS_FLAG_WAIT_CLR_OR            1u
N
N#define  OS_FLAG_WAIT_SET_ALL           2u  /* Wait for ALL    the bits specified to be SET (i.e. 1)   */
N#define  OS_FLAG_WAIT_SET_AND           2u
N
N#define  OS_FLAG_WAIT_SET_ANY           3u  /* Wait for ANY of the bits specified to be SET (i.e. 1)   */
N#define  OS_FLAG_WAIT_SET_OR            3u
N
N
N#define  OS_FLAG_CONSUME             0x80u  /* Consume the flags if condition(s) satisfied             */
N
N
N#define  OS_FLAG_CLR                    0u
N#define  OS_FLAG_SET                    1u
N
N/*
N*********************************************************************************************************
N*                                   Values for OSTickStepState
N*
N* Note(s): This feature is used by uC/OS-View.
N*********************************************************************************************************
N*/
N
N#if OS_TICK_STEP_EN > 0u
X#if 1u > 0u
N#define  OS_TICK_STEP_DIS               0u  /* Stepping is disabled, tick runs as mormal               */
N#define  OS_TICK_STEP_WAIT              1u  /* Waiting for uC/OS-View to set OSTickStepState to _ONCE  */
N#define  OS_TICK_STEP_ONCE              2u  /* Process tick once and wait for next cmd from uC/OS-View */
N#endif
N
N/*
N*********************************************************************************************************
N*       Possible values for 'opt' argument of OSSemDel(), OSMboxDel(), OSQDel() and OSMutexDel()
N*********************************************************************************************************
N*/
N#define  OS_DEL_NO_PEND                 0u
N#define  OS_DEL_ALWAYS                  1u
N
N/*
N*********************************************************************************************************
N*                                        OS???Pend() OPTIONS
N*
N* These #defines are used to establish the options for OS???PendAbort().
N*********************************************************************************************************
N*/
N#define  OS_PEND_OPT_NONE               0u  /* NO option selected                                      */
N#define  OS_PEND_OPT_BROADCAST          1u  /* Broadcast action to ALL tasks waiting                   */
N
N/*
N*********************************************************************************************************
N*                                     OS???PostOpt() OPTIONS
N*
N* These #defines are used to establish the options for OSMboxPostOpt() and OSQPostOpt().
N*********************************************************************************************************
N*/
N#define  OS_POST_OPT_NONE            0x00u  /* NO option selected                                      */
N#define  OS_POST_OPT_BROADCAST       0x01u  /* Broadcast message to ALL tasks waiting                  */
N#define  OS_POST_OPT_FRONT           0x02u  /* Post to highest priority task waiting                   */
N#define  OS_POST_OPT_NO_SCHED        0x04u  /* Do not call the scheduler if this option is selected    */
N
N/*
N*********************************************************************************************************
N*                                 TASK OPTIONS (see OSTaskCreateExt())
N*********************************************************************************************************
N*/
N#define  OS_TASK_OPT_NONE          0x0000u  /* NO option selected                                      */
N#define  OS_TASK_OPT_STK_CHK       0x0001u  /* Enable stack checking for the task                      */
N#define  OS_TASK_OPT_STK_CLR       0x0002u  /* Clear the stack when the task is create                 */
N#define  OS_TASK_OPT_SAVE_FP       0x0004u  /* Save the contents of any floating-point registers       */
N
N/*
N*********************************************************************************************************
N*                            TIMER OPTIONS (see OSTmrStart() and OSTmrStop())
N*********************************************************************************************************
N*/
N#define  OS_TMR_OPT_NONE                0u  /* No option selected                                      */
N
N#define  OS_TMR_OPT_ONE_SHOT            1u  /* Timer will not automatically restart when it expires    */
N#define  OS_TMR_OPT_PERIODIC            2u  /* Timer will     automatically restart when it expires    */
N
N#define  OS_TMR_OPT_CALLBACK            3u  /* OSTmrStop() option to call 'callback' w/ timer arg.     */
N#define  OS_TMR_OPT_CALLBACK_ARG        4u  /* OSTmrStop() option to call 'callback' w/ new   arg.     */
N
N/*
N*********************************************************************************************************
N*                                            TIMER STATES
N*********************************************************************************************************
N*/
N#define  OS_TMR_STATE_UNUSED            0u
N#define  OS_TMR_STATE_STOPPED           1u
N#define  OS_TMR_STATE_COMPLETED         2u
N#define  OS_TMR_STATE_RUNNING           3u
N
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*********************************************************************************************************
N*/
N#define OS_ERR_NONE                     0u
N
N#define OS_ERR_EVENT_TYPE               1u
N#define OS_ERR_PEND_ISR                 2u
N#define OS_ERR_POST_NULL_PTR            3u
N#define OS_ERR_PEVENT_NULL              4u
N#define OS_ERR_POST_ISR                 5u
N#define OS_ERR_QUERY_ISR                6u
N#define OS_ERR_INVALID_OPT              7u
N#define OS_ERR_ID_INVALID               8u
N#define OS_ERR_PDATA_NULL               9u
N
N#define OS_ERR_TIMEOUT                 10u
N#define OS_ERR_EVENT_NAME_TOO_LONG     11u
N#define OS_ERR_PNAME_NULL              12u
N#define OS_ERR_PEND_LOCKED             13u
N#define OS_ERR_PEND_ABORT              14u
N#define OS_ERR_DEL_ISR                 15u
N#define OS_ERR_CREATE_ISR              16u
N#define OS_ERR_NAME_GET_ISR            17u
N#define OS_ERR_NAME_SET_ISR            18u
N#define OS_ERR_ILLEGAL_CREATE_RUN_TIME 19u
N
N#define OS_ERR_MBOX_FULL               20u
N
N#define OS_ERR_Q_FULL                  30u
N#define OS_ERR_Q_EMPTY                 31u
N
N#define OS_ERR_PRIO_EXIST              40u
N#define OS_ERR_PRIO                    41u
N#define OS_ERR_PRIO_INVALID            42u
N
N#define OS_ERR_SCHED_LOCKED            50u
N#define OS_ERR_SEM_OVF                 51u
N
N#define OS_ERR_TASK_CREATE_ISR         60u
N#define OS_ERR_TASK_DEL                61u
N#define OS_ERR_TASK_DEL_IDLE           62u
N#define OS_ERR_TASK_DEL_REQ            63u
N#define OS_ERR_TASK_DEL_ISR            64u
N#define OS_ERR_TASK_NAME_TOO_LONG      65u
N#define OS_ERR_TASK_NO_MORE_TCB        66u
N#define OS_ERR_TASK_NOT_EXIST          67u
N#define OS_ERR_TASK_NOT_SUSPENDED      68u
N#define OS_ERR_TASK_OPT                69u
N#define OS_ERR_TASK_RESUME_PRIO        70u
N#define OS_ERR_TASK_SUSPEND_IDLE       71u
N#define OS_ERR_TASK_SUSPEND_PRIO       72u
N#define OS_ERR_TASK_WAITING            73u
N
N#define OS_ERR_TIME_NOT_DLY            80u
N#define OS_ERR_TIME_INVALID_MINUTES    81u
N#define OS_ERR_TIME_INVALID_SECONDS    82u
N#define OS_ERR_TIME_INVALID_MS         83u
N#define OS_ERR_TIME_ZERO_DLY           84u
N#define OS_ERR_TIME_DLY_ISR            85u
N
N#define OS_ERR_MEM_INVALID_PART        90u
N#define OS_ERR_MEM_INVALID_BLKS        91u
N#define OS_ERR_MEM_INVALID_SIZE        92u
N#define OS_ERR_MEM_NO_FREE_BLKS        93u
N#define OS_ERR_MEM_FULL                94u
N#define OS_ERR_MEM_INVALID_PBLK        95u
N#define OS_ERR_MEM_INVALID_PMEM        96u
N#define OS_ERR_MEM_INVALID_PDATA       97u
N#define OS_ERR_MEM_INVALID_ADDR        98u
N#define OS_ERR_MEM_NAME_TOO_LONG       99u
N
N#define OS_ERR_NOT_MUTEX_OWNER        100u
N
N#define OS_ERR_FLAG_INVALID_PGRP      110u
N#define OS_ERR_FLAG_WAIT_TYPE         111u
N#define OS_ERR_FLAG_NOT_RDY           112u
N#define OS_ERR_FLAG_INVALID_OPT       113u
N#define OS_ERR_FLAG_GRP_DEPLETED      114u
N#define OS_ERR_FLAG_NAME_TOO_LONG     115u
N
N#define OS_ERR_PIP_LOWER              120u
N
N#define OS_ERR_TMR_INVALID_DLY        130u
N#define OS_ERR_TMR_INVALID_PERIOD     131u
N#define OS_ERR_TMR_INVALID_OPT        132u
N#define OS_ERR_TMR_INVALID_NAME       133u
N#define OS_ERR_TMR_NON_AVAIL          134u
N#define OS_ERR_TMR_INACTIVE           135u
N#define OS_ERR_TMR_INVALID_DEST       136u
N#define OS_ERR_TMR_INVALID_TYPE       137u
N#define OS_ERR_TMR_INVALID            138u
N#define OS_ERR_TMR_ISR                139u
N#define OS_ERR_TMR_NAME_TOO_LONG      140u
N#define OS_ERR_TMR_INVALID_STATE      141u
N#define OS_ERR_TMR_STOPPED            142u
N#define OS_ERR_TMR_NO_CALLBACK        143u
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          EVENT CONTROL BLOCK
N*********************************************************************************************************
N*/
N
N#if OS_LOWEST_PRIO <= 63u
X#if 10u <= 63u
Ntypedef  INT8U    OS_PRIO;
N#else
Stypedef  INT16U   OS_PRIO;
N#endif
N
N#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
X#if ((((0u > 0u) && (3u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u))) && (10u > 0u)
Ntypedef struct os_event {
N    INT8U    OSEventType;                    /* Type of event control block (see OS_EVENT_TYPE_xxxx)    */
N    void    *OSEventPtr;                     /* Pointer to message or queue structure                   */
N    INT16U   OSEventCnt;                     /* Semaphore Count (not used if other EVENT type)          */
N    OS_PRIO  OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N    OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    OS_PRIO  OSEventTbl[((10u) / 8u + 1u)];   
N
N#if OS_EVENT_NAME_EN > 0u
X#if 1u > 0u
N    INT8U   *OSEventName;
N#endif
N} OS_EVENT;
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                       EVENT FLAGS CONTROL BLOCK
N*********************************************************************************************************
N*/
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N
N#if OS_FLAGS_NBITS == 8u                    /* Determine the size of OS_FLAGS (8, 16 or 32 bits)       */
X#if 8u == 8u                     
Ntypedef  INT8U    OS_FLAGS;
N#endif
N
N#if OS_FLAGS_NBITS == 16u
X#if 8u == 16u
Stypedef  INT16U   OS_FLAGS;
N#endif
N
N#if OS_FLAGS_NBITS == 32u
X#if 8u == 32u
Stypedef  INT32U   OS_FLAGS;
N#endif
N
N
Ntypedef struct os_flag_grp {                /* Event Flag Group                                        */
N    INT8U         OSFlagType;               /* Should be set to OS_EVENT_TYPE_FLAG                     */
N    void         *OSFlagWaitList;           /* Pointer to first NODE of task waiting on event flag     */
N    OS_FLAGS      OSFlagFlags;              /* 8, 16 or 32 bit flags                                   */
N#if OS_FLAG_NAME_EN > 0u
X#if 1u > 0u
N    INT8U        *OSFlagName;
N#endif
N} OS_FLAG_GRP;
N
N
N
Ntypedef struct os_flag_node {               /* Event Flag Wait List Node                               */
N    void         *OSFlagNodeNext;           /* Pointer to next     NODE in wait list                   */
N    void         *OSFlagNodePrev;           /* Pointer to previous NODE in wait list                   */
N    void         *OSFlagNodeTCB;            /* Pointer to TCB of waiting task                          */
N    void         *OSFlagNodeFlagGrp;        /* Pointer to Event Flag Group                             */
N    OS_FLAGS      OSFlagNodeFlags;          /* Event flag to wait on                                   */
N    INT8U         OSFlagNodeWaitType;       /* Type of wait:                                           */
N                                            /*      OS_FLAG_WAIT_AND                                   */
N                                            /*      OS_FLAG_WAIT_ALL                                   */
N                                            /*      OS_FLAG_WAIT_OR                                    */
N                                            /*      OS_FLAG_WAIT_ANY                                   */
N} OS_FLAG_NODE;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          MESSAGE MAILBOX DATA
N*********************************************************************************************************
N*/
N
N#if OS_MBOX_EN > 0u
X#if 1u > 0u
Ntypedef struct os_mbox_data {
N    void   *OSMsg;                         /* Pointer to message in mailbox                            */
N    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE]; /* List of tasks waiting for event to occur                 */
X    OS_PRIO OSEventTbl[((10u) / 8u + 1u)];  
N    OS_PRIO OSEventGrp;                    /* Group corresponding to tasks waiting for event to occur  */
N} OS_MBOX_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                     MEMORY PARTITION DATA STRUCTURES
N*********************************************************************************************************
N*/
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
Ntypedef struct os_mem {                   /* MEMORY CONTROL BLOCK                                      */
N    void   *OSMemAddr;                    /* Pointer to beginning of memory partition                  */
N    void   *OSMemFreeList;                /* Pointer to list of free memory blocks                     */
N    INT32U  OSMemBlkSize;                 /* Size (in bytes) of each block of memory                   */
N    INT32U  OSMemNBlks;                   /* Total number of blocks in this partition                  */
N    INT32U  OSMemNFree;                   /* Number of memory blocks remaining in this partition       */
N#if OS_MEM_NAME_EN > 0u
X#if 1u > 0u
N    INT8U  *OSMemName;                    /* Memory partition name                                     */
N#endif
N} OS_MEM;
N
N
Ntypedef struct os_mem_data {
N    void   *OSAddr;                    /* Pointer to the beginning address of the memory partition     */
N    void   *OSFreeList;                /* Pointer to the beginning of the free list of memory blocks   */
N    INT32U  OSBlkSize;                 /* Size (in bytes) of each memory block                         */
N    INT32U  OSNBlks;                   /* Total number of blocks in the partition                      */
N    INT32U  OSNFree;                   /* Number of memory blocks free                                 */
N    INT32U  OSNUsed;                   /* Number of memory blocks used                                 */
N} OS_MEM_DATA;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    MUTUAL EXCLUSION SEMAPHORE DATA
N*********************************************************************************************************
N*/
N
N#if OS_MUTEX_EN > 0u
X#if 1u > 0u
Ntypedef struct os_mutex_data {
N    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    OS_PRIO OSEventTbl[((10u) / 8u + 1u)];   
N    OS_PRIO OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N    BOOLEAN OSValue;                        /* Mutex value (OS_FALSE = used, OS_TRUE = available)      */
N    INT8U   OSOwnerPrio;                    /* Mutex owner's task priority or 0xFF if no owner         */
N    INT8U   OSMutexPIP;                     /* Priority Inheritance Priority or 0xFF if no owner       */
N} OS_MUTEX_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                          MESSAGE QUEUE DATA
N*********************************************************************************************************
N*/
N
N#if OS_Q_EN > 0u
X#if 0u > 0u
Stypedef struct os_q {                   /* QUEUE CONTROL BLOCK                                         */
S    struct os_q   *OSQPtr;              /* Link to next queue control block in list of free blocks     */
S    void         **OSQStart;            /* Pointer to start of queue data                              */
S    void         **OSQEnd;              /* Pointer to end   of queue data                              */
S    void         **OSQIn;               /* Pointer to where next message will be inserted  in   the Q  */
S    void         **OSQOut;              /* Pointer to where next message will be extracted from the Q  */
S    INT16U         OSQSize;             /* Size of queue (maximum number of entries)                   */
S    INT16U         OSQEntries;          /* Current number of entries in the queue                      */
S} OS_Q;
S
S
Stypedef struct os_q_data {
S    void          *OSMsg;               /* Pointer to next message to be extracted from queue          */
S    INT16U         OSNMsgs;             /* Number of messages in message queue                         */
S    INT16U         OSQSize;             /* Size of message queue                                       */
S    OS_PRIO        OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur         */
S    OS_PRIO        OSEventGrp;          /* Group corresponding to tasks waiting for event to occur     */
S} OS_Q_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                           SEMAPHORE DATA
N*********************************************************************************************************
N*/
N
N#if OS_SEM_EN > 0u
X#if 1u > 0u
Ntypedef struct os_sem_data {
N    INT16U  OSCnt;                          /* Semaphore count                                         */
N    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    OS_PRIO OSEventTbl[((10u) / 8u + 1u)];   
N    OS_PRIO OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N} OS_SEM_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                            TASK STACK DATA
N*********************************************************************************************************
N*/
N
N#if OS_TASK_CREATE_EXT_EN > 0u
X#if 1u > 0u
Ntypedef struct os_stk_data {
N    INT32U  OSFree;                    /* Number of free entries on the stack                          */
N    INT32U  OSUsed;                    /* Number of entries used on the stack                          */
N} OS_STK_DATA;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          TASK CONTROL BLOCK
N*********************************************************************************************************
N*/
N
Ntypedef struct os_tcb {
N    OS_STK          *OSTCBStkPtr;           /* Pointer to current top of stack                         */
N
N#if OS_TASK_CREATE_EXT_EN > 0u
X#if 1u > 0u
N    void            *OSTCBExtPtr;           /* Pointer to user definable data for TCB extension        */
N    OS_STK          *OSTCBStkBottom;        /* Pointer to bottom of stack                              */
N    INT32U           OSTCBStkSize;          /* Size of task stack (in number of stack elements)        */
N    INT16U           OSTCBOpt;              /* Task options as passed by OSTaskCreateExt()             */
N    INT16U           OSTCBId;               /* Task ID (0..65535)                                      */
N#endif
N
N    struct os_tcb   *OSTCBNext;             /* Pointer to next     TCB in the TCB list                 */
N    struct os_tcb   *OSTCBPrev;             /* Pointer to previous TCB in the TCB list                 */
N
N#if (OS_EVENT_EN)
X#if ((((0u > 0u) && (3u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
N    OS_EVENT        *OSTCBEventPtr;         /* Pointer to          event control block                 */
N#endif
N
N#if (OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u)
X#if ((((0u > 0u) && (3u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u))) && (1u > 0u)
N    OS_EVENT       **OSTCBEventMultiPtr;    /* Pointer to multiple event control blocks                */
N#endif
N
N#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
X#if ((0u > 0u) && (3u > 0u)) || (1u > 0u)
N    void            *OSTCBMsg;              /* Message received from OSMboxPost() or OSQPost()         */
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
N    OS_FLAG_NODE    *OSTCBFlagNode;         /* Pointer to event flag node                              */
N#endif
N    OS_FLAGS         OSTCBFlagsRdy;         /* Event flags that made task ready to run                 */
N#endif
N
N    INT32U           OSTCBDly;              /* Nbr ticks to delay task or, timeout waiting for event   */
N    INT8U            OSTCBStat;             /* Task      status                                        */
N    INT8U            OSTCBStatPend;         /* Task PEND status                                        */
N    INT8U            OSTCBPrio;             /* Task priority (0 == highest)                            */
N
N    INT8U            OSTCBX;                /* Bit position in group  corresponding to task priority   */
N    INT8U            OSTCBY;                /* Index into ready table corresponding to task priority   */
N    OS_PRIO          OSTCBBitX;             /* Bit mask to access bit position in ready table          */
N    OS_PRIO          OSTCBBitY;             /* Bit mask to access bit position in ready group          */
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
N    INT8U            OSTCBDelReq;           /* Indicates whether a task needs to delete itself         */
N#endif
N
N#if OS_TASK_PROFILE_EN > 0u
X#if 1u > 0u
N    INT32U           OSTCBCtxSwCtr;         /* Number of time the task was switched in                 */
N    INT32U           OSTCBCyclesTot;        /* Total number of clock cycles the task has been running  */
N    INT32U           OSTCBCyclesStart;      /* Snapshot of cycle counter at start of task resumption   */
N    OS_STK          *OSTCBStkBase;          /* Pointer to the beginning of the task stack              */
N    INT32U           OSTCBStkUsed;          /* Number of bytes used from the stack                     */
N#endif
N
N#if OS_TASK_NAME_EN > 0u
X#if 1u > 0u
N    INT8U           *OSTCBTaskName;
N#endif
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
N    INT32U           OSTCBRegTbl[OS_TASK_REG_TBL_SIZE];
X    INT32U           OSTCBRegTbl[1u];
N#endif
N} OS_TCB;
N
N/*$PAGE*/
N/*
N************************************************************************************************************************
N*                                                   TIMER DATA TYPES
N************************************************************************************************************************
N*/
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
Ntypedef  void (*OS_TMR_CALLBACK)(void *ptmr, void *parg);
N
N
N
Ntypedef  struct  os_tmr {
N    INT8U            OSTmrType;                       /* Should be set to OS_TMR_TYPE                                  */
N    OS_TMR_CALLBACK  OSTmrCallback;                   /* Function to call when timer expires                           */
N    void            *OSTmrCallbackArg;                /* Argument to pass to function when timer expires               */
N    void            *OSTmrNext;                       /* Double link list pointers                                     */
N    void            *OSTmrPrev;
N    INT32U           OSTmrMatch;                      /* Timer expires when OSTmrTime == OSTmrMatch                    */
N    INT32U           OSTmrDly;                        /* Delay time before periodic update starts                      */
N    INT32U           OSTmrPeriod;                     /* Period to repeat timer                                        */
N#if OS_TMR_CFG_NAME_EN > 0u
X#if 1u > 0u
N    INT8U           *OSTmrName;                       /* Name to give the timer                                        */
N#endif
N    INT8U            OSTmrOpt;                        /* Options (see OS_TMR_OPT_xxx)                                  */
N    INT8U            OSTmrState;                      /* Indicates the state of the timer:                             */
N                                                      /*     OS_TMR_STATE_UNUSED                                       */
N                                                      /*     OS_TMR_STATE_RUNNING                                      */
N                                                      /*     OS_TMR_STATE_STOPPED                                      */
N} OS_TMR;
N
N
N
Ntypedef  struct  os_tmr_wheel {
N    OS_TMR          *OSTmrFirst;                      /* Pointer to first timer in linked list                         */
N    INT16U           OSTmrEntries;
N} OS_TMR_WHEEL;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
NOS_EXT  INT32U            OSCtxSwCtr;               /* Counter of number of context switches           */
Xextern  INT32U            OSCtxSwCtr;                
N
N#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
X#if ((((0u > 0u) && (3u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u))) && (10u > 0u)
NOS_EXT  OS_EVENT         *OSEventFreeList;          /* Pointer to list of free EVENT control blocks    */
Xextern  OS_EVENT         *OSEventFreeList;           
NOS_EXT  OS_EVENT          OSEventTbl[OS_MAX_EVENTS];/* Table of EVENT control blocks                   */
Xextern  OS_EVENT          OSEventTbl[10u]; 
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
NOS_EXT  OS_FLAG_GRP       OSFlagTbl[OS_MAX_FLAGS];  /* Table containing event flag groups              */
Xextern  OS_FLAG_GRP       OSFlagTbl[5u];   
NOS_EXT  OS_FLAG_GRP      *OSFlagFreeList;           /* Pointer to free list of event flag groups       */
Xextern  OS_FLAG_GRP      *OSFlagFreeList;            
N#endif
N
N#if OS_TASK_STAT_EN > 0u
X#if 1u > 0u
NOS_EXT  INT8U             OSCPUUsage;               /* Percentage of CPU used                          */
Xextern  INT8U             OSCPUUsage;                
NOS_EXT  INT32U            OSIdleCtrMax;             /* Max. value that idle ctr can take in 1 sec.     */
Xextern  INT32U            OSIdleCtrMax;              
NOS_EXT  INT32U            OSIdleCtrRun;             /* Val. reached by idle ctr at run time in 1 sec.  */
Xextern  INT32U            OSIdleCtrRun;              
NOS_EXT  BOOLEAN           OSStatRdy;                /* Flag indicating that the statistic task is rdy  */
Xextern  BOOLEAN           OSStatRdy;                 
NOS_EXT  OS_STK            OSTaskStatStk[OS_TASK_STAT_STK_SIZE];      /* Statistics task stack          */
Xextern  OS_STK            OSTaskStatStk[15u];       
N#endif
N
NOS_EXT  INT8U             OSIntNesting;             /* Interrupt nesting level                         */
Xextern  INT8U             OSIntNesting;              
N
NOS_EXT  INT8U             OSLockNesting;            /* Multitasking lock nesting level                 */
Xextern  INT8U             OSLockNesting;             
N
NOS_EXT  INT8U             OSPrioCur;                /* Priority of current task                        */
Xextern  INT8U             OSPrioCur;                 
NOS_EXT  INT8U             OSPrioHighRdy;            /* Priority of highest priority task               */
Xextern  INT8U             OSPrioHighRdy;             
N
NOS_EXT  OS_PRIO           OSRdyGrp;                        /* Ready list group                         */
Xextern  OS_PRIO           OSRdyGrp;                         
NOS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];       /* Table of tasks which are ready to run    */
Xextern  OS_PRIO           OSRdyTbl[((10u) / 8u + 1u)];        
N
NOS_EXT  BOOLEAN           OSRunning;                       /* Flag indicating that kernel is running   */
Xextern  BOOLEAN           OSRunning;                        
N
NOS_EXT  INT8U             OSTaskCtr;                       /* Number of tasks created                  */
Xextern  INT8U             OSTaskCtr;                        
N
NOS_EXT  volatile  INT32U  OSIdleCtr;                                 /* Idle counter                   */
Xextern  volatile  INT32U  OSIdleCtr;                                  
N
N#ifdef OS_SAFETY_CRITICAL_IEC61508
SOS_EXT  BOOLEAN           OSSafetyCriticalStartFlag;
N#endif
N
NOS_EXT  OS_STK            OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE];      /* Idle task stack                */
Xextern  OS_STK            OSTaskIdleStk[15u];       
N
N
NOS_EXT  OS_TCB           *OSTCBCur;                        /* Pointer to currently running TCB         */
Xextern  OS_TCB           *OSTCBCur;                         
NOS_EXT  OS_TCB           *OSTCBFreeList;                   /* Pointer to list of free TCBs             */
Xextern  OS_TCB           *OSTCBFreeList;                    
NOS_EXT  OS_TCB           *OSTCBHighRdy;                    /* Pointer to highest priority TCB R-to-R   */
Xextern  OS_TCB           *OSTCBHighRdy;                     
NOS_EXT  OS_TCB           *OSTCBList;                       /* Pointer to doubly linked list of TCBs    */
Xextern  OS_TCB           *OSTCBList;                        
NOS_EXT  OS_TCB           *OSTCBPrioTbl[OS_LOWEST_PRIO + 1u];    /* Table of pointers to created TCBs   */
Xextern  OS_TCB           *OSTCBPrioTbl[10u + 1u];     
NOS_EXT  OS_TCB            OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];   /* Table of TCBs                  */
Xextern  OS_TCB            OSTCBTbl[7u + 2u];    
N
N#if OS_TICK_STEP_EN > 0u
X#if 1u > 0u
NOS_EXT  INT8U             OSTickStepState;          /* Indicates the state of the tick step feature    */
Xextern  INT8U             OSTickStepState;           
N#endif
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
NOS_EXT  OS_MEM           *OSMemFreeList;            /* Pointer to free list of memory partitions       */
Xextern  OS_MEM           *OSMemFreeList;             
NOS_EXT  OS_MEM            OSMemTbl[OS_MAX_MEM_PART];/* Storage for memory partition manager            */
Xextern  OS_MEM            OSMemTbl[5u]; 
N#endif
N
N#if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
X#if (0u > 0u) && (3u > 0u)
SOS_EXT  OS_Q             *OSQFreeList;              /* Pointer to list of free QUEUE control blocks    */
SOS_EXT  OS_Q              OSQTbl[OS_MAX_QS];        /* Table of QUEUE control blocks                   */
N#endif
N
N#if OS_TIME_GET_SET_EN > 0u
X#if 1u > 0u
NOS_EXT  volatile  INT32U  OSTime;                   /* Current value of system time (in ticks)         */
Xextern  volatile  INT32U  OSTime;                    
N#endif
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
NOS_EXT  INT16U            OSTmrFree;                /* Number of free entries in the timer pool        */
Xextern  INT16U            OSTmrFree;                 
NOS_EXT  INT16U            OSTmrUsed;                /* Number of timers used                           */
Xextern  INT16U            OSTmrUsed;                 
NOS_EXT  INT32U            OSTmrTime;                /* Current timer time                              */
Xextern  INT32U            OSTmrTime;                 
N
NOS_EXT  OS_EVENT         *OSTmrSem;                 /* Sem. used to gain exclusive access to timers    */
Xextern  OS_EVENT         *OSTmrSem;                  
NOS_EXT  OS_EVENT         *OSTmrSemSignal;           /* Sem. used to signal the update of timers        */
Xextern  OS_EVENT         *OSTmrSemSignal;            
N
NOS_EXT  OS_TMR            OSTmrTbl[OS_TMR_CFG_MAX]; /* Table containing pool of timers                 */
Xextern  OS_TMR            OSTmrTbl[8u];  
NOS_EXT  OS_TMR           *OSTmrFreeList;            /* Pointer to free list of timers                  */
Xextern  OS_TMR           *OSTmrFreeList;             
NOS_EXT  OS_STK            OSTmrTaskStk[OS_TASK_TMR_STK_SIZE];
Xextern  OS_STK            OSTmrTaskStk[15u];
N
NOS_EXT  OS_TMR_WHEEL      OSTmrWheelTbl[OS_TMR_CFG_WHEEL_SIZE];
Xextern  OS_TMR_WHEEL      OSTmrWheelTbl[8u];
N#endif
N
Nextern  INT8U   const     OSUnMapTbl[256];          /* Priority->Index    lookup table                 */
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                     (Target Independent Functions)
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#if (OS_EVENT_EN)
X#if ((((0u > 0u) && (3u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
N
N#if (OS_EVENT_NAME_EN > 0u)
X#if (1u > 0u)
NINT8U         OSEventNameGet          (OS_EVENT        *pevent,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSEventNameSet          (OS_EVENT        *pevent,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
N#if (OS_EVENT_MULTI_EN > 0u)
X#if (1u > 0u)
NINT16U        OSEventPendMulti        (OS_EVENT       **pevents_pend,
N                                       OS_EVENT       **pevents_rdy,
N                                       void           **pmsgs_rdy,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N#endif
N
N#endif
N
N/*
N*********************************************************************************************************
N*                                         EVENT FLAGS MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N
N#if OS_FLAG_ACCEPT_EN > 0u
X#if 1u > 0u
NOS_FLAGS      OSFlagAccept            (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            wait_type,
N                                       INT8U           *perr);
N#endif
N
NOS_FLAG_GRP  *OSFlagCreate            (OS_FLAGS         flags,
N                                       INT8U           *perr);
N
N#if OS_FLAG_DEL_EN > 0u
X#if 1u > 0u
NOS_FLAG_GRP  *OSFlagDel               (OS_FLAG_GRP     *pgrp,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_FLAG_NAME_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
NINT8U         OSFlagNameGet           (OS_FLAG_GRP     *pgrp,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSFlagNameSet           (OS_FLAG_GRP     *pgrp,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
NOS_FLAGS      OSFlagPend              (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            wait_type,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
NOS_FLAGS      OSFlagPendGetFlagsRdy   (void);
NOS_FLAGS      OSFlagPost              (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N
N#if OS_FLAG_QUERY_EN > 0u
X#if 1u > 0u
NOS_FLAGS      OSFlagQuery             (OS_FLAG_GRP     *pgrp,
N                                       INT8U           *perr);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                        MESSAGE MAILBOX MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_MBOX_EN > 0u
X#if 1u > 0u
N
N#if OS_MBOX_ACCEPT_EN > 0u
X#if 1u > 0u
Nvoid         *OSMboxAccept            (OS_EVENT        *pevent);
N#endif
N
NOS_EVENT     *OSMboxCreate            (void            *pmsg);
N
N#if OS_MBOX_DEL_EN > 0u
X#if 1u > 0u
NOS_EVENT     *OSMboxDel               (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid         *OSMboxPend              (OS_EVENT        *pevent,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
N#if OS_MBOX_PEND_ABORT_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxPendAbort         (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if OS_MBOX_POST_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxPost              (OS_EVENT        *pevent,
N                                       void            *pmsg);
N#endif
N
N#if OS_MBOX_POST_OPT_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxPostOpt           (OS_EVENT        *pevent,
N                                       void            *pmsg,
N                                       INT8U            opt);
N#endif
N
N#if OS_MBOX_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxQuery             (OS_EVENT        *pevent,
N                                       OS_MBOX_DATA    *p_mbox_data);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           MEMORY MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
N
NOS_MEM       *OSMemCreate             (void            *addr,
N                                       INT32U           nblks,
N                                       INT32U           blksize,
N                                       INT8U           *perr);
N
Nvoid         *OSMemGet                (OS_MEM          *pmem,
N                                       INT8U           *perr);
N#if OS_MEM_NAME_EN > 0u
X#if 1u > 0u
NINT8U         OSMemNameGet            (OS_MEM          *pmem,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSMemNameSet            (OS_MEM          *pmem,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
NINT8U         OSMemPut                (OS_MEM          *pmem,
N                                       void            *pblk);
N
N#if OS_MEM_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSMemQuery              (OS_MEM          *pmem,
N                                       OS_MEM_DATA     *p_mem_data);
N#endif
N
N#endif
N
N/*
N*********************************************************************************************************
N*                                MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_MUTEX_EN > 0u
X#if 1u > 0u
N
N#if OS_MUTEX_ACCEPT_EN > 0u
X#if 1u > 0u
NBOOLEAN       OSMutexAccept           (OS_EVENT        *pevent,
N                                       INT8U           *perr);
N#endif
N
NOS_EVENT     *OSMutexCreate           (INT8U            prio,
N                                       INT8U           *perr);
N
N#if OS_MUTEX_DEL_EN > 0u
X#if 1u > 0u
NOS_EVENT     *OSMutexDel              (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid          OSMutexPend             (OS_EVENT        *pevent,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
NINT8U         OSMutexPost             (OS_EVENT        *pevent);
N
N#if OS_MUTEX_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSMutexQuery            (OS_EVENT        *pevent,
N                                       OS_MUTEX_DATA   *p_mutex_data);
N#endif
N
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         MESSAGE QUEUE MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
X#if (0u > 0u) && (3u > 0u)
S
S#if OS_Q_ACCEPT_EN > 0u
Svoid         *OSQAccept               (OS_EVENT        *pevent,
S                                       INT8U           *perr);
S#endif
S
SOS_EVENT     *OSQCreate               (void           **start,
S                                       INT16U           size);
S
S#if OS_Q_DEL_EN > 0u
SOS_EVENT     *OSQDel                  (OS_EVENT        *pevent,
S                                       INT8U            opt,
S                                       INT8U           *perr);
S#endif
S
S#if OS_Q_FLUSH_EN > 0u
SINT8U         OSQFlush                (OS_EVENT        *pevent);
S#endif
S
Svoid         *OSQPend                 (OS_EVENT        *pevent,
S                                       INT32U           timeout,
S                                       INT8U           *perr);
S
S#if OS_Q_PEND_ABORT_EN > 0u
SINT8U         OSQPendAbort            (OS_EVENT        *pevent,
S                                       INT8U            opt,
S                                       INT8U           *perr);
S#endif
S
S#if OS_Q_POST_EN > 0u
SINT8U         OSQPost                 (OS_EVENT        *pevent,
S                                       void            *pmsg);
S#endif
S
S#if OS_Q_POST_FRONT_EN > 0u
SINT8U         OSQPostFront            (OS_EVENT        *pevent,
S                                       void            *pmsg);
S#endif
S
S#if OS_Q_POST_OPT_EN > 0u
SINT8U         OSQPostOpt              (OS_EVENT        *pevent,
S                                       void            *pmsg,
S                                       INT8U            opt);
S#endif
S
S#if OS_Q_QUERY_EN > 0u
SINT8U         OSQQuery                (OS_EVENT        *pevent,
S                                       OS_Q_DATA       *p_q_data);
S#endif
S
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          SEMAPHORE MANAGEMENT
N*********************************************************************************************************
N*/
N#if OS_SEM_EN > 0u
X#if 1u > 0u
N
N#if OS_SEM_ACCEPT_EN > 0u
X#if 1u > 0u
NINT16U        OSSemAccept             (OS_EVENT        *pevent);
N#endif
N
NOS_EVENT     *OSSemCreate             (INT16U           cnt);
N
N#if OS_SEM_DEL_EN > 0u
X#if 1u > 0u
NOS_EVENT     *OSSemDel                (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid          OSSemPend               (OS_EVENT        *pevent,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
N#if OS_SEM_PEND_ABORT_EN > 0u
X#if 1u > 0u
NINT8U         OSSemPendAbort          (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
NINT8U         OSSemPost               (OS_EVENT        *pevent);
N
N#if OS_SEM_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSSemQuery              (OS_EVENT        *pevent,
N                                       OS_SEM_DATA     *p_sem_data);
N#endif
N
N#if OS_SEM_SET_EN > 0u
X#if 1u > 0u
Nvoid          OSSemSet                (OS_EVENT        *pevent,
N                                       INT16U           cnt,
N                                       INT8U           *perr);
N#endif
N
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            TASK MANAGEMENT
N*********************************************************************************************************
N*/
N#if OS_TASK_CHANGE_PRIO_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskChangePrio        (INT8U            oldprio,
N                                       INT8U            newprio);
N#endif
N
N#if OS_TASK_CREATE_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskCreate            (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT8U            prio);
N#endif
N
N#if OS_TASK_CREATE_EXT_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskCreateExt         (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT8U            prio,
N                                       INT16U           id,
N                                       OS_STK          *pbos,
N                                       INT32U           stk_size,
N                                       void            *pext,
N                                       INT16U           opt);
N#endif
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskDel               (INT8U            prio);
NINT8U         OSTaskDelReq            (INT8U            prio);
N#endif
N
N#if OS_TASK_NAME_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskNameGet           (INT8U            prio,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSTaskNameSet           (INT8U            prio,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
N#if OS_TASK_SUSPEND_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskResume            (INT8U            prio);
NINT8U         OSTaskSuspend           (INT8U            prio);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
NINT8U         OSTaskStkChk            (INT8U            prio,
N                                       OS_STK_DATA     *p_stk_data);
N#endif
N
N#if OS_TASK_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskQuery             (INT8U            prio,
N                                       OS_TCB          *p_task_data);
N#endif
N
N
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
NINT32U        OSTaskRegGet            (INT8U            prio,
N                                       INT8U            id,
N                                       INT8U           *perr);
N
Nvoid          OSTaskRegSet            (INT8U            prio,
N                                       INT8U            id,
N                                       INT32U           value,
N                                       INT8U           *perr);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            TIME MANAGEMENT
N*********************************************************************************************************
N*/
N
Nvoid          OSTimeDly               (INT32U           ticks);
N
N#if OS_TIME_DLY_HMSM_EN > 0u
X#if 1u > 0u
NINT8U         OSTimeDlyHMSM           (INT8U            hours,
N                                       INT8U            minutes,
N                                       INT8U            seconds,
N                                       INT16U           ms);
N#endif
N
N#if OS_TIME_DLY_RESUME_EN > 0u
X#if 1u > 0u
NINT8U         OSTimeDlyResume         (INT8U            prio);
N#endif
N
N#if OS_TIME_GET_SET_EN > 0u
X#if 1u > 0u
NINT32U        OSTimeGet               (void);
Nvoid          OSTimeSet               (INT32U           ticks);
N#endif
N
Nvoid          OSTimeTick              (void);
N
N/*
N*********************************************************************************************************
N*                                            TIMER MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
NOS_TMR      *OSTmrCreate              (INT32U           dly,
N                                       INT32U           period,
N                                       INT8U            opt,
N                                       OS_TMR_CALLBACK  callback,
N                                       void            *callback_arg,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N
NBOOLEAN      OSTmrDel                 (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
N#if OS_TMR_CFG_NAME_EN > 0u
X#if 1u > 0u
NINT8U        OSTmrNameGet             (OS_TMR          *ptmr,
N                                       INT8U          **pdest,
N                                       INT8U           *perr);
N#endif
NINT32U       OSTmrRemainGet           (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
NINT8U        OSTmrStateGet            (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
NBOOLEAN      OSTmrStart               (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
NBOOLEAN      OSTmrStop                (OS_TMR          *ptmr,
N                                       INT8U            opt,
N                                       void            *callback_arg,
N                                       INT8U           *perr);
N
NINT8U        OSTmrSignal              (void);
N#endif
N
N/*
N*********************************************************************************************************
N*                                             MISCELLANEOUS
N*********************************************************************************************************
N*/
N
Nvoid          OSInit                  (void);
N
Nvoid          OSIntEnter              (void);
Nvoid          OSIntExit               (void);
N
N#ifdef OS_SAFETY_CRITICAL_IEC61508
Svoid          OSSafetyCriticalStart   (void);
N#endif
N
N#if OS_SCHED_LOCK_EN > 0u
X#if 1u > 0u
Nvoid          OSSchedLock             (void);
Nvoid          OSSchedUnlock           (void);
N#endif
N
Nvoid          OSStart                 (void);
N
Nvoid          OSStatInit              (void);
N
NINT16U        OSVersion               (void);
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                      INTERNAL FUNCTION PROTOTYPES
N*                            (Your application MUST NOT call these functions)
N*********************************************************************************************************
N*/
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
Nvoid          OS_Dummy                (void);
N#endif
N
N#if (OS_EVENT_EN)
X#if ((((0u > 0u) && (3u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
NINT8U         OS_EventTaskRdy         (OS_EVENT        *pevent,
N                                       void            *pmsg,
N                                       INT8U            msk,
N                                       INT8U            pend_stat);
N
Nvoid          OS_EventTaskWait        (OS_EVENT        *pevent);
N
Nvoid          OS_EventTaskRemove      (OS_TCB          *ptcb,
N                                       OS_EVENT        *pevent);
N
N#if (OS_EVENT_MULTI_EN > 0u)
X#if (1u > 0u)
Nvoid          OS_EventTaskWaitMulti   (OS_EVENT       **pevents_wait);
N
Nvoid          OS_EventTaskRemoveMulti (OS_TCB          *ptcb,
N                                       OS_EVENT       **pevents_multi);
N#endif
N
Nvoid          OS_EventWaitListInit    (OS_EVENT        *pevent);
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
Nvoid          OS_FlagInit             (void);
Nvoid          OS_FlagUnlink           (OS_FLAG_NODE    *pnode);
N#endif
N
Nvoid          OS_MemClr               (INT8U           *pdest,
N                                       INT16U           size);
N
Nvoid          OS_MemCopy              (INT8U           *pdest,
N                                       INT8U           *psrc,
N                                       INT16U           size);
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
Nvoid          OS_MemInit              (void);
N#endif
N
N#if OS_Q_EN > 0u
X#if 0u > 0u
Svoid          OS_QInit                (void);
N#endif
N
Nvoid          OS_Sched                (void);
N
N#if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u)
X#if (1u > 0u) || (1u > 0u) || (1u > 0u) || (1u > 0u)
NINT8U         OS_StrLen               (INT8U           *psrc);
N#endif
N
Nvoid          OS_TaskIdle             (void            *p_arg);
N
Nvoid          OS_TaskReturn           (void);
N
N#if OS_TASK_STAT_EN > 0u
X#if 1u > 0u
Nvoid          OS_TaskStat             (void            *p_arg);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
Nvoid          OS_TaskStkClr           (OS_STK          *pbos,
N                                       INT32U           size,
N                                       INT16U           opt);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
Nvoid          OS_TaskStatStkChk       (void);
N#endif
N
NINT8U         OS_TCBInit              (INT8U            prio,
N                                       OS_STK          *ptos,
N                                       OS_STK          *pbos,
N                                       INT16U           id,
N                                       INT32U           stk_size,
N                                       void            *pext,
N                                       INT16U           opt);
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
Nvoid          OSTmr_Init              (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                      (Target Specific Functions)
N*********************************************************************************************************
N*/
N
N#if OS_DEBUG_EN > 0u
X#if 1u > 0u
Nvoid          OSDebugInit             (void);
N#endif
N
Nvoid          OSInitHookBegin         (void);
Nvoid          OSInitHookEnd           (void);
N
Nvoid          OSTaskCreateHook        (OS_TCB          *ptcb);
Nvoid          OSTaskDelHook           (OS_TCB          *ptcb);
N
Nvoid          OSTaskIdleHook          (void);
N
Nvoid          OSTaskReturnHook        (OS_TCB          *ptcb);
N
Nvoid          OSTaskStatHook          (void);
NOS_STK       *OSTaskStkInit           (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT16U           opt);
N
N#if OS_TASK_SW_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          OSTaskSwHook            (void);
N#endif
N
Nvoid          OSTCBInitHook           (OS_TCB          *ptcb);
N
N#if OS_TIME_TICK_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          OSTimeTickHook          (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                   (Application Specific Functions)
N*********************************************************************************************************
N*/
N
N#if OS_APP_HOOKS_EN > 0u
X#if 1u > 0u
Nvoid          App_TaskCreateHook      (OS_TCB          *ptcb);
Nvoid          App_TaskDelHook         (OS_TCB          *ptcb);
Nvoid          App_TaskIdleHook        (void);
N
Nvoid          App_TaskReturnHook      (OS_TCB          *ptcb);
N
Nvoid          App_TaskStatHook        (void);
N
N#if OS_TASK_SW_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          App_TaskSwHook          (void);
N#endif
N
Nvoid          App_TCBInitHook         (OS_TCB          *ptcb);
N
N#if OS_TIME_TICK_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          App_TimeTickHook        (void);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*
N* IMPORTANT: These prototypes MUST be placed in OS_CPU.H
N*********************************************************************************************************
N*/
N
N#if 0
Svoid          OSStartHighRdy          (void);
Svoid          OSIntCtxSw              (void);
Svoid          OSCtxSw                 (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   LOOK FOR MISSING #define CONSTANTS
N*
N* This section is used to generate ERROR messages at compile time if certain #define constants are
N* MISSING in OS_CFG.H.  This allows you to quickly determine the source of the error.
N*
N* You SHOULD NOT change this section UNLESS you would like to add more comments as to the source of the
N* compile time error.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            EVENT FLAGS
N*********************************************************************************************************
N*/
N
N#ifndef OS_FLAG_EN
S#error  "OS_CFG.H, Missing OS_FLAG_EN: Enable (1) or Disable (0) code generation for Event Flags"
N#else
N    #ifndef OS_MAX_FLAGS
S    #error  "OS_CFG.H, Missing OS_MAX_FLAGS: Max. number of Event Flag Groups in your application"
N    #else
N        #if     OS_MAX_FLAGS > 65500u
X        #if     5u > 65500u
S        #error  "OS_CFG.H, OS_MAX_FLAGS must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_FLAGS_NBITS
S    #error  "OS_CFG.H, Missing OS_FLAGS_NBITS: Determine #bits used for event flags, MUST be either 8, 16 or 32"
N    #endif
N
N    #ifndef OS_FLAG_WAIT_CLR_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_WAIT_CLR_EN: Include code for Wait on Clear EVENT FLAGS"
N    #endif
N
N    #ifndef OS_FLAG_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_ACCEPT_EN: Include code for OSFlagAccept()"
N    #endif
N
N    #ifndef OS_FLAG_DEL_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_DEL_EN: Include code for OSFlagDel()"
N    #endif
N
N    #ifndef OS_FLAG_NAME_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_NAME_EN: Enable flag group names"
N    #endif
N
N    #ifndef OS_FLAG_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_QUERY_EN: Include code for OSFlagQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           MESSAGE MAILBOXES
N*********************************************************************************************************
N*/
N
N#ifndef OS_MBOX_EN
S#error  "OS_CFG.H, Missing OS_MBOX_EN: Enable (1) or Disable (0) code generation for MAILBOXES"
N#else
N    #ifndef OS_MBOX_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_ACCEPT_EN: Include code for OSMboxAccept()"
N    #endif
N
N    #ifndef OS_MBOX_DEL_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_DEL_EN: Include code for OSMboxDel()"
N    #endif
N
N    #ifndef OS_MBOX_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_PEND_ABORT_EN: Include code for OSMboxPendAbort()"
N    #endif
N
N    #ifndef OS_MBOX_POST_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_POST_EN: Include code for OSMboxPost()"
N    #endif
N
N    #ifndef OS_MBOX_POST_OPT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_POST_OPT_EN: Include code for OSMboxPostOpt()"
N    #endif
N
N    #ifndef OS_MBOX_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_QUERY_EN: Include code for OSMboxQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           MEMORY MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_MEM_EN
S#error  "OS_CFG.H, Missing OS_MEM_EN: Enable (1) or Disable (0) code generation for MEMORY MANAGER"
N#else
N    #ifndef OS_MAX_MEM_PART
S    #error  "OS_CFG.H, Missing OS_MAX_MEM_PART: Max. number of memory partitions"
N    #else
N        #if     OS_MAX_MEM_PART > 65500u
X        #if     5u > 65500u
S        #error  "OS_CFG.H, OS_MAX_MEM_PART must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_MEM_NAME_EN
S    #error  "OS_CFG.H, Missing OS_MEM_NAME_EN: Enable memory partition names"
N    #endif
N
N    #ifndef OS_MEM_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MEM_QUERY_EN: Include code for OSMemQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                       MUTUAL EXCLUSION SEMAPHORES
N*********************************************************************************************************
N*/
N
N#ifndef OS_MUTEX_EN
S#error  "OS_CFG.H, Missing OS_MUTEX_EN: Enable (1) or Disable (0) code generation for MUTEX"
N#else
N    #ifndef OS_MUTEX_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_ACCEPT_EN: Include code for OSMutexAccept()"
N    #endif
N
N    #ifndef OS_MUTEX_DEL_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_DEL_EN: Include code for OSMutexDel()"
N    #endif
N
N    #ifndef OS_MUTEX_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_QUERY_EN: Include code for OSMutexQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                              MESSAGE QUEUES
N*********************************************************************************************************
N*/
N
N#ifndef OS_Q_EN
S#error  "OS_CFG.H, Missing OS_Q_EN: Enable (1) or Disable (0) code generation for QUEUES"
N#else
N    #ifndef OS_MAX_QS
S    #error  "OS_CFG.H, Missing OS_MAX_QS: Max. number of queue control blocks"
N    #else
N        #if     OS_MAX_QS > 65500u
X        #if     3u > 65500u
S        #error  "OS_CFG.H, OS_MAX_QS must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_Q_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_Q_ACCEPT_EN: Include code for OSQAccept()"
N    #endif
N
N    #ifndef OS_Q_DEL_EN
S    #error  "OS_CFG.H, Missing OS_Q_DEL_EN: Include code for OSQDel()"
N    #endif
N
N    #ifndef OS_Q_FLUSH_EN
S    #error  "OS_CFG.H, Missing OS_Q_FLUSH_EN: Include code for OSQFlush()"
N    #endif
N
N    #ifndef OS_Q_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_Q_PEND_ABORT_EN: Include code for OSQPendAbort()"
N    #endif
N
N    #ifndef OS_Q_POST_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_EN: Include code for OSQPost()"
N    #endif
N
N    #ifndef OS_Q_POST_FRONT_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_FRONT_EN: Include code for OSQPostFront()"
N    #endif
N
N    #ifndef OS_Q_POST_OPT_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_OPT_EN: Include code for OSQPostOpt()"
N    #endif
N
N    #ifndef OS_Q_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_Q_QUERY_EN: Include code for OSQQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                              SEMAPHORES
N*********************************************************************************************************
N*/
N
N#ifndef OS_SEM_EN
S#error  "OS_CFG.H, Missing OS_SEM_EN: Enable (1) or Disable (0) code generation for SEMAPHORES"
N#else
N    #ifndef OS_SEM_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_SEM_ACCEPT_EN: Include code for OSSemAccept()"
N    #endif
N
N    #ifndef OS_SEM_DEL_EN
S    #error  "OS_CFG.H, Missing OS_SEM_DEL_EN: Include code for OSSemDel()"
N    #endif
N
N    #ifndef OS_SEM_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_SEM_PEND_ABORT_EN: Include code for OSSemPendAbort()"
N    #endif
N
N    #ifndef OS_SEM_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_SEM_QUERY_EN: Include code for OSSemQuery()"
N    #endif
N
N    #ifndef OS_SEM_SET_EN
S    #error  "OS_CFG.H, Missing OS_SEM_SET_EN: Include code for OSSemSet()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                             TASK MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_MAX_TASKS
S#error  "OS_CFG.H, Missing OS_MAX_TASKS: Max. number of tasks in your application"
N#else
N    #if     OS_MAX_TASKS < 2u
X    #if     7u < 2u
S    #error  "OS_CFG.H,         OS_MAX_TASKS must be >= 2"
N    #endif
N
N    #if     OS_MAX_TASKS >  ((OS_LOWEST_PRIO - OS_N_SYS_TASKS) + 1u)
X    #if     7u >  ((10u - 2u) + 1u)
S    #error  "OS_CFG.H,         OS_MAX_TASKS must be <= OS_LOWEST_PRIO - OS_N_SYS_TASKS + 1"
N    #endif
N
N#endif
N
N#if     OS_LOWEST_PRIO >  254u
X#if     10u >  254u
S#error  "OS_CFG.H,         OS_LOWEST_PRIO must be <= 254 in V2.8x and higher"
N#endif
N
N#ifndef OS_TASK_IDLE_STK_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_IDLE_STK_SIZE: Idle task stack size"
N#endif
N
N#ifndef OS_TASK_STAT_EN
S#error  "OS_CFG.H, Missing OS_TASK_STAT_EN: Enable (1) or Disable(0) the statistics task"
N#endif
N
N#ifndef OS_TASK_STAT_STK_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_STAT_STK_SIZE: Statistics task stack size"
N#endif
N
N#ifndef OS_TASK_STAT_STK_CHK_EN
S#error  "OS_CFG.H, Missing OS_TASK_STAT_STK_CHK_EN: Check task stacks from statistics task"
N#endif
N
N#ifndef OS_TASK_CHANGE_PRIO_EN
S#error  "OS_CFG.H, Missing OS_TASK_CHANGE_PRIO_EN: Include code for OSTaskChangePrio()"
N#endif
N
N#ifndef OS_TASK_CREATE_EN
S#error  "OS_CFG.H, Missing OS_TASK_CREATE_EN: Include code for OSTaskCreate()"
N#endif
N
N#ifndef OS_TASK_CREATE_EXT_EN
S#error  "OS_CFG.H, Missing OS_TASK_CREATE_EXT_EN: Include code for OSTaskCreateExt()"
N#endif
N
N#ifndef OS_TASK_DEL_EN
S#error  "OS_CFG.H, Missing OS_TASK_DEL_EN: Include code for OSTaskDel()"
N#endif
N
N#ifndef OS_TASK_NAME_EN
S#error  "OS_CFG.H, Missing OS_TASK_NAME_EN: Enable task names"
N#endif
N
N#ifndef OS_TASK_SUSPEND_EN
S#error  "OS_CFG.H, Missing OS_TASK_SUSPEND_EN: Include code for OSTaskSuspend() and OSTaskResume()"
N#endif
N
N#ifndef OS_TASK_QUERY_EN
S#error  "OS_CFG.H, Missing OS_TASK_QUERY_EN: Include code for OSTaskQuery()"
N#endif
N
N#ifndef OS_TASK_REG_TBL_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_REG_TBL_SIZE: Include code for task specific registers"
N#else
N    #if     OS_TASK_REG_TBL_SIZE > 255u
X    #if     1u > 255u
S    #error  "OS_CFG.H,         OS_TASK_REG_TBL_SIZE must be <= 255"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                             TIME MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_TICKS_PER_SEC
S#error  "OS_CFG.H, Missing OS_TICKS_PER_SEC: Sets the number of ticks in one second"
N#endif
N
N#ifndef OS_TIME_DLY_HMSM_EN
S#error  "OS_CFG.H, Missing OS_TIME_DLY_HMSM_EN: Include code for OSTimeDlyHMSM()"
N#endif
N
N#ifndef OS_TIME_DLY_RESUME_EN
S#error  "OS_CFG.H, Missing OS_TIME_DLY_RESUME_EN: Include code for OSTimeDlyResume()"
N#endif
N
N#ifndef OS_TIME_GET_SET_EN
S#error  "OS_CFG.H, Missing OS_TIME_GET_SET_EN: Include code for OSTimeGet() and OSTimeSet()"
N#endif
N
N/*
N*********************************************************************************************************
N*                                             TIMER MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_TMR_EN
S#error  "OS_CFG.H, Missing OS_TMR_EN: When (1) enables code generation for Timer Management"
N#elif   OS_TMR_EN > 0u
X#elif   1u > 0u
N    #if     OS_SEM_EN == 0u
X    #if     1u == 0u
S    #error  "OS_CFG.H, Semaphore management is required (set OS_SEM_EN to 1) when enabling Timer Management."
S    #error  "          Timer management require TWO semaphores."
N    #endif
N
N    #ifndef OS_TMR_CFG_MAX
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_MAX: Determines the total number of timers in an application (2 .. 65500)"
N    #else
N        #if OS_TMR_CFG_MAX < 2u
X        #if 8u < 2u
S        #error  "OS_CFG.H, OS_TMR_CFG_MAX should be between 2 and 65500"
N        #endif
N
N        #if OS_TMR_CFG_MAX > 65500u
X        #if 8u > 65500u
S        #error  "OS_CFG.H, OS_TMR_CFG_MAX should be between 2 and 65500"
N        #endif
N    #endif
N
N    #ifndef OS_TMR_CFG_WHEEL_SIZE
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_WHEEL_SIZE: Sets the size of the timer wheel (1 .. 1023)"
N    #else
N        #if OS_TMR_CFG_WHEEL_SIZE < 2u
X        #if 8u < 2u
S        #error  "OS_CFG.H, OS_TMR_CFG_WHEEL_SIZE should be between 2 and 1024"
N        #endif
N
N        #if OS_TMR_CFG_WHEEL_SIZE > 1024u
X        #if 8u > 1024u
S        #error  "OS_CFG.H, OS_TMR_CFG_WHEEL_SIZE should be between 2 and 1024"
N        #endif
N    #endif
N
N    #ifndef OS_TMR_CFG_NAME_EN
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_NAME_EN: Enable Timer names"
N    #endif
N
N    #ifndef OS_TMR_CFG_TICKS_PER_SEC
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_TICKS_PER_SEC: Determines the rate at which tiem timer management task will run (Hz)"
N    #endif
N
N    #ifndef OS_TASK_TMR_STK_SIZE
S    #error  "OS_CFG.H, Missing OS_TASK_TMR_STK_SIZE: Determines the size of the Timer Task's stack"
N    #endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#ifndef OS_ARG_CHK_EN
S#error  "OS_CFG.H, Missing OS_ARG_CHK_EN: Enable (1) or Disable (0) argument checking"
N#endif
N
N
N#ifndef OS_CPU_HOOKS_EN
S#error  "OS_CFG.H, Missing OS_CPU_HOOKS_EN: uC/OS-II hooks are found in the processor port files when 1"
N#endif
N
N
N#ifndef OS_APP_HOOKS_EN
S#error  "OS_CFG.H, Missing OS_APP_HOOKS_EN: Application-defined hooks are called from the uC/OS-II hooks"
N#endif
N
N
N#ifndef OS_DEBUG_EN
S#error  "OS_CFG.H, Missing OS_DEBUG_EN: Allows you to include variables for debugging or not"
N#endif
N
N
N#ifndef OS_LOWEST_PRIO
S#error  "OS_CFG.H, Missing OS_LOWEST_PRIO: Defines the lowest priority that can be assigned"
N#endif
N
N
N#ifndef OS_MAX_EVENTS
S#error  "OS_CFG.H, Missing OS_MAX_EVENTS: Max. number of event control blocks in your application"
N#else
N    #if     OS_MAX_EVENTS > 65500u
X    #if     10u > 65500u
S    #error  "OS_CFG.H, OS_MAX_EVENTS must be <= 65500"
N    #endif
N#endif
N
N
N#ifndef OS_SCHED_LOCK_EN
S#error  "OS_CFG.H, Missing OS_SCHED_LOCK_EN: Include code for OSSchedLock() and OSSchedUnlock()"
N#endif
N
N
N#ifndef OS_EVENT_MULTI_EN
S#error  "OS_CFG.H, Missing OS_EVENT_MULTI_EN: Include code for OSEventPendMulti()"
N#endif
N
N
N#ifndef OS_TASK_PROFILE_EN
S#error  "OS_CFG.H, Missing OS_TASK_PROFILE_EN: Include data structure for run-time task profiling"
N#endif
N
N
N#ifndef OS_TASK_SW_HOOK_EN
S#error  "OS_CFG.H, Missing OS_TASK_SW_HOOK_EN: Allows you to include the code for OSTaskSwHook() or not"
N#endif
N
N
N#ifndef OS_TICK_STEP_EN
S#error  "OS_CFG.H, Missing OS_TICK_STEP_EN: Allows to 'step' one tick at a time with uC/OS-View"
N#endif
N
N
N#ifndef OS_TIME_TICK_HOOK_EN
S#error  "OS_CFG.H, Missing OS_TIME_TICK_HOOK_EN: Allows you to include the code for OSTimeTickHook() or not"
N#endif
N
N/*
N*********************************************************************************************************
N*                                         SAFETY CRITICAL USE
N*********************************************************************************************************
N*/
N
N#ifdef SAFETY_CRITICAL_RELEASE
S
S#if    OS_ARG_CHK_EN < 1u
S#error "OS_CFG.H, OS_ARG_CHK_EN must be enabled for safety-critical release code"
S#endif
S
S#if    OS_APP_HOOKS_EN > 0u
S#error "OS_CFG.H, OS_APP_HOOKS_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_DEBUG_EN > 0u
S#error "OS_CFG.H, OS_DEBUG_EN must be disabled for safety-critical release code"
S#endif
S
S#ifdef CANTATA
S#error "OS_CFG.H, CANTATA must be disabled for safety-critical release code"
S#endif
S
S#ifdef OS_SCHED_LOCK_EN
S#error "OS_CFG.H, OS_SCHED_LOCK_EN must be disabled for safety-critical release code"
S#endif
S
S#ifdef VSC_VALIDATION_MODE
S#error "OS_CFG.H, VSC_VALIDATION_MODE must be disabled for safety-critical release code"
S#endif
S
S#if    OS_TASK_STAT_EN > 0u
S#error "OS_CFG.H, OS_TASK_STAT_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_TICK_STEP_EN > 0u
S#error "OS_CFG.H, OS_TICK_STEP_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_FLAG_EN > 0u
S    #if    OS_FLAG_DEL_EN > 0
S    #error "OS_CFG.H, OS_FLAG_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_MBOX_EN > 0u
S    #if    OS_MBOX_DEL_EN > 0u
S    #error "OS_CFG.H, OS_MBOX_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_MUTEX_EN > 0u
S    #if    OS_MUTEX_DEL_EN > 0u
S    #error "OS_CFG.H, OS_MUTEX_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_Q_EN > 0u
S    #if    OS_Q_DEL_EN > 0u
S    #error "OS_CFG.H, OS_Q_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_SEM_EN > 0u
S    #if    OS_SEM_DEL_EN > 0u
S    #error "OS_CFG.H, OS_SEM_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_TASK_EN > 0u
S    #if    OS_TASK_DEL_EN > 0u
S    #error "OS_CFG.H, OS_TASK_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_CRITICAL_METHOD != 3u
S#error "OS_CPU.H, OS_CRITICAL_METHOD must be type 3 for safety-critical release code"
S#endif
S
N#endif  /* ------------------------ SAFETY_CRITICAL_RELEASE ------------------------ */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N	 	   	  			 		 	 	  		  	  			 			  		 	  				 	 		  	 	  	 		 		   		  	  			 				 		 		  	 	 	     	 					 	   	   	 	  	 		  	  			 	 	  		 		   		   	 			 
L 7 "..\main.c" 2
N#include "app_cfg.h"
N
N#include <stdio.h>
L 1 "d:\Keil\ARM\RV31\Inc\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 137287 $
N * Checkin $Date: 2008-08-27 13:36:52 +0100 (Wed, 27 Aug 2008) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
L 10 "..\main.c" 2
N#include "M051Series.h"
L 1 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 1
N/**************************************************************************//**
N * @file     M051Series.h
N * @version  V2.1
N * $Revision: 10 $
N * $Date: 12/06/19 11:18a $
N * @brief    M051 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __M051Series_H__
N#define __M051Series_H__
N                 
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N 
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn       = -14,      /*!< 2 Non Maskable Interrupt                             */
N  HardFault_IRQn            = -13,      /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
N  SVCall_IRQn               = -5,       /*!< 11 Cortex-M0 SV Call Interrupt                       */
N  PendSV_IRQn               = -2,       /*!< 14 Cortex-M0 Pend SV Interrupt                       */
N  SysTick_IRQn              = -1,       /*!< 15 Cortex-M0 System Tick Interrupt                   */
N
N/******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
N  BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
N  WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
N  EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
N  EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
N  GPIO_P0P1_IRQn            = 4,        /*!< GPIO_P0P1 Interrupt                                  */
N  GPIO_P2P3P4_IRQn          = 5,        /*!< GPIO_P2P3P4 Interrupt                                */
N  PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
N  PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
N  TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
N  TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
N  TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
N  TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
N  UART0_IRQn                = 12,       /*!< UART0 Interrupt                                      */
N  UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
N  SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
N  SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
N  I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
N  I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
N  ACMP0_IRQn                = 25,       /*!< ACMP0 Interrupt                                      */
N  ACMP1_IRQn                = 26,       /*!< ACMP1 Interrupt                                      */
N  PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
N  ADC_IRQn                  = 29        /*!< ADC Interrupt                                        */
N           
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N#include "core_cm0.h"                   /*!< Cortex-M0 processor and core peripherals             */
L 1 "..\..\LibM051Series\CMSIS\CoreSupport\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM0_CORE_H__
N#define __CM0_CORE_H__
N
N/** @addtogroup CMSIS_CM0_core_LintCinfiguration CMSIS CM0 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - not yet checked
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N
N/** @addtogroup CMSIS_CM0_core_definitions CM0 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM0_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | __CM0_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x00)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
L 1 "d:\Keil\ARM\RV31\Inc\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
L 56 "..\..\LibM051Series\CMSIS\CoreSupport\core_cm0.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    2               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM0_core_register CMSIS CM0 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM0_NVIC CMSIS CM0 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                      /*!< (Offset: 0x000) Interrupt Set Enable Register            */
X  volatile uint32_t ISER[1];                       
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                      /*!< (Offset: 0x080) Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                       
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                      /*!< (Offset: 0x100) Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                       
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                      /*!< (Offset: 0x180) Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                       
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IPR[8];                       /*!< (Offset: 0x3EC) Interrupt Priority Register              */
X  volatile uint32_t IPR[8];                        
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM0_NVIC */
N
N
N/** @addtogroup CMSIS_CM0_SCB CMSIS CM0 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N       uint32_t RESERVED0;                                      
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N       uint32_t RESERVED1;                                      
N  __IO uint32_t SHP[2];                       /*!< Offset: 0x1C  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                        
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N       uint32_t RESERVED2[2];                                   
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N} SCB_Type;                                                
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFul << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM0_SCB */
N
N
N/** @addtogroup CMSIS_CM0_SysTick CMSIS CM0 SysTick
N  memory mapped structure for SysTick
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM0_SysTick */
N
N
N/** @addtogroup CMSIS_CM0_CoreDebug CMSIS CM0 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_DWTENA_Pos         24                                             /*!< CoreDebug DEMCR: DWTENA Position */
N#define CoreDebug_DEMCR_DWTENA_Msk         (1ul << CoreDebug_DEMCR_DWTENA_Pos)            /*!< CoreDebug DEMCR: DWTENA Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM0_CoreDebug */
N
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N/*@}*/ /* end of group CMSIS_CM0_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (410894 < 400000)
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S
S
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM0_Core_FunctionInterface CMSIS CM0 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N/* ##########################   NVIC functions  #################################### */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn   The positive number of the external interrupt to disable
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) | 
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IPR[_IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N                                                               
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) | 
N                   SysTick_CTRL_TICKINT_Msk   | 
X                   (1ul << 1)   | 
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      | 
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1ul << 2));
N  __DSB();                                                                             /* Ensure completion of memory access */              
X  __dsb(0);                                                                                            
N  while(1);                                                                            /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM0_Core_FunctionInterface */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM0_core_definitions */
N
N#endif /* __CM0_CORE_H__ */
N
N/*lint -restore */
L 74 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "system_M051Series.h"          /*!< M051Series System                                    */
L 1 "..\..\LibM051Series\CMSIS\DeviceSupport\system_M051Series.h" 1
N/**************************************************************************//**
N * @file     system_M051Series.h
N * @version  V2.00
N * $Revision: 3 $
N * $Date: 12/07/13 4:23p $
N * @brief    M051 Series System Setting Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYSTEM_M051Series_H__
N#define __SYSTEM_M051Series_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N//#define DEBUG_ENABLE_SEMIHOST   /* To enable semihosted. !!!The SEMIHOSTED of startup_M051series.s must be {TRUE} */
N#define DEBUG_PORT      UART0       /*!< Select Debug Port which is used for retarget.c to output debug message to UART */
N
N/**
N *
N * @details    This is used to enable PLL to speed up booting at startup. Remove it will cause system using 
N *             default clock source (External crystal or internal 22.1184MHz IRC).
N *             Enable this option will casue system booting in 50MHz(By XTAL) or 50.1918MHz(By IRC22M) according to
N *             user configuration setting in CONFIG0
N *             
N */
N#define INIT_SYSCLK_AT_BOOTING
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __XTAL      (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __IRC22M    (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __IRC10K    (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __HSI       (50000000UL)    /*!< PLL default output is 48MHz@12M X'tal or 48.065MHz@22.1184MHz IRC */
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
Nextern uint32_t CyclesPerUs;        /*!< Cycles per micro second              */
Nextern uint32_t PllClock;           /*!< PLL Output Clock Frequency           */
N
N#if USE_ASSERT
S/**
S * @brief      Assert Function
S *
S * @param[in]  expr  Expression to be evaluated
S *
S * @return     None
S *
S * @details    If the expression is false, an error message will be printed out 
S *             from debug port (UART0 or UART1).
S */
S#define ASSERT_PARAM(expr)  { if (!(expr)) { AssertError((uint8_t*)__FILE__, __LINE__); } }
S
Svoid AssertError(uint8_t* file, uint32_t line);
N#else
N#define ASSERT_PARAM(expr)
N#endif
N
N#define assert_param(expr)  ASSERT_PARAM(expr)
N
N
N/**
N * @brief    System Initializaiton
N *
N * @param    None
N *
N * @return   None
N *
N * @details  The necessary initializaiton of system.
N */
Nextern void SystemInit(void);
N
N
N/**
N * @brief    Update the Variable SystemCoreClock
N *
N * @param    None
N *
N * @return   None
N *
N * @details  This function is used to update the variable SystemCoreClock
N *           and must be called whenever the core clock is changed.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 75 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/**
N * Initialize the system clock
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system
N *         Initialize the PLL and update the SystemFrequency variable
N */
Nextern void SystemInit (void);                
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N/** @addtogroup M051_SERIES_REG M051 Series Registers
N @{             
N*/
N
N
N/*--------------------- General Purpose Input and Ouptut ---------------------*/
N/** @addtogroup M051_GPIO M051 GPIO
N  Memory Mapped Structure for M051 Series General Purpose I/O
N  @{
N */
Ntypedef struct
N{
N    /**
N     * PMD
N     * ===================================================================================================
N     * Offset: 0x00  Port 0-4  I/O Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |PMD0      |P0 I/O Pin[0] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[0] pin is in INPUT mode. 
N     * |        |          |01 = P0[0] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[0] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[0] pin is in Quasi-bidirectional mode.
N     * |[3:2]   |PMD1      |P0 I/O Pin[1] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[1] pin is in INPUT mode. 
N     * |        |          |01 = P0[1] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[1] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[1] pin is in Quasi-bidirectional mode.
N     * |[5:4]   |PMD2      |P0 I/O Pin[2] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[2] pin is in INPUT mode. 
N     * |        |          |01 = P0[2] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[2] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[2] pin is in Quasi-bidirectional mode.
N     * |[7:6]   |PMD3      |P0 I/O Pin[3] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[3] pin is in INPUT mode. 
N     * |        |          |01 = P0[3] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[3] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[3] pin is in Quasi-bidirectional mode.
N     * |[9:8]   |PMD4      |P0 I/O Pin[4] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[4] pin is in INPUT mode. 
N     * |        |          |01 = P0[4] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[4] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[4] pin is in Quasi-bidirectional mode.
N     * |[11:10] |PMD5      |P0 I/O Pin[5] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[5] pin is in INPUT mode. 
N     * |        |          |01 = P0[5] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[5] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[5] pin is in Quasi-bidirectional mode.
N     * |[13:12] |PMD6      |P0 I/O Pin[6] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[6] pin is in INPUT mode. 
N     * |        |          |01 = P0[6] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[6] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[6] pin is in Quasi-bidirectional mode.
N     * |[15:14] |PMD7      |P0 I/O Pin[7] Mode Control 
N     * |        |          |Determine each I/O type of P0 pins 
N     * |        |          |00 = P0[7] pin is in INPUT mode. 
N     * |        |          |01 = P0[7] pin is in OUTPUT mode. 
N     * |        |          |10 = P0[7] pin is in Open-Drain mode. 
N     * |        |          |11 = P0[7] pin is in Quasi-bidirectional mode.
N     */    
N    __IO uint32_t  PMD;                         
X    volatile uint32_t  PMD;                         
N
N    /**
N     * OFFD
N     * ===================================================================================================
N     * Port 0-4 Digital Input Path Disable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:16] |OFFD      |OFFD: P0 Pin OFF digital input path Enable 
N     * |        |          |1 = Disable IO digital input path (digital input tied to low) 
N     * |        |          |0 = Enable IO digital input path
N     */    
N    __IO uint32_t  OFFD;                        
X    volatile uint32_t  OFFD;                        
N
N    /**
N     * DOUT
N     * ===================================================================================================
N     * Port 0-4 Data Output Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DOUT0     |P0 Pin[0] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.
N     * |[1]     |DOUT1     |P0 Pin[1] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.
N     * |[2]     |DOUT2     |P0 Pin[2] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.
N     * |[3]     |DOUT3     |P0 Pin[3] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.
N     * |[4]     |DOUT4     |P0 Pin[4] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.
N     * |[5]     |DOUT5     |P0 Pin[5] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.
N     * |[6]     |DOUT6     |P0 Pin[6] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.
N     * |[7]     |DOUT7     |P0 Pin[7] Output Value 
N     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
N     * |        |          |and quasi-mode. 
N     * |        |          |1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set. 
N     * |        |          |0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.
N     */    
N    __IO uint32_t  DOUT;                        
X    volatile uint32_t  DOUT;                        
N
N    /**
N     * DMASK
N     * ===================================================================================================
N     * Port0-4 Data Output Write Mask
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DMASK0    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the 
N     * |        |          |DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[0] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[0] bit is protected
N     * |[1]     |DMASK1    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the 
N     * |        |          |DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[1] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[1] bit is protected
N     * |[2]     |DMASK2    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the 
N     * |        |          |DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[2] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[2] bit is protected
N     * |[3]     |DMASK3    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the 
N     * |        |          |DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[3] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[3] bit is protected
N     * |[4]     |DMASK4    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the 
N     * |        |          |DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[4] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[4] bit is protected
N     * |[5]     |DMASK5    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the 
N     * |        |          |DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[6] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[6] bit is protected
N     * |[6]     |DMASK6    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the 
N     * |        |          |DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[6] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[6] bit is protected
N     * |[7]     |DMASK7    |P0 Data Output Write Mask 
N     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the 
N     * |        |          |DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write 
N     * |        |          |data to the protect bit is ignored 
N     * |        |          |0 = The corresponding P0_DOUT[7] bit can be updated 
N     * |        |          |1 = The corresponding P0_DOUT[7] bit is protected
N     */    
N    __IO uint32_t  DMASK;                       
X    volatile uint32_t  DMASK;                       
N
N    /**
N     * PIN;
N     * ===================================================================================================
N     * Port 0-4 Pin Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PIN0      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[0].
N     * |[1]     |PIN1      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[1].
N     * |[2]     |PIN2      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[2].
N     * |[3]     |PIN3      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[3].
N     * |[4]     |PIN4      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[4].
N     * |[5]     |PIN5      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[5].
N     * |[6]     |PIN6      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[6].
N     * |[7]     |PIN7      |P0 Pin Values 
N     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[7].
N     */    
N    __IO uint32_t  PIN;                         
X    volatile uint32_t  PIN;                         
N
N    /**
N     * DBEN
N     * ===================================================================================================
N     * Port 0-4 De-bounce Enable
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DBEN0     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[0] de-bounce function is disabled 
N     * |        |          |1 = The bit[0] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     * |[1]     |DBEN1     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[1] de-bounce function is disabled 
N     * |        |          |1 = The bit[1] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     * |[2]     |DBEN2     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[2] de-bounce function is disabled 
N     * |        |          |1 = The bit[2] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     * |[3]     |DBEN3     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[3] de-bounce function is disabled 
N     * |        |          |1 = The bit[3] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     * |[4]     |DBEN4     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[4] de-bounce function is disabled 
N     * |        |          |1 = The bit[4] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     * |[5]     |DBEN5     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[5] de-bounce function is disabled 
N     * |        |          |1 = The bit[5] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     * |[6]     |DBEN6     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[6] de-bounce function is disabled 
N     * |        |          |1 = The bit[6] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     * |[7]     |DBEN7     |P0 Input Signal De-bounce Enable 
N     * |        |          |DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
N     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
N     * |        |          |as the signal bounce and will not trigger the interrupt. 
N     * |        |          |The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
N     * |        |          |0 = The bit[7] de-bounce function is disabled 
N     * |        |          |1 = The bit[7] de-bounce function is enabled 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
N     * |        |          |the de-bounce enable bit is ignored.
N     */    
N    __IO uint32_t  DBEN;                        
X    volatile uint32_t  DBEN;                        
N
N    /**
N     * IMD
N     * ===================================================================================================
N     * Port 0-4 Interrupt Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |IMD0      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     * |[1]     |IMD1      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     * |[2]     |IMD2      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     * |[3]     |IMD3      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     * |[4]     |IMD4      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     * |[5]     |IMD5      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     * |[6]     |IMD6      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     * |[7]     |IMD7      |Port 0 Interrupt Mode Control 
N     * |        |          |IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
N     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
N     * |        |          |sampled by one clock and the generate the interrupt 
N     * |        |          |0 = Edge trigger interrupt 
N     * |        |          |1 = Level trigger interrupt 
N     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
N     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
N     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
N     * |        |          |de-bounce enable bit is ignored.
N     */    
N    __IO uint32_t  IMD;                         
X    volatile uint32_t  IMD;                         
N
N    /**
N     * IEN
N     * ===================================================================================================
N     * Port 0-4 Interrupt Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |IF_EN0    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[0] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[0] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[0] state low-level or high-to-low change interrupt
N     * |[1]     |IF_EN1    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[1] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[1] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[1] state low-level or high-to-low change interrupt
N     * |[2]     |IF_EN2    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[2] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[2] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[2] state low-level or high-to-low change interrupt
N     * |[3]     |IF_EN3    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[3] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[3] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[3] state low-level or high-to-low change interrupt
N     * |[4]     |IF_EN4    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[4] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[4] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[4] state low-level or high-to-low change interrupt
N     * |[5]     |IF_EN5    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[5] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[5] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[5] state low-level or high-to-low change interrupt
N     * |[6]     |IF_EN6    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[6] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[6] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[6] state low-level or high-to-low change interrupt
N     * |[7]     |IF_EN7    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
N     * |        |          |IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IF_EN[7] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[7] state low-level or high-to-low change interrupt 
N     * |        |          |0 = Disable the P0[7] state low-level or high-to-low change interrupt
N     * |[16]    |IR_EN0    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[0] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[0] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[0] level-high or low-to-high interrupt
N     * |[17]    |IR_EN1    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[1] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[1] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[1] level-high or low-to-high interrupt
N     * |[18]    |IR_EN2    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[2] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[2] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[2] level-high or low-to-high interrupt
N     * |[19]    |IR_EN3    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[3] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[3] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[3] level-high or low-to-high interrupt
N     * |[20]    |IR_EN4    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[4] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[4] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[4] level-high or low-to-high interrupt
N     * |[21]    |IR_EN5    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[5] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[5] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[5] level-high or low-to-high interrupt
N     * |[22]    |IR_EN6    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[6] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[6] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[6] level-high or low-to-high interrupt
N     * |[23]    |IR_EN7    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
N     * |        |          |IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also 
N     * |        |          |enable the pin wakeup function. 
N     * |        |          |When set the IR_EN[7] bit "1": 
N     * |        |          |If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt. 
N     * |        |          |If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate 
N     * |        |          |the interrupt. 
N     * |        |          |1 = Enable the P0[7] level-high or low-to-high interrupt 
N     * |        |          |0 = Disable the P0[7] level-high or low-to-high interrupt
N     */    
N    __IO uint32_t  IEN;                         
X    volatile uint32_t  IEN;                         
N
N    /**
N     * ISRC
N     * ===================================================================================================
N     * Port 0-4 Interrupt Trigger Source
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISRC0     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[0] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[0] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     * |[1]     |ISRC1     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[1] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[1] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     * |[2]     |ISRC2     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[2] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[2] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     * |[3]     |ISRC3     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[3] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[3] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     * |[4]     |ISRC4     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[4] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[4] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     * |[5]     |ISRC5     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[5] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[5] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     * |[6]     |ISRC6     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[6] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[6] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     * |[7]     |ISRC7     |Port 0 Interrupt Trigger Source Indicator 
N     * |        |          |Read: 
N     * |        |          |1 = Indicates P0[7] generate an interrupt 
N     * |        |          |0 = No interrupt at P0[7] 
N     * |        |          |Write: 
N     * |        |          |1 = Clear the correspond pending interrupt 
N     * |        |          |0 = No action
N     */    
N    __IO uint32_t  ISRC;                        
X    volatile uint32_t  ISRC;                        
N} GPIO_T;                                  
N                                                
Ntypedef struct                                  
N{                                               
N    /**
N     * DBNCECON
N     * ===================================================================================================
N     * Offset: 0x180 Interrupt De-bounce Cycle Control
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DBCLKSEL  |De-bounce sampling cycle selection
N     * |        |          |DBCLKSEL
N     * |        |          |Description
N     * |        |          |0 = Sample interrupt input once per 1 clocks
N     * |        |          |1 = Sample interrupt input once per 2 clocks
N     * |        |          |2 = Sample interrupt input once per 4 clocks
N     * |        |          |3 = Sample interrupt input once per 8 clocks
N     * |        |          |4 = Sample interrupt input once per 16 clocks
N     * |        |          |5 = Sample interrupt input once per 32 clocks
N     * |        |          |6 = Sample interrupt input once per 64 clocks
N     * |        |          |7 = Sample interrupt input once per 128 clocks
N     * |        |          |8 = Sample interrupt input once per 256 clocks
N     * |        |          |9 = Sample interrupt input once per 2*256 clocks
N     * |        |          |10 = Sample interrupt input once per 4*256clocks
N     * |        |          |11 = Sample interrupt input once per 8*256 clocks
N     * |        |          |12 = Sample interrupt input once per 16*256 clocks
N     * |        |          |13 = Sample interrupt input once per 32*256 clocks
N     * |        |          |14 = Sample interrupt input once per 64*256 clocks
N     * |        |          |15 = Sample interrupt input once per 128*256 clocks
N     * |[4]     |DBCLKSRC  |De-bounce counter clock source select
N     * |        |          |1 = De-bounce counter clock source is the internal 10KHz clock
N     * |        |          |0 = De-bounce counter clock source is the HCLK
N     * |[5]     |ICLK_ON   |Interrupt clock On mode
N     * |        |          |Set this bit "0" will disable the interrupt generate circuit clock, if the pin[n] interrupt is disabled
N     * |        |          |0 = disable the clock if the P0/1/2/3/4[n] interrupt is disabled
N     * |        |          |1 = interrupt generated circuit clock always enable 
N     * |        |          |n=0~7
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DBNCECON;                    
X    volatile uint32_t  DBNCECON;                    
N} GPIO_DBNCECON_T;
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO PMD: PMD7 Position */
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO PMD: PMD7 Mask */
N
N#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO PMD: PMD6 Position */    
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO PMD: PMD6 Mask */
N
N#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO PMD: PMD5 Position */
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO PMD: PMD5 Mask */
N
N#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO PMD: PMD4 Position */
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO PMD: PMD4 Mask */
N
N#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO PMD: PMD3 Position */
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO PMD: PMD3 Mask */
N
N#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO PMD: PMD2 Position */
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO PMD: PMD2 Mask */
N
N#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO PMD: PMD1 Position */
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO PMD: PMD1 Mask */
N
N#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO PMD: PMD0 Position */
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO PMD: PMD0 Mask */
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO OFFD: OFFD Position */
N#define GPIO_OFFD_OFFD_Msk          (0xFFul << GPIO_OFFD_OFFD_Pos)              /*!< GPIO OFFD: OFFD Mask */
N
N/* GPIO DOUT Bit Field Definitions */                                           
N#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO DOUT: DOUT Position */
N#define GPIO_DOUT_DOUT_Msk          (0xFFul << GPIO_DOUT_DOUT_Pos)              /*!< GPIO DOUT: DOUT Mask */
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO DMASK: DMASK Position */
N#define GPIO_DMASK_DMASK_Msk        (0xFFul << GPIO_DMASK_DMASK_Pos)            /*!< GPIO DMASK: DMASK Mask */
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO PIN: PIN Position */   
N#define GPIO_PIN_PIN_Msk            (0xFFul << GPIO_PIN_PIN_Pos)                /*!< GPIO PIN: PIN Mask */
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO DBEN: DBEN Position */
N#define GPIO_DBEN_DBEN_Msk          (0xFFul << GPIO_DBEN_DBEN_Pos)              /*!< GPIO DBEN: DBEN Mask */
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO IMD: IMD Position */
N#define GPIO_IMD_IMD_Msk            (0xFFul << GPIO_IMD_IMD_Pos)                /*!< GPIO IMD: IMD Mask */
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO IEN: IR_EN Position */
N#define GPIO_IEN_IR_EN_Msk          (0xFFul << GPIO_IEN_IR_EN_Pos)              /*!< GPIO IEN: IR_EN Mask */
N
N#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO IEN: IF_EN Position */
N#define GPIO_IEN_IF_EN_Msk          (0xFFul << GPIO_IEN_IF_EN_Pos)              /*!< GPIO IEN: IF_EN Mask */
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO ISRC: ISRC Position */
N#define GPIO_ISRC_ISRC_Msk          (0xFFul << GPIO_ISRC_ISRC_Pos)              /*!< GPIO ISRC: ISRC Mask */
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO DBNCECON: ICLK_ON  Position */
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO DBNCECON: ICLK_ON  Mask */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO DBNCECON: DBCLKSRC Position */
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO DBNCECON: DBCLKSRC Mask */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO DBNCECON: DBCLKSEL Position */
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO DBNCECON: DBCLKSEL Mask */
N/*@}*/ /* end of group M051_GPIO */
N
N
N/*------------------------- UART Interface Controller ------------------------*/
N
N/** @addtogroup M051_UART M051 UART
N  Memory Mapped Structure for M051 Series UART Serial Interface Controller
N  @{
N */
Ntypedef struct
N{
N                                
N    union {                             
N    __IO uint32_t DATA;                 
X    volatile uint32_t DATA;                 
N
N    /**
N     * THR
N     * ===================================================================================================
N     * Offset: 0x00 Transmit Holding DATA
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |          |bitTransmittedData
N     * |        |          |Transmit Holding Register
N     * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB 
N     * |        |          |first).
N     */    
N    __IO uint32_t THR;                  
X    volatile uint32_t THR;                  
N
N    /**
N     * RBR
N     * ===================================================================================================
N     * Offset: 0x00 Receive Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |          |Receive Buffer Register
N     * |        |          |By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).
N     */    
N    __IO uint32_t RBR;                  
X    volatile uint32_t RBR;                  
N    };
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x04  UART Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable.
N     * |        |          |0 = Mask off INT_RDA
N     * |        |          |1 = Enable INT_RDA
N     * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable
N     * |        |          |0 = Mask off INT_THRE
N     * |        |          |1 = Enable INT_THRE
N     * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable 
N     * |        |          |0 = Mask off INT_RLS
N     * |        |          |1 = Enable INT_RLS
N     * |[3]     |Modem_IEN |Modem Status Interrupt Enable 
N     * |        |          |0 = Mask off INT_MOS
N     * |        |          |1 = Enable INT_MOS
N     * |[4]     |RTO_IEN   |Rx Time out Interrupt Enable
N     * |        |          |0 = Mask off INT_tout
N     * |        |          |1 = Enable INT_tout 
N     * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable
N     * |        |          |0 = Mask off INT_Buf_err
N     * |        |          |1 = Enable INT_Buf_err
N     * |[6]     |Wake_EN   |Wake up CPU function enable 
N     * |        |          |0 = Disable UART wake up CPU function
N     * |        |          |1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS 
N     * |        |          |change will wake up CPU from deep sleep mode.
N     * |[11]    |Time_Out_EN|Time-Out Counter Enable
N     * |        |          |1 = Enable Time-out counter.
N     * |        |          |0 = Disable Time-out counter.
N     * |[12]    |Auto_RTS_EN|RTS Auto Flow Control Enable 
N     * |        |          |1 = Enable RTS auto flow control.
N     * |        |          |0 = Disable RTS auto flow control.
N     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR 
N     * |[RTS_Tri_Lev], the UART will dessert RTS signal.|[13]      |Auto_CTS_EN
N     * |        |          |CTS Auto Flow Control Enable
N     * |        |          |1 = Enable CTS auto flow control.
N     * |        |          |0 = Disable CTS auto flow control.
N     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input 
N     * |        |          |assert (UART will not send data to device until CTS is asserted).
N     */    
N    __IO uint32_t IER;                  
X    volatile uint32_t IER;                  
N
N    /**
N     * FCR
N     * ===================================================================================================
N     * Offset: 0x08  UART FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RFR       |Rx Software Reset
N     * |        |          |When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are 
N     * |        |          |cleared.
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
N     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
N     * |[2]     |TFR       |Tx Software Reset
N     * |        |          |When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are 
N     * |        |          |cleared.
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
N     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
N     * |[7:4]   |RFITL     |Word Length Select
N     * |        |          |INTR_RDA Tigger Level(Bytes)
N     * |        |          |0000 = 01 Bytes
N     * |        |          |0001 = 04 Bytes
N     * |        |          |0010 = 08 Bytes
N     * |        |          |0011 = 14 Bytes
N     * |[8]     |RX_DIS    |Receiver Disable register.
N     * |        |          |The receiver is disabled or not (set 1 is disable receiver)
N     * |        |          |1: Disable Receiver
N     * |        |          |0: Enable Receiver
N     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before 
N     * |        |          |RS-485 enable function in UA_FUN_SEL. FUN_SEL is programmed.
N     * |[19:16] |RTS_Tri_Lev|Word Length Select
N     * |        |          |0000 = 01 Bytes
N     * |        |          |0001 = 04 Bytes
N     * |        |          |0010 = 08 Bytes
N     * |        |          |0011 = 14 Bytes
N     */    
N    __IO uint32_t FCR;                  
X    volatile uint32_t FCR;                  
N
N    /**
N     * LCR
N     * ===================================================================================================
N     * Offset: 0x0C  UART Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WLS       |Word Length Select
N     * |        |          |00 = 5 bits
N     * |        |          |01 = 6 bits
N     * |        |          |10 = 7 bits
N     * |        |          |11 = 8 bits
N     * |[2]     |NSB       |Number of "STOP bit"
N     * |        |          |0= One "STOP bit" is generated in the transmitted data
N     * |        |          |1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
N     * |        |          |Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.
N     * |[3]     |PBE       |Parity Bit Enable
N     * |        |          |0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
N     * |        |          |1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
N     * |[4]     |EPE       |Even Parity Enable
N     * |        |          |0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
N     * |        |          |1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
N     * |        |          |This bit has effect only when bit 3 (parity bit enable) is set.
N     * |[5]     |SPE       |Stick Parity Enable 
N     * |        |          |0 = Disable stick parity 
N     * |        |          |1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When 
N     * |        |          |PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.
N     * |[6]     |BCB       |Break Control Bit 
N     * |        |          |When this bit is set to logic 1, the serial data output (Tx) is forced to the Spacing State (logic 0). This bit 
N     * |        |          |acts only on Tx and has no effect on the transmitter logic.
N     */    
N    __IO uint32_t LCR;                  
X    volatile uint32_t LCR;                  
N
N    /**
N     * MCR
N     * ===================================================================================================
N     * Offset: 0x10  UART Modem Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RTS       |RTS (Request-To-Send) Signal 
N     * |        |          |0: Drive RTS pin to logic 1 (If the Lev_RTS set to low level triggered).
N     * |        |          |1: Drive RTS pin to logic 0 (If the Lev_RTS set to low level triggered).
N     * |        |          |0: Drive RTS pin to logic 0 (If the Lev_RTS set to high level triggered).
N     * |        |          |1: Drive RTS pin to logic 1 (If the Lev_RTS set to high level triggered).
N     * |[9]     |Lev_RTS   |RTS Trigger Level 
N     * |        |          |This bit can change the RTS trigger level.
N     * |        |          |0= low level triggered
N     * |        |          |1= high level triggered
N     * |[13]    |RTS_St    |RTS Pin State 
N     * |        |          |This bit is the pin status of RTS.
N     */    
N    __IO uint32_t MCR;                  
X    volatile uint32_t MCR;                  
N
N    /**
N     * MSR
N     * ===================================================================================================
N     * Offset: 0x14  UART Modem Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DCTSF     |Detect CTS State Change Flag 
N     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU 
N     * |        |          |when IER [Modem_IEN].
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[4]     |CTS_St    |CTS Pin Status 
N     * |        |          |This bit is the pin status of CTS. 
N     * |[8]     |Lev_CTS   |CTS Trigger Level
N     * |        |          |This bit can change the CTS trigger level.
N     * |        |          |0= low level triggered
N     * |        |          |1= high level triggered
N     */    
N    __IO uint32_t MSR;                  
X    volatile uint32_t MSR;                  
N
N    /**
N     * FSR
N     * ===================================================================================================
N     * Offset: 0x18  UART FIFO Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |Rx_Over_IF|Rx overflow Error IF (Read Only) 
N     * |        |          |This bit is set when Rx FIFO overflow.
N     * |        |          |If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 16 bytes of 
N     * |        |          |UART0/UART1, this bit will be set.
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[3]     |RS-       |485_Add_Det
N     * |        |          |RS-485 Address Byte Detection Flag
N     * |        |          |This bit is set to logic 1 and set UA_RS-485_CSR [RS-485_Add_EN] whenever in RS-485 
N     * |        |          |mode the receiver detect any address byte received address byte character (bit9 = '1') bit", 
N     * |        |          |and it is reset whenever the CPU writes 1 to this bit.
N     * |        |          |Note: This field is used for RS-485 mode.
N     * |[4]     |PEF       |Parity Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", 
N     * |        |          |and is reset whenever the CPU writes 1 to this bit.
N     * |[5]     |FEF       |Framing Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that 
N     * |        |          |is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset 
N     * |        |          |whenever the CPU writes 1 to this bit.
N     * |[6]     |BIF       |Break Interrupt Flag
N     * |        |          |This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" 
N     * |        |          |(logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data 
N     * |        |          |bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
N     * |[13:8]  |Rx_Pointer|Rx FIFO pointer (Read Only)
N     * |        |          |This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external 
N     * |        |          |device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer 
N     * |        |          |decreases one.
N     * |[14]    |Rx_Empty  |Receiver FIFO Empty (Read Only)
N     * |        |          |This bit initiate Rx FIFO empty or not.
N     * |        |          |When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be 
N     * |        |          |cleared when UART receives any new data.
N     * |[15]    |Rx_Full   |Receiver FIFO Full (Read Only)
N     * |        |          |This bit initiates Rx FIFO full or not.
N     * |        |          |This bit is set when Rx_Pointer is equal to 16(UART0/UART1), otherwise is cleared by 
N     * |        |          |hardware.
N     * |[21:16] |Tx_Pointer|TX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, 
N     * |        |          |Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift 
N     * |        |          |Register, Tx_Pointer decreases one.
N     * |[22]    |Tx_Empty  |Transmitter FIFO Empty (Read Only)
N     * |        |          |This bit indicates Tx FIFO empty or not.
N     * |        |          |When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware 
N     * |        |          |sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).
N     * |[23]    |Tx_Full   |Transmitter FIFO Full (Read Only)
N     * |        |          |This bit indicates Tx FIFO full or not.
N     * |        |          |This bit is set when Tx_Pointer is equal to 64/16(UART0/UART1), otherwise is cleared by 
N     * |        |          |hardware.
N     * |[24]    |Tx_Over_IF|Tx Overflow Error Interrupt Flag (Read Only)
N     * |        |          |If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[28]    |TE_Flag   |Transmitter Empty Flag (Read Only)
N     * |        |          |Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte 
N     * |        |          |has been transmitted.
N     * |        |          |Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not 
N     * |        |          |completed.
N     * |        |          |NOTE: This bit is read only. 
N     */    
N    __IO uint32_t FSR;                  
X    volatile uint32_t FSR;                  
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x1C  UART Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only).
N     * |        |          |When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If 
N     * |        |          |IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
N     * |        |          |NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO 
N     * |        |          |drops below the threshold level (RFITL).
N     * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only). 
N     * |        |          |This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If 
N     * |        |          |IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and it will be cleared when writing data into THR (Tx FIFO not empty).
N     * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only).
N     * |        |          |In UART mode this bit is set when the Rx receive data have parity error, framing error or break 
N     * |        |          |error (at least one of 3 bits, BIF, FEF and PEF, is set). In RS-485 mode, the field includes RS-485 
N     * |        |          |Address Byte Detection Flag. If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS-485_Add_Det 
N     * |        |          |are cleared.
N     * |[3]     |Modem_IF  |MODEM Interrupt Flag (Read Only) 
N     * |        |          |This bit is set when the CTS pin has state change (DCTSF=1). If IER[Modem_IEN] is enabled, the 
N     * |        |          |Modem interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.
N     * |[4]     |Tout_IF   |Time Out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Rx FIFO is not empty and no activities occur in the Rx FIFO and the time 
N     * |        |          |out counter equal to TOIC. If IER [Tout_IEN] is enabled, the Tout interrupt will be generated. 
N     * |        |          |NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.
N     * |[5]     |Buf_Err_IF|Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When 
N     * |        |          |Buf_Err_IF is set, the transfer maybe not correct. If IER[Buf_Err_IEN] is enabled, the buffer error 
N     * |        |          |interrupt will be generated.
N     * |        |          |NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared. 
N     * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator to Interrupt Controller (INT_RDA).
N     * |        |          |An AND output with inputs of RDA_IEN and RDA_IF
N     * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller (INT_THRE).
N     * |        |          |An AND output with inputs of THRE_IEN and THRE_IF
N     * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator to Interrupt Controller (INT_RLS). 
N     * |        |          |An AND output with inputs of RLS_IEN and RLS_IF
N     * |        |          |Note: In RS-485 mode, the field includes RS-485 Address Byte Detection Flag.
N     * |[11]    |Modem_INT |MODEM Status Interrupt Indicator to Interrupt Controller (INT_MOS). 
N     * |        |          |An AND output with inputs of Modem_IEN and Modem_IF
N     * |[12]    |Tout_INT  |Time Out Interrupt Indicator to Interrupt Controller (INT_Tout)
N     * |        |          |An AND output with inputs of RTO_IEN and Tout_IF
N     * |[13]    |Buf_Err_INT|Buffer Error Interrupt Indicator to Interrupt Controller (INT_Buf_err)
N     * |        |          |An AND output with inputs of BUF_ERR_IEN and Buf_Err_IF
N     */    
N    __IO uint32_t ISR;                  
X    volatile uint32_t ISR;                  
N
N    /**
N     * TOR
N     * ===================================================================================================
N     * Offset: 0x20  UART Time Out Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:0]   |TOIC      |Time Out Interrupt Comparator
N     * |        |          |The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO 
N     * |        |          |receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out 
N     * |        |          |interrupt comparator (TOIC), a receiver time out interrupt (INT_TOUT) is generated if UA_IER[RTO_IEN]. 
N     * |        |          |A new incoming data word or RX FIFO empty clears INT_TOUT. 
N     * |[15:8]  |DLY       |TX Delay time value
N     * |        |          |This field is use to programming the transfer delay time between the last stop bit leaving the TX-FIFO 
N     * |        |          |and the de-assertion of by setting UA_TOR. DLY register.
N     */    
N    __IO uint32_t TOR;                  
X    volatile uint32_t TOR;                  
N
N    /**
N     * BAUD
N     * ===================================================================================================
N     * Offset: 0x24  UART Baud Rate Divisor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |BRD_LowByte|Baud Rate Divider 
N     * |        |          |The low byte of the baud rate divider
N     * |[15:8]  |BRD_HighByte|Baud Rate Divider 
N     * |        |          |The high byte of the baud rate divider
N     * |[27:24] |Divider_X |Divider X
N     * |        |          |The baud rate divider M = X+1.
N     * |[28]    |DIV_X_ONE |Divider X equal 1
N     * |        |          |0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must > 8)
N     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must > 3).
N     * |[29]    |DIV_X_EN  |Divider X Enable
N     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is  
N     * |        |          |Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
N     * |        |          |0 = Disable divider X (the equation of M = 16)
N     * |        |          |1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must > 8).
N     * |        |          |NOTE: When in IrDA mode, this bit must disable.
N     */    
N    __IO uint32_t BAUD;                 
X    volatile uint32_t BAUD;                 
N
N    /**
N     * IRCR
N     * ===================================================================================================
N     * Offset: 0x28  UART IrDA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |Tx_SELECT |Tx_SELECT
N     * |        |          |1: Enable IrDA transmitter
N     * |        |          |0: Enable IrDA receiver
N     * |[2]     |LB        |IrDA loop back mode for self test.
N     * |        |          |1: Enable IrDA loop back mode
N     * |        |          |0: Disable IrDA loop back mode
N     * |[5]     |INV_Tx    |INV_Tx
N     * |        |          |1= Inverse Tx output signal
N     * |        |          |0= No inversion
N     * |[6]     |INV_Rx    |INV_Rx
N     * |        |          |1= Inverse Rx input signal
N     * |        |          |0= No inversion
N     */    
N    __IO uint32_t IRCR;                 
X    volatile uint32_t IRCR;                 
N
N    /**
N     * ALT_CSR
N     * ===================================================================================================
N     * Offset: 0x2C  UART Alternate Control/Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |RS-485_NMM|RS-485 Normal Multi-drop Operation Mode (NMM)
N     * |        |          |1: Enable RS-485 Normal Multi-drop Operation Mode (NMM)
N     * |        |          |0: Disable RS-485 Normal Multi-drop Operation Mode (NMM)
N     * |        |          |Note: It can't be active with RS-485_AAD operation mode.
N     * |[9]     |RS-485_AAD|RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |1: Enable RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |0: Disable RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |Note: It can't be active with RS-485_NMM operation mode.
N     * |[10]    |RS-485_AUD|RS-485 Auto Direction Mode (AUD)
N     * |        |          |1: Enable RS-485 Auto Direction Mode (AUD)
N     * |        |          |0: Disable RS-485 Auto Direction Mode (AUD)
N     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N     * |[15]    |RS-485_Add_EN|RS-485 Address Detection Enable
N     * |        |          |This bit is use to enable RS-485 address detection mode. 
N     * |        |          |1: Enable address detection mode
N     * |        |          |0: Disable address detection mode 
N     * |        |          |Note: This field is used for RS-485 any operation mode.
N     * |[31:24] |ADDR_MATCH|Address match value register
N     * |        |          |This field contains the RS-485 address match values.
N     * |        |          |Note: This field is used for RS-485 auto address detection mode.
N     */    
N    __IO uint32_t ALT_CSR;               
X    volatile uint32_t ALT_CSR;               
N
N    /**
N     * FUNSEL
N     * ===================================================================================================
N     * Offset: 0x30  UART Function Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FUN_SEL   |Function Select Enable
N     * |        |          |00 = UART Function.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Enable IrDA Function.
N     * |        |          |11 = Enable RS-485 Function.
N     */    
N    __IO uint32_t FUNSEL;               
X    volatile uint32_t FUNSEL;               
N} UART_T;
N
N
N
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos         0                                          /*!< UART THR: THR Position  */
N#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos         0                                          /*!< UART RBR: RBR Posistion */
N#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART IER: AUTO_CTS_EN Posistion      */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART IER: AUTO_CTS_EN Mask           */
N
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART IER: AUTO_RTS_EN Posistion      */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART IER: TIME_OUT_EN Posistion      */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_LIN_RX_BRK_IEN_Pos 8                                       /*!< UART IER: LIN_RX_BRK_IEN Posistion   */
N#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)    /*!< UART IER: LIN_RX_BRK_IEN Mask        */
N
N#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART IER: WAKE_EN Posistion          */
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART IER: WAKE_EN Mask               */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART IER: BUF_ERR_IEN Posistion      */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART IER: RTO_IEN Posistion          */
N#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART IER: RTO_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART IER: MODEM_IEN Posistion        */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART IER: RLS_IEN Posistion          */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART IER: THRE_IEN Posistion         */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART MCR: RTS Mask                   */
N
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART MSR: DCTST Mask                 */
N
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_LIN_RX_BREAK_INT_Pos    15                                      /*!< UART ISR: LIN_RX_BREAK_INT Position       */
N#define UART_ISR_LIN_RX_BREAK_INT_Msk    (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)  /*!< UART ISR: LIN_RX_BREAK_INT Mask           */
N
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART ISR: RDA_INT Mask               */
N
N#define UART_ISR_LIN_RX_BREAK_IF_Pos 7                                      /*!< UART ISR: LIN RX BREAK IF Position   */
N#define UART_ISR_LIN_RX_BREAK_IF_Msk (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)  /*!< UART ISR: LIN RX BREAK IF Mask       */
N           
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART ISR: RDA_IF Mask                */
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos           8                                        /*!< UART TOR: DLY Position               */
N#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos          0                                        /*!< UART TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)            /*!< UART TOR: TOIC Mask                  */
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
N
N#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
N
N#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
N
N#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
N#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART ALT_CSR: RS485_NMM Mask         */
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART ALT_CSR: LIN TX Break Mode Enable Position     */
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART ALT_CSR: LIN TX Break Mode Enable Mask         */
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART ALT_CSR: LIN RX Enable Position     */
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART ALT_CSR: LIN RX Enable Mask         */
N
N#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART ALT_CSR: UART LIN Break Field Length Position     */
N#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART ALT_CSR: UART LIN Break Field Length Mask         */
N
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART FUN_SEL: FUN_SEL Mask           */
N
N/*@}*/ /* end of group M051_UART */
N
N
N/*----------------------------- TIMER Controller -----------------------------*/
N/** @addtogroup M051_TIMER M051 TIMER
N  Memory Mapped Structure for M051 Series Timer Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * TCSR
N     * ===================================================================================================
N     * Offset: 0x00  Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PRESCALE  |Pre-scale Counter
N     * |        |          |Clock input is divided by PRESCALE+1 before it is fed to the counter. If 
N     * |        |          |PRESCALE=0, then there is no scaling.
N     * |[16]    |TDR_EN    |Data Load Enable
N     * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with 
N     * |        |          |the 24-bit up-timer value as the timer is counting. 
N     * |        |          |1 = Timer Data Register update enable.
N     * |        |          |0 = Timer Data Register update disable. 
N     * |[25]    |CACT      |Timer Active Status Bit (Read only)
N     * |        |          |This bit indicates the up-timer status.
N     * |        |          |0 = Timer is not active.
N     * |        |          |1 = Timer is active.
N     * |[26]    |CRST      |Timer Reset Bit
N     * |        |          |Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 
N     * |        |          |0.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.
N     * |[28:27] |MODE      |Timer Operating Mode
N     * |        |          |00 =
N     * |        |          |The timer is operating in the one-shot mode. The associated 
N     * |        |          |interrupt signal is generated once (if IE is enabled) and CEN is 
N     * |        |          |automatically cleared by hardware.
N     * |        |          |01 =
N     * |        |          |The timer is operating in the periodic mode. The associated 
N     * |        |          |interrupt signal is generated periodically (if IE is enabled).
N     * |        |          |10 =
N     * |        |          |The timer is operating in the toggle mode. The interrupt signal is 
N     * |        |          |generated periodically (if IE is enabled). And the associated 
N     * |        |          |signal (tout) is changing back and forth with 50% duty cycle.
N     * |        |          |11 =
N     * |        |          |Reserved 
N     * |[29]    |IE        |Interrupt Enable Bit
N     * |        |          |1 = Enable timer Interrupt.
N     * |        |          |0 = Disable timer Interrupt. 
N     * |        |          |If timer interrupt is enabled, the timer asserts its interrupt signal when the associated 
N     * |        |          |up-timer value is equal to TCMPR.
N     * |[30]    |CEN       |Timer Enable Bit
N     * |        |          |1 = Starts counting
N     * |        |          |0 = Stops/Suspends counting
N     * |        |          |Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up 
N     * |        |          |counting from the last stop counting value.
N     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) 
N     * |        |          |when the associated timer interrupt is generated (IE[29]=1).
N     */    
N    __IO uint32_t  TCSR;                
X    volatile uint32_t  TCSR;                
N
N    /**
N     * TCMPR
N     * ===================================================================================================
N     * Offset: 0x04  Timer Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TCMP      |Timer Compared Value
N     * |        |          |TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value 
N     * |        |          |is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with 
N     * |        |          |TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
N     * |        |          |Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
N     * |        |          |NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
N     * |        |          |NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, 
N     * |        |          |TIMER will restart counting using this new value and abort previous count.
N     */    
N    __IO uint32_t  TCMPR;		        
X    volatile uint32_t  TCMPR;		        
N
N    /**
N     * TISR
N     * ===================================================================================================
N     * Offset: 0x08  Timer Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Timer Interrupt Flag
N     * |        |          |This bit indicates the interrupt status of Timer.
N     * |        |          |TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer 
N     * |        |          |compared value (TCMP). It is cleared by writing 1 to this bit.
N     */    
N    __IO uint32_t  TISR;		        
X    volatile uint32_t  TISR;		        
N
N    /**
N     * TDR
N     * ===================================================================================================
N     * Timer Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TDR       |Timer Data Register
N     * |        |          |When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. 
N     * |        |          |User can read this register for the up-timer value.
N     */    
N    __IO uint32_t  TDR;			        
X    volatile uint32_t  TDR;			        
N
N    /**
N     * TCAP
N     * ===================================================================================================
N     * Timer Capture Data Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TCAP;		        
X    volatile uint32_t  TCAP;		        
N
N    /**
N     * TEXCON
N     * ===================================================================================================
N     * Offset: 0x14  Timer External Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TEXCON;	            
X    volatile uint32_t  TEXCON;	            
N
N    /**
N     * TEXISR
N     * ===================================================================================================
N     * Offset: 0x14  Timer External Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TEXISR;	            
X    volatile uint32_t  TEXISR;	            
N} TIMER_T;
N
N/* TIMER TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31											/*!< TIMER TCSR: DBGACK_TMR Position */
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER TCSR: DBGACK_TMR Mask */
N
N#define TIMER_TCSR_CEN_Pos          30											/*!< TIMER TCSR: CEN Position */
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)				    /*!< TIMER TCSR: CEN Mask */
N
N#define TIMER_TCSR_IE_Pos           29											/*!< TIMER TCSR: IE Position */
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)					/*!< TIMER TCSR: IE Mask */
N                                                                                 
N#define TIMER_TCSR_MODE_Pos         27											/*!< TIMER TCSR: MODE Position */
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)				/*!< TIMER TCSR: MODE Mask */
N
N#define TIMER_TCSR_CRST_Pos         26											/*!< TIMER TCSR: CRST Position */
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)				/*!< TIMER TCSR: CRST Mask */
N
N#define TIMER_TCSR_CACT_Pos         25											/*!< TIMER TCSR: CACT Position */
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)				/*!< TIMER TCSR: CACT Mask */
N
N#define TIMER_TCSR_CTB_Pos          24											/*!< TIMER TCSR: CTB Position */
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)					/*!< TIMER TCSR: CTB Mask */
N
N#define TIMER_TCSR_WAKE_EN_Pos      23											/*!< TIMER TCSR: WAKE_EN Position */
N#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)			    /*!< TIMER TCSR: WAKE_EN Mask */
N
N#define TIMER_TCSR_CAP_SRC_Pos      22											/*!< TIMER TCSR: CAP_SRC Position */
N#define TIMER_TCSR_CAP_SRC_Msk      (1ul << TIMER_TCSR_CAP_SRC_Pos)			    /*!< TIMER TCSR: CAP_SRC Mask */
N
N#define TIMER_TCSR_TOGGLE_PIN_Pos   21											/*!< TIMER TCSR: TOGGLE_PIN Position */
N#define TIMER_TCSR_TOGGLE_PIN_Msk   (1ul << TIMER_TCSR_TOGGLE_PIN_Pos)		    /*!< TIMER TCSR: TOGGLE_PIN Mask */
N
N#define TIMER_TCSR_ERIODIC_SEL_Pos  20											/*!< TIMER TCSR: PERIODIC_SEL Position */
N#define TIMER_TCSR_ERIODIC_SEL_Msk  (1ul << TIMER_TCSR_ERIODIC_SEL_Pos)		    /*!< TIMER TCSR: PERIODIC_SEL Mask */
N
N#define TIMER_TCSR_INTR_TRG_EN_Pos  19											/*!< TIMER TCSR: INTR_TRG_EN Position */
N#define TIMER_TCSR_INTR_TRG_EN_Msk  (1ul << TIMER_TCSR_INTR_TRG_EN_Pos)		    /*!< TIMER TCSR: INTR_TRG_EN Mask */
N
N#define TIMER_TCSR_TDR_EN_Pos       16											/*!< TIMER TCSR: TDR_EN Position */
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)				/*!< TIMER TCSR: TDR_EN Mask */
N
N#define TIMER_TCSR_PRESCALE_Pos     0											/*!< TIMER TCSR: PRESCALE Position */
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)			/*!< TIMER TCSR: PRESCALE Mask */
N
N/* TIMER TCMPR Bit Field Definitions */
N#define TIMER_TCMP_TCMP_Pos         0											/*!< TIMER TCMPR: TCMP Position */
N#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)		    /*!< TIMER TCMPR: TCMP Mask */
N
N/* TIMER TISR Bit Field Definitions */
N#define TIMER_TISR_TWF_Pos          1											/*!< TIMER TISR: TWF Position */
N#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)					/*!< TIMER TISR: TWF Mask */
N
N#define TIMER_TISR_TIF_Pos          0											/*!< TIMER TISR: TIF Position */
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)					/*!< TIMER TISR: TIF Mask */
N
N/* TIMER TDR Bit Field Definitions */
N#define TIMER_TDR_TDR_Pos           0								            /*!< TIMER TDR: TDR Position */
N#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)	        /*!< TIMER TDR: TDR Mask */
N
N/* TIMER TCAP Bit Field Definitions */
N#define TIMER_TCAP_TCAP_Pos         0									        /*!< TIMER TCAP: TCAP Position */
N#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER TCAP: TCAP Mask */
N
N/* TIMER TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_TCDB_Pos       7											/*!< TIMER TEXCON: TCDB Position */
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)				/*!< TIMER TEXCON: TCDB Mask */
N
N#define TIMER_TEXCON_TEXDB_Pos      6											/*!< TIMER TEXCON: TEXDB Position */
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)				/*!< TIMER TEXCON: TEXDB Mask */
N
N#define TIMER_TEXCON_TEXIEN_Pos     5											/*!< TIMER TEXCON: TEXIEN Position */
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)			/*!< TIMER TEXCON: TEXIEN Mask */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4											/*!< TIMER TEXCON: RSTCAPSEL Position */
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)			/*!< TIMER TEXCON: RSTCAPSEL Mask */
N
N#define TIMER_TEXCON_TEXEN_Pos      3											/*!< TIMER TEXCON: TEXEN Position */
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)				/*!< TIMER TEXCON: TEXEN Mask */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1											/*!< TIMER TEXCON: TEX_EDGE Position */
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)		/*!< TIMER TEXCON: TEX_EDGE Mask */
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0											/*!< TIMER TEXCON: TX_PHASE Position */
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)			/*!< TIMER TEXCON: TX_PHASE Mask */
N
N/* TIMER TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0											/*!< TIMER TEXISR: TEXIF Position */
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)				/*!< TIMER TEXISR: TEXIF Mask */
N/*@}*/ /* end of group M051_TIMER */
N
N
N/*----------------------------- WDT Controller -----------------------------*/
N/** @addtogroup M051_WDT M051 WDT
N  Memory Mapped Structure for M051 Series Watchdog Timer
N  @{
N */
Ntypedef struct
N{
N    /**
N     * WTCR
N     * ===================================================================================================
N     * Offset: 0x00  Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WTR       |Clear Watchdog Timer 
N     * |        |          |Set this bit will clear the Watchdog timer. 
N     * |        |          |0= Writing 0 to this bit has no effect
N     * |        |          |1= Reset the contents of the Watchdog timer
N     * |        |          |NOTE: This bit will auto clear after few clock cycle
N     * |[1]     |WTRE      |Watchdog Timer Reset Enable
N     * |        |          |Setting this bit will enable the Watchdog timer reset function.
N     * |        |          |0= Disable Watchdog timer reset function
N     * |        |          |1= Enable Watchdog timer reset function
N     * |[2]     |WTRF      |Watchdog Timer Reset Flag
N     * |        |          |When the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by 
N     * |        |          |software to determine the source of reset. Software is responsible to clear it manually by writing 1 to 
N     * |        |          |it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.
N     * |        |          |0= Watchdog timer reset does not occur
N     * |        |          |1= Watchdog timer reset occurs
N     * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
N     * |[3]     |WTIF      |Watchdog Timer Interrupt Flag
N     * |        |          |If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the 
N     * |        |          |Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit 
N     * |        |          |indicates that a timeout period has elapsed.
N     * |        |          |0= Watchdog timer interrupt does not occur
N     * |        |          |1= Watchdog timer interrupt occurs
N     * |        |          |NOTE: Write 1 to clear this bit to zero.
N     * |[4]     |WTWKE     |Watchdog Timer Wakeup Function Enable bit
N     * |        |          |0 = Disable Watchdog timer Wakeup CPU function.
N     * |        |          |1 = Enable the Wakeup function that Watchdog timer timeout can wake up CPU from power-down 
N     * |        |          |mode.
N     * |[5]     |WTWKF     |Watchdog Timer Wakeup Flag
N     * |        |          |If Watchdog timer causes CPU wakes up from power-down mode, this bit will be set to high. It must 
N     * |        |          |be cleared by software with a write 1 to this bit.
N     * |        |          |1 = CPU wake up from sleep or power-down mode by Watchdog timeout.
N     * |        |          |0 = Watchdog timer does not cause CPU wakeup.
N     * |        |          |NOTE: Write 1 to clear this bit to zero.
N     * |[6]     |WTIE      |Watchdog Timer Interrupt Enable
N     * |        |          |0= Disable the Watchdog timer interrupt
N     * |        |          |1= Enable the Watchdog timer interrupt
N     * |[7]     |WTE       |Watchdog Timer Enable
N     * |        |          |0= Disable the Watchdog timer (This action will reset the internal counter)
N     * |        |          |1= Enable the Watchdog timer
N     * |[10:8]  |WTIS      |Watchdog Timer Interval Select (write protection bit)
N     * |        |          |These three bits select the timeout interval for the Watchdog timer. 
N     */    
N    __IO uint32_t  WTCR;                 
X    volatile uint32_t  WTCR;                 
N
N    /**
N     * WTCRALT
N     * ===================================================================================================
N     * Offset: 0x04  Watchdog Timer Alternative Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WTCRALT;              
X    volatile uint32_t  WTCRALT;              
N} WDT_T;
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT WTCR : DBGACK_WDT Position */
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT WTCR : DBGACK_WDT Mask */
N
N#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT WTCR : WTIS Position */
N#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT WTCR : WTIS Mask */
N
N#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT WTCR : WTE Position */
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT WTCR : WTE Mask */
N
N#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT WTCR : WTIE Position */
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT WTCR : WTIE Mask */
N
N#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT WTCR : WTWKF Position */
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT WTCR : WTWKF Mask */
N
N#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT WTCR : WTWKE Position */
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT WTCR : WTWKE Mask */
N
N#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT WTCR : WTIF Position */
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT WTCR : WTIF Mask */
N
N#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT WTCR : WTRF Position */
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT WTCR : WTRF Mask */
N
N#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT WTCR : WTRE Position */
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT WTCR : WTRE Mask */
N
N#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT WTCR : WTR Position */
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT WTCR : WTR Mask */
N
N/* WDT WTCRALT Bit Field Definitions */
N#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT WTCRALT : WTRDSEL Position */
N#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT WTCRALT : WTRDSEL Mask */
N/*@}*/ /* end of group M051_WDT */
N
N
N/*----------------------------- WWDT Controller -----------------------------*/
N/** @addtogroup M051_WWDT M051 WWDT
N  Memory Mapped Structure for M051 Series Window Watchdog Timer
N  @{
N */
Ntypedef struct
N{
N    /**
N     * WWDTRLD
N     * ===================================================================================================
N     * WWDT Reload Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WWDTRLD;
X    volatile uint32_t  WWDTRLD;
N
N    /**
N     * WWDTCR
N     * ===================================================================================================
N     * Offset: 0x04  Window Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WWDTCR;
X    volatile uint32_t  WWDTCR;
N
N    /**
N     * WWDTSR
N     * ===================================================================================================
N     * Offset: 0x08  Window Watchdog Timer Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WWDTSR;
X    volatile uint32_t  WWDTSR;
N
N    /**
N     * WWDTCVR
N     * ===================================================================================================
N     * Offset: 0x0C  Watchdog Timer Alternative Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WWDTCVR;
X    volatile uint32_t  WWDTCVR;
N
N} WWDT_T;
N
N/* WWDT WWDTRLD Bit Field Definitions */
N#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT WWDTRLD : WWDTRLD Position */
N#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT WWDTRLD : WWDTRLD Mask */
N
N/* WWDT WWDTCR Bit Field Definitions */
N#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT WWDTCR : DBGACK_WWDT Position */
N#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT WWDTCR : DBGACK_WWDT Mask */
N
N#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT WWDTCR : WINCMP Position */
N#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT WWDTCR : WINCMP Mask */
N
N#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT WWDTCR : PERIODSEL Position */
N#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT WWDTCR : PERIODSEL Mask */
N
N#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT WWDTCR : WWDTIE Position */
N#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT WWDTCR : WWDTIE Mask */
N
N#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT WWDTCR : WWDTEN Position */
N#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_PERIODSEL_Pos)          /*!< WWDT WWDTCR : WWDTEN Mask */
N
N/* WWDT WWDTSR Bit Field Definitions */
N#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT WWDTSR : WWDTRF Position */
N#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT WWDTSR : WWDTRF Mask */
N
N#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT WWDTSR : WWDTIF Position */
N#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT WWDTSR : WWDTIF Mask */
N
N/* WWDT WWDTCVR Bit Field Definitions */
N#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT WWDTCVR : WWDTRF Position */
N#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT WWDTCVR : WWDTRF Mask */
N/*@}*/ /* end of group M051_WWDT */
N
N
N/*------------------------- SPI Interface Controller -------------------------*/
N/** @addtogroup M051_SPI M051 SPI
N  Memory Mapped Structure for M051 Series SPI Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * CNTRL
N     * ===================================================================================================
N     * Offset: 0x00  SPI Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GO_BUSY   |Go and Busy Status
N     * |        |          |1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave 
N     * |        |          |mode, writing 1 to this bit indicates that the slave is ready to communicate with a 
N     * |        |          |master.
N     * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
N     * |        |          |During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will 
N     * |        |          |be cleared automatically.
N     * |        |          |NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The 
N     * |        |          |transfer result will be unpredictable if software changes related settings when 
N     * |        |          |GO_BUSY bit is 1.
N     * |[1]     |RX_NEG    |Receive At Negative Edge
N     * |        |          |1 = The received data input signal is latched at the falling edge of SPICLK.
N     * |        |          |0 = The received data input signal is latched at the rising edge of SPICLK.
N     * |[2]     |TX_NEG    |Transmit At Negative Edge
N     * |        |          |1 = The transmitted data output signal is changed at the falling edge of SPICLK.
N     * |        |          |0 = The transmitted data output signal is changed at the rising edge of SPICLK.
N     * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
N     * |        |          |This field specifies how many bits are transmitted in one transaction. Up to 32 bits 
N     * |        |          |can be transmitted.
N     * |        |          |TX_BIT_LEN = 0x01 ... 1 bit
N     * |        |          |TX_BIT_LEN = 0x02 ... 2 bits
N     * |        |          |......
N     * |        |          |TX_BIT_LEN = 0x1f ... 31 bits
N     * |        |          |TX_BIT_LEN = 0x00 .. 32 bits
N     * |[9:8]   |TX_NUM    |Numbers of Transmit/Receive Word
N     * |        |          |This field specifies how many transmit/receive word numbers should be executed 
N     * |        |          |in one transfer.
N     * |        |          |00 = Only one transmit/receive word will be executed in one transfer.
N     * |        |          |01 = Two successive transmit/receive words will be executed in one transfer. (burst 
N     * |        |          |mode)
N     * |        |          |10 = Reserved.
N     * |        |          |11 = Reserved.
N     * |[10]    |LSB       |LSB First
N     * |        |          |1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received 
N     * |        |          |from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
N     * |        |          |0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 
N     * |        |          |register that is depends on the TX_BIT_LEN field).
N     * |[11]    |CLKP      |Clock Polarity
N     * |        |          |1 = SPICLK idle high.
N     * |        |          |0 = SPICLK idle low.
N     * |[15:12] |SP_CYCLE  |Suspend Interval (master only)
N     * |        |          |These four bits provide configurable suspend interval between two successive 
N     * |        |          |transmit/receive transactions in a transfer. The suspend interval is from the last 
N     * |        |          |falling clock edge of the current transaction to the first rising clock edge of the 
N     * |        |          |successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock 
N     * |        |          |edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, 
N     * |        |          |setting this field has no effect on transfer. The desired suspend interval is obtained 
N     * |        |          |according to the following equation:
N     * |        |          |(SP_CYCLE[3:0] + 2)*period of SPI clock
N     * |        |          |SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
N     * |        |          |SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
N     * |        |          |......
N     * |        |          |SP_CYCLE = 0xe ... 16 SPICLK clock cycle
N     * |        |          |SP_CYCLE = 0xf ... 17 SPICLK clock cycle
N     * |[16]    |IF        |Interrupt Flag
N     * |        |          |1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
N     * |        |          |0 = It indicates that the transfer does not finish yet.
N     * |        |          |NOTE: This bit can be cleared by writing 1 to itself.
N     * |[17]    |IE        |Interrupt Enable
N     * |        |          |1 = Enable MICROWIRE/SPI Interrupt.
N     * |        |          |0 = Disable MICROWIRE/SPI Interrupt.
N     * |[18]    |SLAVE     |SLAVE Mode Indication
N     * |        |          |1 = Slave mode.
N     * |        |          |0 = Master mode.
N     * |[20:19] |REORDER   |Reorder Mode Select
N     * |        |          |00 = Disable both byte reorder and byte suspend functions.
N     * |        |          |01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK 
N     * |        |          |cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. 
N     * |        |          |(32 bits/word).
N     * |        |          |10 = Enable byte reorder function, but disable byte suspend function.
N     * |        |          |11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK 
N     * |        |          |cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. 
N     * |        |          |(32 bits/word).
N     * |        |          |Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.
N     * |[23]    |VARCLK_EN |Variable Clock Enable (master only)
N     * |        |          |1 = The serial clock output frequency is variable. The output frequency is decided 
N     * |        |          |by the value of VARCLK, DIVIDER, and DIVIDER2.
N     * |        |          |0 = The serial clock output frequency is fixed and decided only by the value of 
N     * |        |          |DIVIDER. 
N     * |        |          |Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be 
N     * |        |          |programmed as 0x10 (16 bits mode)
N     */    
N    __IO uint32_t CNTRL;
X    volatile uint32_t CNTRL;
N
N    /**
N     * DIVIDER
N     * ===================================================================================================
N     * Offset: 0x04  SPI Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |DIVIDER   |Clock Divider Register (master only) 
N     * |        |          |The value in this field is the frequency divider of the system clock, PCLK, to generate 
N     * |        |          |the serial clock on the output SPICLK. The desired frequency is obtained according to 
N     * |        |          |the following equation:
N     * |        |          |fsclk = fpclk / ((DIVIDER+1)*2)
N     * |        |          |In slave mode, the period of SPI clock driven by a master shall equal or over 5 times 
N     * |        |          |the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of 
N     * |        |          |the frequency of slave's PCLK.
N     * |[31:16] |DIVIDER2  |Clock Divider 2 Register (master only) 
N     * |        |          |The value in this field is the 2nd frequency divider of the system clock, PCLK, to 
N     * |        |          |generate the serial clock on the output SPICLK. The desired frequency is obtained 
N     * |        |          |according to the following equation:
N     * |        |          |fsclk = fpclk / ((DIVIDER2+1)*2)
N     */    
N    __IO uint32_t DIVIDER;
X    volatile uint32_t DIVIDER;
N
N    /**
N     * SSR
N     * ===================================================================================================
N     * Offset: 0x08  SPI Slave Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SSR       |Slave Select Register (master only)
N     * |        |          |If AUTOSS bit is cleared, writing 1 to this bit sets the SPISSx line to active state and 
N     * |        |          |writing 0 sets the line back to inactive state.
N     * |        |          |If AUTOSS bit is set, writing 1 to this bit will select the SPISSx line to be automatically 
N     * |        |          |driven to active state for the duration of the transmit/receive, and will be driven to 
N     * |        |          |inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in 
N     * |        |          |SS_LVL).
N     * |[2]     |SS_LVL    |Slave Select Active Level
N     * |        |          |It defines the active level of slave select signal (SPISSx). 
N     * |        |          |1 = The slave select signal SPISSx is active at high-level/rising-edge.
N     * |        |          |0 = The slave select signal SPISSx is active at low-level/falling-edge.
N     * |[3]     |AUTOSS    |Automatic Slave Select (master only)
N     * |        |          |1 = If this bit is set, SPISSx signal is generated automatically. It means that slave 
N     * |        |          |select signal will be asserted by the SPI controller when transmit/receive is started by 
N     * |        |          |setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
N     * |        |          |0 = If this bit is cleared, slave select signal will be asserted and de-asserted by setting 
N     * |        |          |and clearing SSR[0].
N     * |[4]     |SS_LTRIG  |Slave Select Level Trigger (slave only)
N     * |        |          |1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the 
N     * |        |          |signal is active low or active high.
N     * |        |          |0: The input slave select signal is edge-trigger. This is default value.
N     * |[5]     |LTRIG_FLAG|Level Trigger Flag
N     * |        |          |When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the 
N     * |        |          |received bit number is met the requirement or not.
N     * |        |          |1 = The transaction number and the transferred bit length met the specified 
N     * |        |          |requirements which defined in TX_NUM and TX_BIT_LEN.
N     * |        |          |0 = The transaction number or the transferred bit length of one transaction doesn't 
N     * |        |          |meet the specified requirements.
N     * |        |          |Note: This bit is READ only
N     */    
N    __IO uint32_t SSR;
X    volatile uint32_t SSR;
N
N    /**
N     * RESERVE0
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t RESERVE0;
X    volatile const  uint32_t RESERVE0;
N
N    /**
N     * SPI_RX0, SPI_RX1
N     * ===================================================================================================
N     * Offset: 0x10, 0x14  Data Receive Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RX        |Data Receive Register
N     * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer. The 
N     * |        |          |number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For 
N     * |        |          |example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the 
N     * |        |          |received data.
N     * |        |          |NOTE: The Data Receive Registers are read only registers.
N     */    
N    __I  uint32_t RX[2];
X    volatile const  uint32_t RX[2];
N
N    /**
N     * RESERVE1
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t RESERVE1;
X    volatile const  uint32_t RESERVE1;
N
N    /**
N     * RESERVE2
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t RESERVE2;
X    volatile const  uint32_t RESERVE2;
N
N    /**
N     * SPI_TX0, SPI_TX1
N     * ===================================================================================================
N     * Offset: 0x20, 0x24  Data Transmit Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TX        |Data Transmit Register
N     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer. The number 
N     * |        |          |of valid bits depend on the transmit bit length field in the CNTRL register. 
N     * |        |          |For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be 
N     * |        |          |transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will 
N     * |        |          |perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], 
N     * |        |          |TX1[31:0]).
N     */    
N    __O  uint32_t TX[2];
X    volatile  uint32_t TX[2];
N
N    /**
N     * RESERVE3
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t RESERVE3;
X    volatile const  uint32_t RESERVE3;
N
N    /**
N     * RESERVE4
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t RESERVE4;
X    volatile const  uint32_t RESERVE4;
N
N    /**
N     * RESERVE5
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t RESERVE5;
X    volatile const  uint32_t RESERVE5;
N
N    /**
N     * VARCLK
N     * ===================================================================================================
N     * Offset: 0x34  Variable Clock Pattern Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VARCLK    |Variable Clock Pattern 
N     * |        |          |The value in this field is the frequency patterns of the SPI clock. If the bit patterns of 
N     * |        |          |VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If 
N     * |        |          |the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value 
N     * |        |          |of DIVIDER2. Refer to register SPI_DIVIDER.
N     */    
N    __IO uint32_t VARCLK;
X    volatile uint32_t VARCLK;
N
N    /**
N     * RESERVE6
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t RESERVE6;
X    volatile const  uint32_t RESERVE6;
N
N    /**
N     * CNTRL2
N     * ===================================================================================================
N     * Offset: 0x3C  SPI Control and Status Register 2
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t CNTRL2;
X    volatile uint32_t CNTRL2;
N
N    /**
N     * FIFO_CTL
N     * ===================================================================================================
N     * Offset: 0x40  SPI FIFO Control Register 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t FIFO_CTL;
X    volatile uint32_t FIFO_CTL;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x44  SPI Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N} SPI_T;
N
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI CNTRL: TX_FULL Position */
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI CNTRL: TX_FULL Mask     */
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI CNTRL: TX_EMPTY Position */
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI CNTRL: TX_EMPTY Mask     */
N
N#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI CNTRL: RX_FULL Position */
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI CNTRL: RX_FULL Mask     */
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI CNTRL: RX_EMPTY Position */
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI CNTRL: RX_EMPTY Mask     */
N
N#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI CNTRL: VARCLK_EN Position */
N#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI CNTRL: VARCLK_EN Mask     */
N
N#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI CNTRL: FIFO Position */
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI CNTRL: FIFO Mask     */
N
N#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI CNTRL: REORDER Position */
N#define SPI_CNTRL_REORDER_Msk      (3ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI CNTRL: REORDER Mask     */
N
N#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI CNTRL: SLAVE Position */
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI CNTRL: SLAVE Mask     */
N
N#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI CNTRL: IE Position */
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI CNTRL: IE Mask     */
N
N#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI CNTRL: IF Position */
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI CNTRL: IF Mask     */
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI CNTRL: SP_CYCLE Position */
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI CNTRL: SP_CYCLE Mask     */
N
N#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI CNTRL: CLKP Position */
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI CNTRL: CLKP Mask     */
N
N#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI CNTRL: LSB Position */
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI CNTRL: LSB Mask     */
N
N#define SPI_CNTRL_TX_NUM_Pos       8                                      /*!< SPI CNTRL: TX_NUM Position */
N#define SPI_CNTRL_TX_NUM_Msk       (3ul << SPI_CNTRL_TX_NUM_Pos)          /*!< SPI CNTRL: TX_NUM Mask     */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI CNTRL: TX_BIT_LEN Position */
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI CNTRL: TX_BIT_LEN Mask     */
N
N#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI CNTRL: TX_NEG Position */
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI CNTRL: TX_NEG Mask     */
N
N#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI CNTRL: RX_NEG Position */
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI CNTRL: RX_NEG Mask     */
N
N#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI CNTRL: GO_BUSY Position */
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI CNTRL: GO_BUSY Mask     */
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER2_Pos   16                                       /*!< SPI DIVIDER: DIVIDER2 Position */
N#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI DIVIDER: DIVIDER2 Mask */
N
N#define SPI_DIVIDER_DIVIDER_Pos    0                                        /*!< SPI DIVIDER: DIVIDER Position */
N#define SPI_DIVIDER_DIVIDER_Msk    (0xFFFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI DIVIDER: DIVIDER Mask */
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI SSR: LTRIG_FLAG Position */
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI SSR: LTRIG_FLAG Mask */
N
N#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI SSR: SS_LTRIG Position */
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI SSR: SS_LTRIG Mask */
N
N#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI SSR: AUTOSS Position */
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI SSR: AUTOSS Mask */
N
N#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI SSR: SS_LVL Position */
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI SSR: SS_LVL Mask */
N
N#define SPI_SSR_SSR_Pos            0                                 /*!< SPI SSR: SSR Position */
N#define SPI_SSR_SSR_Msk            (1ul << SPI_SSR_SSR_Pos)          /*!< SPI SSR: SSR Mask */
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI CNTRL2: BCn Position */
N#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI CNTRL2: BCn Mask */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI CNTRL2: SS_INT_OPT Position */
N#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI CNTRL2: SS_INT_OPT Mask */
N
N#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI CNTRL2: DUAL_IO_EN Position */
N#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI CNTRL2: DUAL_IO_EN Mask */
N
N#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI CNTRL2: DUAL_IO_DIR Position */
N#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI CNTRL2: DUAL_IO_DIR Mask */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI CNTRL2: SLV_START_INTSTS Position */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI CNTRL2: SLV_START_INTSTS Mask */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI CNTRL2: SSTA_INTEN Position */
N#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI CNTRL2: SSTA_INTEN Mask */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI CNTRL2: SLV_ABORT Position */
N#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI CNTRL2: SLV_ABORT Mask */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI CNTRL2: NOSLVSEL Position */
N#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI CNTRL2: NOSLVSEL Mask */
N
N#define SPI_CNTRL2_DIV_ONE_Pos      0                                                /*!< SPI CNTRL2: DIV_ONE Position */
N#define SPI_CNTRL2_DIV_ONE_Msk      (1ul << SPI_CNTRL2_DIV_ONE_Pos)                  /*!< SPI CNTRL2: DIV_ONE Mask */
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI FIFO_CTL: TX_THRESHOLD Position */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: TX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI FIFO_CTL: RX_THRESHOLD Position */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: RX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI FIFO_CTL: TIMEOUT_INTEN Position */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI FIFO_CTL: TIMEOUT_INTEN Mask */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI FIFO_CTL: RXOV_INTEN Position */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI FIFO_CTL: RXOV_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI FIFO_CTL: TX_INTEN Position */
N#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI FIFO_CTL: TX_INTEN Mask */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI FIFO_CTL: RX_INTEN Position */
N#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI FIFO_CTL: RX_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI FIFO_CTL: TX_CLR Position */
N#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI FIFO_CTL: TX_CLR Mask */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI FIFO_CTL: RX_CLR Position */
N#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI FIFO_CTL: RX_CLR Mask */
N
N/* SPI_STATUS Bit Field Definitions */
N#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI STATUS: TX_FIFO_COUNT Position */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI STATUS: TX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI STATUS: TX_FULL Position */
N#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI STATUS: TX_FULL Mask */
N
N#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI STATUS: TX_EMPTY Position */
N#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI STATUS: TX_EMPTY Mask */
N
N#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI STATUS: RX_FULL Position */
N#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI STATUS: RX_FULL Mask */
N
N#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI STATUS: RX_EMPTY Position */
N#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI STATUS: RX_EMPTY Mask */
N
N#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI STATUS: TIMEOUT Position */
N#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI STATUS: TIMEOUT Mask */
N
N#define SPI_STATUS_IF_Pos           16                                               /*!< SPI STATUS: IF Position */
N#define SPI_STATUS_IF_Msk           (1ul << SPI_STATUS_IF_Pos)                       /*!< SPI STATUS: IF Mask     */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI STATUS: RX_FIFO_COUNT Position */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI STATUS: RX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI STATUS: SLV_START_INTSTS Position */
N#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI STATUS: SLV_START_INTSTS Mask */
N
N#define SPI_STATUS_TX_INTSTS_Pos    4                                                /*!< SPI STATUS: TX_INTSTS Position */
N#define SPI_STATUS_TX_INTSTS_Msk    (1ul << SPI_STATUS_TX_INTSTS_Pos)                /*!< SPI STATUS: TX_INTSTS Mask */
N
N#define SPI_STATUS_RX_OVERRUN_Pos    2                                               /*!< SPI STATUS: RX_OVERRUN Position */
N#define SPI_STATUS_RX_OVERRUN_Msk    (1ul << SPI_STATUS_RX_OVERRUN_Pos)              /*!< SPI STATUS: RX_OVERRUN Mask */
N
N#define SPI_STATUS_RX_INTSTS_Pos    0                                                /*!< SPI STATUS: RX_INTSTS Position */
N#define SPI_STATUS_RX_INTSTS_Msk    (1ul << SPI_STATUS_RX_INTSTS_Pos)                /*!< SPI STATUS: RX_INTSTS Mask */
N/*@}*/ /* end of group M051_SPI */
N
N
N/*------------------------------ I2C Controller ------------------------------*/
N
N/** @addtogroup M051_I2C M051 I2C
N  Memory Mapped Structure for M051 Series I2C Serial Interface Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * I2CON
N     * ===================================================================================================
N     * Offset: 0x00  I2C Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |AA        |Assert Acknowledge control bit. 
N     * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during 
N     * |        |          |the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from 
N     * |        |          |master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to 
N     * |        |          |address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge 
N     * |        |          |clock pulse on the SCL line.
N     * |[3]     |SI        |I2C Interrupt Flag. 
N     * |        |          |When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI 
N     * |        |          |(I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one 
N     * |        |          |to this bit.
N     * |[4]     |STO       |I2C STOP Flag. 
N     * |        |          |In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus 
N     * |        |          |condition if a STOP condition is detected this flag will be cleared by hardware automatically. 
N     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means 
N     * |        |          |it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
N     * |[5]     |STA       |I2C START Flag. 
N     * |        |          |Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition 
N     * |        |          |to bus when the bus is free.
N     * |[6]     |ENSI      |I2C controller is enabled/disable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function 
N     * |        |          |pin function of SDA and SCL must set to I2C function first.
N     * |[7]     |EI        |Enable interrupt. 
N     * |        |          |1 = Enable I2C interrupt.
N     * |        |          |0 = Disable I2C interrupt. 
N     */    
N    __IO uint32_t I2CON;
X    volatile uint32_t I2CON;
N
N    /**
N     * I2CADDR0
N     * ===================================================================================================
N     * Offset: 0x04  I2C Slave Address Register 0 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */    
N    __IO uint32_t I2CADDR0;
X    volatile uint32_t I2CADDR0;
N
N    /**
N     * I2CDAT
N     * ===================================================================================================
N     * Offset: 0x08  I2C Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CDAT    |I2C Data Register
N     * |        |          |Bit[7:0] is located with the 8-bit transferred data of I2C serial port. 
N     */    
N    __IO uint32_t I2CDAT;
X    volatile uint32_t I2CDAT;
N
N    /**
N     * I2CSTATUS
N     * ===================================================================================================
N     * Offset: 0x0C  I2C Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CSTATUS |I2C Status Register 
N     * |        |          |The status register of I2C:
N     * |        |          |The three least significant bits are always 0. The five most significant bits contain the status code. 
N     * |        |          |There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is 
N     * |        |          |requested. All other I2STATUS values correspond to defined I2C states. When each of these 
N     * |        |          |states is entered, a status interrupt is requested (SI = 1). A valid status code is present in 
N     * |        |          |I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle 
N     * |        |          |after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error 
N     * |        |          |occurs when a START or STOP condition is present at an illegal position in the formation frame. 
N     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an 
N     * |        |          |acknowledge bit.
N     */    
N    __I  uint32_t I2CSTATUS;
X    volatile const  uint32_t I2CSTATUS;
N
N    /**
N     * I2CLK
N     * ===================================================================================================
N     * Offset: 0x10  I2C Clock Divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CLK     |I2C clock divided Register
N     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).
N     */    
N    __IO uint32_t I2CLK;
X    volatile uint32_t I2CLK;
N
N    /**
N     * I2CTOC
N     * ===================================================================================================
N     * Offset: 0x14  I2C Time-Out Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Time-Out flag. 
N     * |        |          |1 = Time-Out falg is set by H/W. It can interrupt CPU.
N     * |        |          |0 = S/W can clear the flag.
N     * |[1]     |DIV4      |Time-Out counter input clock is divider by 4 
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |When Enable, The time-Out period is prolong 4 times.
N     * |[2]     |ENTI      |Time-out counter is enabled/disable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will 
N     * |        |          |reset counter and re-start up counting after SI is cleared.
N     */    
N    __IO uint32_t I2CTOC;
X    volatile uint32_t I2CTOC;
N
N    /**
N     * I2CADDR1
N     * ===================================================================================================
N     * Offset: 0x18  I2C Slave Address Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */    
N    __IO uint32_t I2CADDR1;
X    volatile uint32_t I2CADDR1;
N
N    /**
N     * I2CADDR2
N     * ===================================================================================================
N     * Offset: 0x1C  I2C Slave Address Register 2 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */    
N    __IO uint32_t I2CADDR2;
X    volatile uint32_t I2CADDR2;
N
N    /**
N     * I2CADDR3
N     * ===================================================================================================
N     * Offset: 0x20  I2C Slave Address Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */    
N    __IO uint32_t I2CADDR3;
X    volatile uint32_t I2CADDR3;
N
N    /**
N     * I2CADM0
N     * ===================================================================================================
N     * Offset: 0x24  I2C Slave Address Mask Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM0;
X    volatile uint32_t I2CADM0;
N
N    /**
N     * I2CADM1
N     * ===================================================================================================
N     * Offset: 0x28  I2C Slave Address Mask Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM1;
X    volatile uint32_t I2CADM1;
N
N    /**
N     * I2CADM2
N     * ===================================================================================================
N     * Offset: 0x2C  I2C Slave Address Mask Register 2 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM2;
X    volatile uint32_t I2CADM2;
N
N    /**
N     * I2CADM3
N     * ===================================================================================================
N     * Offset: 0x30  I2C Slave Address Mask Register 3 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM3;
X    volatile uint32_t I2CADM3;
N
N    /**
N     * RESERVED0
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    uint32_t RESERVED0[2];
N
N    /**
N     * I2CWKUPCON
N     * ===================================================================================================
N     * Offset: 0x3C  I2C Wake Up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t I2CWKUPCON;
X    volatile uint32_t I2CWKUPCON;
N
N    /**
N     * I2CWKUPSTS
N     * ===================================================================================================
N     * Offset: 0x40  I2C Wake Up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t I2CWKUPSTS;
X    volatile uint32_t I2CWKUPSTS;
N
N} I2C_T;
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C I2CON: EI Position */
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C I2CON: EI Mask */
N
N#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C I2CON: ENS1 Position */
N#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C I2CON: ENS1 Mask */
N
N#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C I2CON: STA Position */
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C I2CON: STA Mask */
N
N#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C I2CON: STO Position */
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C I2CON: STO Mask */
N
N#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C I2CON: SI Position */
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C I2CON: SI Mask */
N
N#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C I2CON: AA Position */
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C I2CON: AA Mask */
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C I2CADDR: I2CADDR Position */
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C I2CADDR: I2CADDR Mask */
N
N#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C I2CADDR: GC Position */
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C I2CADDR: GC Mask */
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C I2CDAT: I2CDAT Position */
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C I2CDAT: I2CDAT Mask */
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C I2CSTATUS: I2CSTATUS Position */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C I2CSTATUS: I2CSTATUS Mask */
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C I2CLK: I2CLK Position */
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C I2CLK: I2CLK Mask */
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C I2CTOC: ENTI Position */
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C I2CTOC: ENTI Mask */
N
N#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C I2CTOC: DIV4 Position */
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C I2CTOC: DIV4 Mask */
N
N#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C I2CTOC: TIF Position */
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C I2CTOC: TIF Mask */
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C I2CADM: I2CADM Position */
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C I2CADM: I2CADM Mask */
N
N/* I2C I2CWKUPCON Bit Field Definitions */
N#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C I2CWKUPCON: WKUPEN Position */
N#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C I2CWKUPCON: WKUPEN Mask */
N
N/* I2C I2CWKUPSTS Bit Field Definitions */
N#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C I2CWKUPSTS: WKUPIF Position */
N#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C I2CWKUPSTS: WKUPIF Mask */
N
N
N/*@}*/ /* end of group M051_I2C */
N
N/*----------------------------- ADC Controller -------------------------------*/
N/** @addtogroup M051_ADC M051 ADC
N  Memory Mapped Structure for M051 Series ADC Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * ADDR
N     * ===================================================================================================
N     * Offset: 0x00-0x1C  A/D Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |RSLT      |A/D Conversion Result
N     * |        |          |This field contains 12 bits conversion result.
N     * |[16]    |OVERRUN   |Over Run Flag
N     * |        |          |1 = Data in RSLT[11:0] is overwrite.
N     * |        |          |0 = Data in RSLT[11:0] is recent conversion result.
N     * |        |          |If converted data in RSLT[11:0] has not been read before new conversion result is 
N     * |        |          |loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after 
N     * |        |          |ADDR register is read.
N     * |[17]    |VALID     |Valid Flag
N     * |        |          |1 = Data in RSLT[11:0] bits is valid.
N     * |        |          |0 = Data in RSLT[11:0] bits is not valid.
N     * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed 
N     * |        |          |and cleared by hardware after ADDR register is read.
N     */    
N    __I uint32_t ADDR[8];
X    volatile const uint32_t ADDR[8];
N
N    /**
N     * ADCR
N     * ===================================================================================================
N     * Offset: 0x20  A/D Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADEN      |A/D Converter Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to 
N     * |        |          |disable A/D converter analog circuit for saving power consumption.
N     * |[1]     |ADIE      |A/D Interrupt Enable
N     * |        |          |1 = Enable A/D interrupt function
N     * |        |          |0 = Disable A/D interrupt function
N     * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
N     * |[3:2]   |ADMD      |A/D Converter Operation Mode
N     * |        |          |00 = Single conversion
N     * |        |          |01 = Burst conversion
N     * |        |          |10 = Single-cycle scan
N     * |        |          |11 = Continuous scan
N     * |        |          |When changing the operation mode, software should disable ADST bit firstly.
N     * |        |          |Note: In Burst Mode, the A/D result data always at Data Register 0.
N     * |[5:4]   |TRGS      |Hardware Trigger Source
N     * |        |          |00 = A/D conversion is started by external STADC pin.
N     * |        |          |Others = Reserved
N     * |        |          |Software should disable TRGE and ADST before change TRGS. 
N     * |        |          |In hardware trigger mode, the ADST bit is set by the external trigger from STADC.
N     * |[7:6]   |TRGCOND   |External Trigger Condition
N     * |        |          |These two bits decide external pin STADC trigger event is level or edge. The signal 
N     * |        |          |must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and 
N     * |        |          |low state.
N     * |        |          |00 = Low level
N     * |        |          |01 = High level
N     * |        |          |10 = Falling edge
N     * |        |          |11 = Rising edge
N     * |[8]     |TRGE      |External Trigger Enable
N     * |        |          |Enable or disable triggering of A/D conversion by external STADC pin.
N     * |        |          |1= Enable
N     * |        |          |0= Disable
N     * |[10]    |DIFFEN    |A/D Differential Input Mode Enable
N     * |        |          |1 = A/D is in differential analog input mode
N     * |        |          |0 = A/D is in single-end analog input mode
N     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus
N     * |        |          |The Vplus of differential input paired channel 0 is from ADC0 pin; Vminus is from ADC1 pin.
N     * |        |          |The Vplus of differential input paired channel 1 is from ADC2 pin; Vminus is from ADC3 pin.
N     * |        |          |The Vplus of differential input paired channel 2 is from ADC4 pin; Vminus is from ADC5 pin.
N     * |        |          |The Vplus of differential input paired channel 3 is from ADC6 pin; Vminus is from ADC7 pin.
N     * |        |          |In differential input mode, only one of the two corresponding channels needs to be 
N     * |        |          |enabled in ADCHER. The conversion result will be placed to the corresponding data 
N     * |        |          |register of the enabled channel. If both channels of a differential input paired channel 
N     * |        |          |are enabled, the ADC will convert it twice in scan mode. And then write the conversion 
N     * |        |          |result to the two corresponding data registers.
N     * |[11]    |ADST      |A/D Conversion Start
N     * |        |          |1 = Conversion start.
N     * |        |          |0 = Conversion stopped and A/D converter enter idle state.
N     * |        |          |ADST bit can be controlled by two sources: software write and external pin STADC. 
N     * |        |          |ADST is cleared to 0 by hardware automatically at the ends of single mode and single-
N     * |        |          |cycle scan mode on specified channels. In continuous scan mode, A/D conversion is 
N     * |        |          |continuously performed sequentially until this bit is cleared to 0 or chip reset.
N     */    
N    __IO uint32_t ADCR;
X    volatile uint32_t ADCR;
N
N    /**
N     * ADCHER
N     * ===================================================================================================
N     * Offset: 0x24  A/D Channel Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN0     |Analog Input Channel 0 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |This channel is the default enabled channel if CHEN0~7 are set as 0s.
N     * |[1]     |CHEN1     |Analog Input Channel 1 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |[2]     |CHEN2     |Analog Input Channel 2 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |[3]     |CHEN3     |Analog Input Channel 3 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |[4]     |CHEN4     |Analog Input Channel 4 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |[5]     |CHEN5     |Analog Input Channel 5 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |[6]     |CHEN6     |Analog Input Channel 6 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |[7]     |CHEN7     |Analog Input Channel 7 Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |[9:8]   |PRESEL    |Analog Input Channel 7 select
N     * |        |          |00: External analog input
N     * |        |          |01: Internal bandgap voltage
N     * |        |          |1x: Reserved
N     */    
N    __IO uint32_t ADCHER;
X    volatile uint32_t ADCHER;
N
N    /**
N     * ADCMPR
N     * ===================================================================================================
N     * Offset: 0x28,0x2C  A/D Compare Register 0 & 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMPEN     |Compare Enable
N     * |        |          |1 = Enable compare.
N     * |        |          |0 = Disable compare.
N     * |        |          |Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion 
N     * |        |          |result when converted data is loaded into ADDR register.
N     * |[1]     |CMPIE     |Compare Interrupt Enable
N     * |        |          |1 = Enable compare function interrupt.
N     * |        |          |0 = Disable compare function interrupt.
N     * |        |          |If the compare function is enabled and the compare condition matches the settings 
N     * |        |          |of CMPCOND and CMPMATCNT, CMPF0 bit will be asserted. If CMPIE is set to 
N     * |        |          |1, a compare interrupt request is generated.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |1= Set the compare condition as that when a 12-bit A/D conversion result is 
N     * |        |          |greater or equal to the 12-bit CMPD(ADCMPR0[27:16]), the internal match 
N     * |        |          |counter will increase one.
N     * |        |          |0= Set the compare condition as that when a 12-bit A/D conversion result is less 
N     * |        |          |than the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will 
N     * |        |          |increase one.
N     * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT +1), the 
N     * |        |          |CMPF0 bit will be set.
N     * |[5:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |000 = Channel 0 conversion result is selected to be compared.
N     * |        |          |001 = Channel 1 conversion result is selected to be compared.
N     * |        |          |010 = Channel 2 conversion result is selected to be compared.
N     * |        |          |011 = Channel 3 conversion result is selected to be compared.
N     * |        |          |100 = Channel 4 conversion result is selected to be compared.
N     * |        |          |101 = Channel 5 conversion result is selected to be compared.
N     * |        |          |110 = Channel 6 conversion result is selected to be compared.
N     * |        |          |111 = Channel 7 conversion result is selected to be compared.
N     * |[11:8]  |CMPMATCNT |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare 
N     * |        |          |condition defined by CMPCOND[2], the internal match counter will increase 1. 
N     * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit 
N     * |        |          |will be set.
N     * |[27:16] |CMPD      |Comparison Data
N     * |        |          |The 12 bits data is used to compare with conversion result of specified channel. 
N     * |        |          |Software can use it to monitor the external analog input pin voltage transition in 
N     * |        |          |scan mode without imposing a load on software.
N     */    
N    __IO uint32_t ADCMPR[2];
X    volatile uint32_t ADCMPR[2];
N
N    /**
N     * ADSR
N     * ===================================================================================================
N     * Offset: 0x30  ADC Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADF       |A/D Conversion End Flag
N     * |        |          |A status flag that indicates the end of A/D conversion.
N     * |        |          |ADF is set to 1 at these two conditions:
N     * |        |          |1.	When A/D conversion ends in single mode
N     * |        |          |2.	When A/D conversion ends on all specified channels in scan mode.
N     * |        |          |3.	When more than 4 samples in FIFO in Burst mode.
N     * |        |          |This bit can be cleared by writing 1 to itself.
N     * |[1]     |CMPF0     |Compare Flag
N     * |        |          |When the selected channel A/D conversion result meets the setting conditions of 
N     * |        |          |ADCMPR0 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
N     * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting
N     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting
N     * |[2]     |CMPF1     |Compare Flag
N     * |        |          |When the selected channel A/D conversion result meets the setting conditions of 
N     * |        |          |ADCMPR1 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
N     * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting
N     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting
N     * |[3]     |BUSY      |BUSY/IDLE
N     * |        |          |1 = A/D converter is busy at conversion.
N     * |        |          |0 = A/D converter is in idle state.
N     * |        |          |This bit is mirror of as ADST bit in ADCR.
N     * |        |          |It is read only.
N     * |[6:4]   |CHANNEL   |Current Conversion Channel
N     * |        |          |This filed reflects current conversion channel when BUSY=1. When BUSY=0, it 
N     * |        |          |shows the next channel will be converted.
N     * |        |          |It is read only.
N     * |[15:8]  |VALID     |Data Valid flag
N     * |        |          |It is a mirror of VALID bit in ADDRx
N     * |        |          |When ADC is in Burst Mode, and there is at least one valid conversion result in buffer, 
N     * |        |          |VALID[7:0] will all set to 1.
N     * |[23:16] |OVERRUN   |Over Run flag
N     * |        |          |It is a mirror to OVERRUN bit in ADDRx
N     * |        |          |When ADC is in Burst Mode, and the buffer is overrun, OVERRUN[7:0] will all set to 
N     * |        |          |1.
N     */    
N    __IO uint32_t ADSR;
X    volatile uint32_t ADSR;
N
N    /**
N     * ADCALR
N     * ===================================================================================================
N     * Offset: 0x34  ADC Calibration Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CALEN     |Self Calibration Enable 
N     * |        |          |1 = Enable self calibration 
N     * |        |          |0 = Disable self calibration 
N     * |        |          |Software can set this bit to 1 enables A/D converter to do self calibration function. It needs 127 
N     * |        |          |ADC clocks to complete calibration. This bit must be kept at 1 after CALDONE asserted. 
N     * |        |          |Clearing this bit will disable self calibration function.
N     * |[1]     |CALDONE   |Calibration is Done 
N     * |        |          |1 = A/D converter self calibration is done. 
N     * |        |          |0 = A/D converter has not been calibrated or calibration is in progress if CALEN bit is set. 
N     * |        |          |When 0 is written to CALEN bit, CALDONE bit is cleared by hardware immediately. It is a read 
N     * |        |          |only bit.
N     */    
N    __IO uint32_t ADCALR;
X    volatile uint32_t ADCALR;
N    
N} ADC_T;
N
N
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17                                /*!< ADC ADDR: VALID Position */
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC ADDR: VALID Mask */
N
N#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC ADDR: OVERRUN Position */
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC ADDR: OVERRUN Mask */
N
N#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC ADDR: RSLT Position */
N#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC ADDR: RSLT Mask */
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC ADCR: DMOF Position */
N#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC ADCR: DMOF Mask */
N
N#define ADC_ADCR_ADST_Pos       11                                /*!< ADC ADCR: ADST Position */
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC ADCR: ADST Mask */
N
N#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC ADCR: DIFFEN Position */
N#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC ADCR: DIFFEN Mask */
N
N#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC ADCR: TRGEN Position */
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC ADCR: TRGEN Mask */
N
N#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC ADCR: TRGCOND Position */
N#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC ADCR: TRGCOND Mask */
N
N#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC ADCR: TRGS Position */
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC ADCR: TRGS Mask */
N
N#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC ADCR: ADMD Position */
N#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC ADCR: ADMD Mask */
N
N#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC ADCR: ADIE Position */
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC ADCR: ADIE Mask */
N
N#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC ADCR: ADEN Position */
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC ADCR: ADEN Mask */
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC ADCHER: PRESEL Position */
N#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC ADCHER: PRESEL Mask */
N
N#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC ADCHER: CHEN Position */
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC ADCHER: CHEN Mask */
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC ADCMPR: CMPD Position */
N#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC ADCMPR: CMPD Mask */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC ADCMPR: CMPMATCNT Position */
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC ADCMPR: CMPMATCNT Mask */
N
N#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC ADCMPR: CMPCH Position */
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC ADCMPR: CMPCH Mask */
N
N#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC ADCMPR: CMPCOND Position */
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC ADCMPR: CMPCOND Mask */
N
N#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC ADCMPR: CMPIE Position */
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC ADCMPR: CMPIE Mask */
N
N#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC ADCMPR: CMPEN Position */
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC ADCMPR: CMPEN Mask */
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC ADSR: OVERRUN Position */
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC ADSR: OVERRUN Mask */
N
N#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC ADSR: VALID Position */
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC ADSR: VALID Mask */
N
N#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC ADSR: CHANNEL Position */
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC ADSR: CHANNEL Mask */
N
N#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC ADSR: BUSY Position */
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC ADSR: BUSY Mask */
N
N#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC ADSR: CMPF1 Position */
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC ADSR: CMPF1 Mask */
N
N#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC ADSR: CMPF0 Position */
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC ADSR: CMPF0 Mask */
N
N#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC ADSR: ADF Position */
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC ADSR: ADF Mask */
N
N/* ADCALR Bit Field Definitions */
N#define ADC_ADCALR_CALDONE_Pos     1                                     /*!< ADC ADCALR: CALDONE Position */
N#define ADC_ADCALR_CALDONE_Msk     (1ul << ADC_ADCALR_CALDONE_Pos)       /*!< ADC ADCALR: CALDONE Mask */
N
N#define ADC_ADCALR_CALEN_Pos       0                                     /*!< ADC ADCALR: CALEN Position */
N#define ADC_ADCALR_CALEN_Msk       (1ul << ADC_ADCALR_CALEN_Pos)         /*!< ADC ADCALR: CALEN Mask */
N/*@}*/ /* end of group M051_ADC */
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/** @addtogroup M051_ACMP M051 ACMP
N  Memory Mapped Structure for M051 Series ACMP Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * CMPCR
N     * ===================================================================================================
N     * Offset: 0x00  ACMP Comparator Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N        __IO uint32_t CMPCR[2];
X        volatile uint32_t CMPCR[2];
N
N    /**
N     * CMPSR
N     * ===================================================================================================
N     * Offset: 0x08  ACMP Comparator Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N        __IO uint32_t CMPSR;
X        volatile uint32_t CMPSR;
N
N} ACMP_T;
N
N
N/* CMPCR Bit Field Definitions */
N#define ACMP_CMPCR_CMPCN_Pos       4                                   /*!< ACMP CMPCR: CMPCN Position */
N#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)       /*!< ACMP CMPCR: CMPCN Mask */
N
N#define ACMP_CMPCR_CMP_HYSEN_Pos   2                                   /*!< ACMP CMPCR: CMP_HYSEN Position */
N#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)   /*!< ACMP CMPCR: CMP_HYSEN Mask */
N
N#define ACMP_CMPCR_CMPIE_Pos       1                                   /*!< ACMP CMPCR: CMPIE Position */
N#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)       /*!< ACMP CMPCR: CMPIE Mask */
N
N#define ACMP_CMPCR_CMPEN_Pos       0                                   /*!< ACMP CMPCR: CMPEN Position */
N#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)       /*!< ACMP CMPCR: CMPEN Mask */
N
N/* CMPSR Bit Field Definitions */
N#define ACMP_CMPSR_CO1_Pos     3                                 /*!< ACMP CMPSR: CO1 Position */
N#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)       /*!< ACMP CMPSR: CO1 Mask */
N
N#define ACMP_CMPSR_CO0_Pos     2                                 /*!< ACMP CMPSR: CO0 Position */
N#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)       /*!< ACMP CMPSR: CO0 Mask */
N
N#define ACMP_CMPSR_CMPF1_Pos   1                                 /*!< ACMP CMPSR: CMPF1 Position */
N#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)     /*!< ACMP CMPSR: CMPF1 Mask */
N
N#define ACMP_CMPSR_CMPF0_Pos   0                                 /*!< ACMP CMPSR: CMPF0 Position */
N#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)     /*!< ACMP CMPSR: CMPF0 Mask */
N/*@}*/ /* end of group M051_ACMP */
N
N
N/*---------------------------- Clock Controller ------------------------------*/
N
N/** @addtogroup M051_SYSCLK M051 System Clock Controller
N  Memory Mapped Structure for M051 Series System Clock Controller
N  @{
N */
N                                                              
Ntypedef struct
N{
N    /**
N     * PWRCON
N     * ===================================================================================================
N     * Offset: 0x00  System Power Down Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field       |Descriptions
N     * | :----: | :----:     | :---- |
N     * |[0]     |XTL12M_EN   |External Crystal Oscillator Control
N     * |        |            |The bit default value is set by flash controller user configuration register config0 [26:24]. 
N     * |        |            |When the default clock source is from external crystal. The bit is auto set to "1"
N     * |        |            |1 = Crystal oscillation enable 
N     * |        |            |0 = Crystal oscillation disable 
N     * |[2]     |OSC22M_EN   |Internal 22.1184 MHz Oscillator Control
N     * |        |            |1 = 22.1184 MHz Oscillation enable 
N     * |        |            |0 = 22.1184 MHz Oscillation disable 
N     * |[3]     |OSC10K_EN   |Internal 10KHz Oscillator Control
N     * |        |            |1 = 10KHz Oscillation enable 
N     * |        |            |0 = 10KHz Oscillation disable 
N     * |[4]     |PD_WU_DLY   |Enable the wake up delay counter.
N     * |        |            |When the chip wakes up from power down mode, the clock control will delay certain clock 
N     * |        |            |cycles to wait system clock stable.
N     * |        |            |The delayed clock cycle is 4096 clock cycles when chip work at external crystal (4 ~ 
N     * |        |            |24MHz), and 256 clock cycles when chip work at 22.1184 MHz oscillator.
N     * |        |            |1 = Enable the clock cycle delay
N     * |        |            |0 = Disable the clock cycle delay
N     * |[5]     |PD_WU_INT_EN|Power down mode wake Up Interrupt Enable
N     * |        |            |0 = Disable
N     * |        |            |1 = Enable. The interrupt will occur when Power down mode (Deep Sleep Mode) wakeup.
N     * |[6]     |PD_WU_STS   |Chip power down wake up status flag
N     * |        |            |Set by "power down wake up", it indicates that resume from power down mode 
N     * |        |            |The flag is set if the GPIO(P0~P4), UART wakeup
N     * |        |            |Write 1 to clear the bit 
N     * |        |            |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1. 
N     * |[7]     |PWR_DOWN_EN |System power down enable bit
N     * |        |            |When set this bit "1", the chip power down mode is enabled and the chip power down active 
N     * |        |            |is depend on the PD_WAIT_CPU bit
N     * |        |            |(a) if the PD_WAIT_CPU is "0" then the chip power down after the PWR_DOWN_EN bit set.
N     * |        |            |(b) if the PD_WAIT_CPU is "1" then the chip keep active till the CPU sleep mode also active 
N     * |        |            |and then the chip power down
N     * |        |            |When chip wake up from power down, this bit is auto cleared, user need to set this bit again 
N     * |        |            |for next power down.
N     * |        |            |When in power down mode, external crystal (4~ 24MHz) and the 22.1184 MHz OSC will be 
N     * |        |            |disabled in this mode, but the 10 kHz OSC is not controlled by power down mode. 
N     * |        |            |When in power down mode, the PLL and system clock are disabled, and ignored the clock 
N     * |        |            |source selection. The clocks of peripheral are not controlled by power down mode, if the 
N     * |        |            |peripheral clock source is from 10 kHz oscillator.
N     * |        |            |1 = Chip enter the power down mode instant or wait CPU sleep command WFI
N     * |        |            |0 = Chip operate in normal mode or CPU in idle mode (sleep mode) because of WFI 
N     * |        |            |command
N     * |[8]     |PD_WAIT_CPU |This bit control the power down entry condition
N     * |        |            |1 = Chip entry power down mode when the both PWR_DOWN and CPU run WFI instruction.
N     * |        |            |0 = Chip entry power down mode when the PWR_DOWN bit is set to 1
N     */    
N    __IO uint32_t PWRCON;
X    volatile uint32_t PWRCON;
N
N    /**
N     * AHBCLK
N     * ===================================================================================================
N     * Offset: 0x04  AHB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control.
N     * |        |          |1 = To enable the Flash ISP controller clock.
N     * |        |          |0 = To disable the Flash ISP controller clock.
N     * |[3]     |EBI_EN    |EBI Controller Clock Enable Control.
N     * |        |          |1 = To enable the EBI Controller clock.
N     * |        |          |0 = To disable the EBI Controller clock.
N     */    
N    __IO uint32_t AHBCLK;
X    volatile uint32_t AHBCLK;
N
N    /**
N     * APBCLK
N     * ===================================================================================================
N     * Offset: 0x08  APB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDT_EN    |Watch Dog Timer Clock Enable.
N     * |        |          |This bit is the protected bit, program this need a open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address 
N     * |        |          |GCR_BA + 0x100
N     * |        |          |0 = Disable Watchdog Timer Clock
N     * |        |          |1 = Enable Watchdog Timer Clock
N     * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N     * |        |          |0 = Disable Timer0 Clock
N     * |        |          |1 = Enable Timer0 Clock
N     * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N     * |        |          |0 = Disable Timer1 Clock
N     * |        |          |1 = Enable Timer1 Clock
N     * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
N     * |        |          |0 = Disable Timer2 Clock
N     * |        |          |1 = Enable Timer2 Clock
N     * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
N     * |        |          |0 = Disable Timer3 Clock
N     * |        |          |1 = Enable Timer3 Clock
N     * |[6]     |FDIV_EN   |Clock Divider Clock Enable Control
N     * |        |          |0 = Disable FDIV Clock
N     * |        |          |1 = Enable FDIV Clock
N     * |[8]     |I2C_EN    |I2C Clock Enable Control. 
N     * |        |          |0 = Disable I2C Clock
N     * |        |          |1 = Enable I2C Clock
N     * |[12]    |SPI0_EN   |SPI0 Clock Enable Control. 
N     * |        |          |0 = Disable SPI0 Clock
N     * |        |          |1 = Enable SPI0 Clock
N     * |[13]    |SPI1_EN   |SPI1 Clock Enable Control. 
N     * |        |          |0 = Disable SPI1 Clock
N     * |        |          |1 = Enable SPI1 Clock
N     * |[16]    |UART0_EN  |UART0 Clock Enable Control.
N     * |        |          |1 = Enable UART0 clock
N     * |        |          |0 = Disable UART0 clock
N     * |[17]    |UART1_EN  |UART1 Clock Enable Control.
N     * |        |          |1 = Enable UART1 clock
N     * |        |          |0 = Disable UART1 clock
N     * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control.
N     * |        |          |1 = Enable PWM01 clock
N     * |        |          |0 = Disable PWM01 clock
N     * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control.
N     * |        |          |1 = Enable PWM23 clock
N     * |        |          |0 = Disable PWM23 clock
N     * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control.
N     * |        |          |1 = Enable PWM45 clock
N     * |        |          |0 = Disable PWM45 clock
N     * |[23]    |PWM67_EN  |PWM_67 Clock Enable Control.
N     * |        |          |1 = Enable PWM67 clock
N     * |        |          |0 = Disable PWM67 clock
N     * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control.
N     * |        |          |1 = Enable ADC clock
N     * |        |          |0 = Disable ADC clock
N     */    
N    __IO uint32_t APBCLK;
X    volatile uint32_t APBCLK;
N
N    /**
N     * CLKSTATUS
N     * ===================================================================================================
N     * Offset: 0x0C  Clock Status Monitor Register 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field      |Descriptions
N     * | :----: | :----:    | :---- |
N     * |[0]     |XTL12M_STB |XTL12M clock source stable flag
N     * |        |           |1 = External Crystal clock is stable
N     * |        |           |0 = External Crystal clock is not stable or not enable
N     * |[2]     |PLL_STB    |PLL clock source stable flag
N     * |        |           |1 = PLL clock is stable
N     * |        |           |0 = PLL clock is not stable or not enable
N     * |[3]     |OSC10K_STB |OSC10K clock source stable flag
N     * |        |           |1 = OSC10K clock is stable
N     * |        |           |0 = OSC10K clock is not stable or not enable
N     * |[4]     |OSC22M_STB |OSC22M clock source stable flag
N     * |        |           |1 = OSC22M clock is stable
N     * |        |           |0 = OSC22M clock is not stable or not enable
N     * |[7]     |CLK_SW_FAIL|Clock switch fail flag
N     * |        |           |1 = Clock switch fail
N     * |        |           |0 = Clock switch success
N     * |        |           |This bit will be set when target switch clock source is not stable. Write 1 to clear this bit to zero.
N     */    
N    __IO uint32_t CLKSTATUS;
X    volatile uint32_t CLKSTATUS;
N
N    /**
N     * CLKSEL0
N     * ===================================================================================================
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |HCLK_S    |HCLK clock source select.
N     * |        |          |Note:
N     * |        |          |1.	Before clock switch the related clock sources (pre-select and new-select) must be turn on
N     * |        |          |2.	The 3-bit default value is reloaded with the value of Config0.CFOSC[26:24] in user 
N     * |        |          |configuration register in Flash controller by any reset. Therefore the default value is either 
N     * |        |          |000b or 111b.
N     * |        |          |3.	These bits are protected bit, program this need an open lock sequence, write 
N     * |        |          |"59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register 
N     * |        |          |REGWRPROT at address GCR_BA + 0x100
N     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |010 = clock source from PLL clock
N     * |        |          |011 = clock source from internal 10KHz oscillator clock
N     * |        |          |111 = clock source from internal 22.1184 MHz oscillator clock
N     * |        |          |others = Reserved
N     * |[5:3]   |STCLK_S   |MCU Cortex_M0 SysTick clock source select.
N     * |        |          |These bits are protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
N     * |        |          |+ 0x100
N     * |        |          |000 = Clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |010 = Clock source from external crystal clock (4 ~ 24MHz)/2
N     * |        |          |011 = clock source from HCLK/2
N     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock/2
N     */    
N    __IO uint32_t CLKSEL0;
X    volatile uint32_t CLKSEL0;
N
N    /**
N     * CLKSEL1
N     * ===================================================================================================
N     * Offset: 0x14  Clock Source Select Control Register 1 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WDT_S     |Watchdog Timer clock source select.
N     * |        |          |These bits are protected bit, program this need a open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address 
N     * |        |          |GCR_BA + 0x100
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz).
N     * |        |          |10 = clock source from HCLK/2048 clock
N     * |        |          |11 = clock source from internal 10KHz oscillator clock
N     * |[3:2]   |ADC_S     |ADC clock source select.
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz).
N     * |        |          |01 = clock source from PLL clock
N     * |        |          |1x = clock source from internal 22.1184 MHz oscillator clock
N     * |[10:8]  |TMR0_S    |TIMER0 clock source select.
N     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external trigger
N     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
N     * |[14:12] |TMR1_S    |TIMER1 clock source select.
N     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external trigger
N     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
N     * |[18:16] |TMR2_S    |TIMER2 clock source select.
N     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external trigger
N     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
N     * |[22:20] |TMR3_S    |TIMER3 clock source select.
N     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external trigger
N     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
N     * |[25:24] |UART_S    |UART clock source select.
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |01 = clock source from PLL clock
N     * |        |          |1x = clock source from internal 22.1184 MHz oscillator clock
N     * |[29:28] |PWM01_S   |PWM0 and PWM1 clock source select.
N     * |        |          |PWM0 and PWM1 uses the same Engine clock source, both of them with the same pre-scalar
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
N     * |[31:30] |PWM23_S   |PWM2 and PWM3 clock source select.
N     * |        |          |PWM2 and PWM3 uses the same Engine clock source, both of them with the same pre-scalar
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
N     */    
N    __IO uint32_t CLKSEL1;
X    volatile uint32_t CLKSEL1;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x18  Clock Divider Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |HCLK_N    |HCLK clock divide number from HCLK clock source
N     * |        |          |The HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1)
N     * |[11:8]  |UART_N    |UART clock divide number from UART clock source
N     * |        |          |The UART clock frequency = (UART clock source frequency ) / (UART_N + 1)
N     * |[23:16] |ADC_N     |ADC clock divide number from ADC clock source
N     * |        |          |The ADC clock frequency = (ADC clock source frequency ) / (ADC_N + 1)
N     */    
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * CLKSEL2
N     * ===================================================================================================
N     * Offset: 0x1C  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Select
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
N     * |[5:4]   |PWM45_S   |PWM4 and PWM5 clock source select. - PWM4 and PWM5 used the same Engine clock source, 
N     * |        |          |both of them with the same pre-scalar
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
N     * |[7:6]   |PWM67_S   |PWM6 and PWM7 clock source select. - PWM6 and PWM7 used the same Engine clock source, 
N     * |        |          |both of them with the same pre-scalar
N     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
N     */    
N    __IO uint32_t CLKSEL2;
X    volatile uint32_t CLKSEL2;
N
N    /**
N     * PLLCON
N     * ===================================================================================================
N     * Offset: 0x20  PLL Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |FB_DV     |PLL Feedback Divider Control Pins (PLL_F[8:0])
N     * |[13:9]  |IN_DV     |PLL Input Divider Control Pins (PLL_R[4:0])
N     * |[15:14] |OUT_DV    |PLL Output Divider Control Pins (PLL_OD[1:0])
N     * |[16]    |PD        |Power Down Mode. 
N     * |        |          |If set the IDLE bit "1" in PWRCON register, the PLL will enter power down mode too
N     * |        |          |0 = PLL is in normal mode (default)
N     * |        |          |1 = PLL is in power-down mode
N     * |[17]    |BP        |PLL Bypass Control
N     * |        |          |0 = PLL is in normal mode (default)
N     * |        |          |1 = PLL clock output is same as clock input (XTALin)
N     * |[18]    |OE        |PLL OE (FOUT enable) pin Control
N     * |        |          |0 = PLL FOUT enable
N     * |        |          |1 = PLL FOUT is fixed low
N     * |[19]    |PLL_SRC   |PLL Source Clock Select
N     * |        |          |1 = PLL source clock from 22.1184 MHz oscillator
N     * |        |          |0 = PLL source clock from external crystal clock (4 ~ 24 MHz)
N     */    
N    __IO uint32_t PLLCON;
X    volatile uint32_t PLLCON;
N
N    /**
N     * FRQDIV
N     * ===================================================================================================
N     * Offset: 0x24  Frequency Divider Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
N     * |        |          |The formula of output frequency is
N     * |        |          |Fout = Fin/2(N+1), 
N     * |        |          |where Fin is the input clock frequency, Fout is the frequency of divider output clock, N is the 4-bit 
N     * |        |          |value of FSEL[3:0].
N     * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
N     * |        |          |0 = Disable Frequency Divider
N     * |        |          |1 = Enable Frequency Divider
N     */    
N    __IO uint32_t FRQDIV;
X    volatile uint32_t FRQDIV;
N
N} SYSCLK_T;
N
N/* SYSCLK PWRCON Bit Field Definitions */
N#define SYSCLK_PWRCON_PD_WAIT_CPU_Pos           8                                       /*!< SYSCLK PWRCON: PD_WAIT_CPU Position */
N#define SYSCLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << SYSCLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< SYSCLK PWRCON: PD_WAIT_CPU Mask */
N
N#define SYSCLK_PWRCON_PWR_DOWN_EN_Pos           7                                       /*!< SYSCLK PWRCON: PWR_DOWN_EN Position */
N#define SYSCLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << SYSCLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< SYSCLK PWRCON: PWR_DOWN_EN Mask */
N
N#define SYSCLK_PWRCON_PD_WU_STS_Pos             6                                       /*!< SYSCLK PWRCON: PD_WU_STS Position */
N#define SYSCLK_PWRCON_PD_WU_STS_Msk             (1ul << SYSCLK_PWRCON_PD_WU_STS_Pos)    /*!< SYSCLK PWRCON: PD_WU_STS Mask */
N
N#define SYSCLK_PWRCON_PD_WU_INT_EN_Pos          5                                       /*!< SYSCLK PWRCON: PD_WU_INT_EN Position */
N#define SYSCLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << SYSCLK_PWRCON_PD_WU_INT_EN_Pos) /*!< SYSCLK PWRCON: PD_WU_INT_EN Mask */
N
N#define SYSCLK_PWRCON_PD_WU_DLY_Pos             4                                       /*!< SYSCLK PWRCON: PD_WU_DLY Position */
N#define SYSCLK_PWRCON_PD_WU_DLY_Msk             (1ul << SYSCLK_PWRCON_PD_WU_DLY_Pos)    /*!< SYSCLK PWRCON: PD_WU_DLY Mask */
N
N#define SYSCLK_PWRCON_OSC10K_EN_Pos             3                                       /*!< SYSCLK PWRCON: OSC10K_EN Position */
N#define SYSCLK_PWRCON_OSC10K_EN_Msk             (1ul << SYSCLK_PWRCON_OSC10K_EN_Pos)    /*!< SYSCLK PWRCON: OSC10K_EN Mask */
N#define SYSCLK_PWRCON_IRC10K_EN_Pos             3                                       /*!< SYSCLK PWRCON: OSC10K_EN Position */
N#define SYSCLK_PWRCON_IRC10K_EN_Msk             (1ul << SYSCLK_PWRCON_OSC10K_EN_Pos)    /*!< SYSCLK PWRCON: OSC10K_EN Mask */
N
N#define SYSCLK_PWRCON_OSC22M_EN_Pos             2                                       /*!< SYSCLK PWRCON: OSC22M_EN Position */
N#define SYSCLK_PWRCON_OSC22M_EN_Msk             (1ul << SYSCLK_PWRCON_OSC22M_EN_Pos)    /*!< SYSCLK PWRCON: OSC22M_EN Mask */
N#define SYSCLK_PWRCON_IRC22M_EN_Pos             2                                       /*!< SYSCLK PWRCON: OSC22M_EN Position */
N#define SYSCLK_PWRCON_IRC22M_EN_Msk             (1ul << SYSCLK_PWRCON_OSC22M_EN_Pos)    /*!< SYSCLK PWRCON: OSC22M_EN Mask */
N
N#define SYSCLK_PWRCON_XTL12M_EN_Pos             0                                       /*!< SYSCLK PWRCON: XTL12M_EN Position */
N#define SYSCLK_PWRCON_XTL12M_EN_Msk             (1ul << SYSCLK_PWRCON_XTL12M_EN_Pos)    /*!< SYSCLK PWRCON: XTL12M_EN Mask */
N
N/* SYSCLK AHBCLK Bit Field Definitions */
N#define SYSCLK_AHBCLK_EBI_EN_Pos                3                                       /*!< SYSCLK AHBCLK: EBI_EN Position */
N#define SYSCLK_AHBCLK_EBI_EN_Msk                (1ul << SYSCLK_AHBCLK_EBI_EN_Pos)       /*!< SYSCLK AHBCLK: EBI_EN Mask */
N
N#define SYSCLK_AHBCLK_ISP_EN_Pos                2                                       /*!< SYSCLK AHBCLK: ISP_EN Position */
N#define SYSCLK_AHBCLK_ISP_EN_Msk                (1ul << SYSCLK_AHBCLK_ISP_EN_Pos)       /*!< SYSCLK AHBCLK: ISP_EN Mask */
N
N/* SYSCLK APBCLK Bit Field Definitions */
N#define SYSCLK_APBCLK_ACMP1_EN_Pos              31                                      /*!< SYSCLK APBCLK: ACMP1_EN Position */
N#define SYSCLK_APBCLK_ACMP1_EN_Msk              (1ul << SYSCLK_APBCLK_ACMP1_EN_Pos)     /*!< SYSCLK APBCLK: ACMP1_EN Mask */
N
N#define SYSCLK_APBCLK_ACMP0_EN_Pos              30                                      /*!< SYSCLK APBCLK: ACMP0_EN Position */
N#define SYSCLK_APBCLK_ACMP0_EN_Msk              (1ul << SYSCLK_APBCLK_ACMP0_EN_Pos)     /*!< SYSCLK APBCLK: ACMP0_EN Mask */
N#define SYSCLK_APBCLK_ACMP_EN_Pos               30                                      /*!< SYSCLK APBCLK: ACMP_EN Position */
N#define SYSCLK_APBCLK_ACMP_EN_Msk               (1ul << SYSCLK_APBCLK_ACMP_EN_Pos)      /*!< SYSCLK APBCLK: ACMP_EN Mask */
N
N#define SYSCLK_APBCLK_ADC_EN_Pos                28                                      /*!< SYSCLK APBCLK: ADC_EN Position */
N#define SYSCLK_APBCLK_ADC_EN_Msk                (1ul << SYSCLK_APBCLK_ADC_EN_Pos)       /*!< SYSCLK APBCLK: ADC_EN Mask */
N
N#define SYSCLK_APBCLK_PWM67_EN_Pos              23                                      /*!< SYSCLK APBCLK: PWM67_EN Position */
N#define SYSCLK_APBCLK_PWM67_EN_Msk              (1ul << SYSCLK_APBCLK_PWM67_EN_Pos)     /*!< SYSCLK APBCLK: PWM67_EN Mask */
N
N#define SYSCLK_APBCLK_PWM45_EN_Pos              22                                      /*!< SYSCLK APBCLK: PWM45_EN Position */
N#define SYSCLK_APBCLK_PWM45_EN_Msk              (1ul << SYSCLK_APBCLK_PWM45_EN_Pos)     /*!< SYSCLK APBCLK: PWM45_EN Mask */
N
N#define SYSCLK_APBCLK_PWM23_EN_Pos              21                                      /*!< SYSCLK APBCLK: PWM23_EN Position */
N#define SYSCLK_APBCLK_PWM23_EN_Msk              (1ul << SYSCLK_APBCLK_PWM23_EN_Pos)     /*!< SYSCLK APBCLK: PWM23_EN Mask */
N
N#define SYSCLK_APBCLK_PWM01_EN_Pos              20                                      /*!< SYSCLK APBCLK: PWM01_EN Position */
N#define SYSCLK_APBCLK_PWM01_EN_Msk              (1ul << SYSCLK_APBCLK_PWM01_EN_Pos)     /*!< SYSCLK APBCLK: PWM01_EN Mask */
N
N#define SYSCLK_APBCLK_UART1_EN_Pos              17                                      /*!< SYSCLK APBCLK: UART1_EN Position */
N#define SYSCLK_APBCLK_UART1_EN_Msk              (1ul << SYSCLK_APBCLK_UART1_EN_Pos)     /*!< SYSCLK APBCLK: UART1_EN Mask */
N
N#define SYSCLK_APBCLK_UART0_EN_Pos              16                                      /*!< SYSCLK APBCLK: UART0_EN Position */
N#define SYSCLK_APBCLK_UART0_EN_Msk              (1ul << SYSCLK_APBCLK_UART0_EN_Pos)     /*!< SYSCLK APBCLK: UART0_EN Mask */
N
N#define SYSCLK_APBCLK_SPI1_EN_Pos               13                                      /*!< SYSCLK APBCLK: SPI1_EN Position */
N#define SYSCLK_APBCLK_SPI1_EN_Msk               (1ul << SYSCLK_APBCLK_SPI1_EN_Pos)      /*!< SYSCLK APBCLK: SPI1_EN Mask */
N
N#define SYSCLK_APBCLK_SPI0_EN_Pos               12                                      /*!< SYSCLK APBCLK: SPI0_EN Position */
N#define SYSCLK_APBCLK_SPI0_EN_Msk               (1ul << SYSCLK_APBCLK_SPI0_EN_Pos)      /*!< SYSCLK APBCLK: SPI0_EN Mask */
N
N#define SYSCLK_APBCLK_I2C1_EN_Pos               9                                       /*!< SYSCLK APBCLK: I2C1_EN Position */
N#define SYSCLK_APBCLK_I2C1_EN_Msk               (1ul << SYSCLK_APBCLK_I2C0_EN_Pos)      /*!< SYSCLK APBCLK: I2C1_EN Mask */
N
N#define SYSCLK_APBCLK_I2C0_EN_Pos               8                                       /*!< SYSCLK APBCLK: I2C0_EN Position */
N#define SYSCLK_APBCLK_I2C0_EN_Msk               (1ul << SYSCLK_APBCLK_I2C0_EN_Pos)      /*!< SYSCLK APBCLK: I2C0_EN Mask */
N#define SYSCLK_APBCLK_I2C_EN_Pos                8                                       /*!< SYSCLK APBCLK: I2C_EN Position */
N#define SYSCLK_APBCLK_I2C_EN_Msk                (1ul << SYSCLK_APBCLK_I2C_EN_Pos)       /*!< SYSCLK APBCLK: I2C_EN Mask */
N
N#define SYSCLK_APBCLK_FDIV_EN_Pos               6                                       /*!< SYSCLK APBCLK: FDIV_EN Position */
N#define SYSCLK_APBCLK_FDIV_EN_Msk               (1ul << SYSCLK_APBCLK_FDIV_EN_Pos)      /*!< SYSCLK APBCLK: FDIV_EN Mask */
N
N#define SYSCLK_APBCLK_TMR3_EN_Pos               5                                       /*!< SYSCLK APBCLK: TMR3_EN Position */
N#define SYSCLK_APBCLK_TMR3_EN_Msk               (1ul << SYSCLK_APBCLK_TMR3_EN_Pos)      /*!< SYSCLK APBCLK: TMR3_EN Mask */
N
N#define SYSCLK_APBCLK_TMR2_EN_Pos               4                                       /*!< SYSCLK APBCLK: TMR2_EN Position */
N#define SYSCLK_APBCLK_TMR2_EN_Msk               (1ul << SYSCLK_APBCLK_TMR2_EN_Pos)      /*!< SYSCLK APBCLK: TMR2_EN Mask */
N
N#define SYSCLK_APBCLK_TMR1_EN_Pos               3                                       /*!< SYSCLK APBCLK: TMR1_EN Position */
N#define SYSCLK_APBCLK_TMR1_EN_Msk               (1ul << SYSCLK_APBCLK_TMR1_EN_Pos)      /*!< SYSCLK APBCLK: TMR1_EN Mask */
N                                                
N#define SYSCLK_APBCLK_TMR0_EN_Pos               2                                       /*!< SYSCLK APBCLK: TMR0_EN Position */
N#define SYSCLK_APBCLK_TMR0_EN_Msk               (1ul << SYSCLK_APBCLK_TMR0_EN_Pos)      /*!< SYSCLK APBCLK: TMR0_EN Mask */
N
N#define SYSCLK_APBCLK_WDT_EN_Pos                0                                       /*!< SYSCLK APBCLK: WDT_EN Position */
N#define SYSCLK_APBCLK_WDT_EN_Msk                (1ul << SYSCLK_APBCLK_WDT_EN_Pos)       /*!< SYSCLK APBCLK: WDT_EN Mask */
N
N/* SYSCLK CLKSTATUS Bit Field Definitions */
N#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                           /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Position */
N#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Mask */
N
N#define SYSCLK_CLKSTATUS_OSC22M_STB_Pos         4                                       /*!< SYSCLK CLKSTATUS: OSC22M_STB Position */
N#define SYSCLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC22M_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC22M_STB Mask */
N#define SYSCLK_CLKSTATUS_IRC22M_STB_Pos         4                                       /*!< SYSCLK CLKSTATUS: OSC22M_STB Position */
N#define SYSCLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC22M_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC22M_STB Mask */
N
N#define SYSCLK_CLKSTATUS_OSC10K_STB_Pos         3                                       /*!< SYSCLK CLKSTATUS: OSC10K_STB Position */
N#define SYSCLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC10K_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC10K_STB Mask */
N#define SYSCLK_CLKSTATUS_IRC10K_STB_Pos         3                                       /*!< SYSCLK CLKSTATUS: OSC10K_STB Position */
N#define SYSCLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC10K_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC10K_STB Mask */
N
N#define SYSCLK_CLKSTATUS_PLL_STB_Pos            2                                       /*!< SYSCLK CLKSTATUS: PLL_STB Position */
N#define SYSCLK_CLKSTATUS_PLL_STB_Msk            (1ul << SYSCLK_CLKSTATUS_PLL_STB_Pos)   /*!< SYSCLK CLKSTATUS: PLL_STB Mask */
N
N#define SYSCLK_CLKSTATUS_XTL12M_STB_Pos         0                                       /*!< SYSCLK CLKSTATUS: XTL12M_STB Position */
N#define SYSCLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL12M_STB_Pos)/*!< SYSCLK CLKSTATUS: XTL12M_STB Mask */
N
N/* SYSCLK CLKSEL0 Bit Field Definitions */
N#define SYSCLK_CLKSEL0_STCLK_S_Pos              3                                       /*!< SYSCLK CLKSEL0: STCLK_S Position */
N#define SYSCLK_CLKSEL0_STCLK_S_Msk              (7ul << SYSCLK_CLKSEL0_STCLK_S_Pos)     /*!< SYSCLK CLKSEL0: STCLK_S Mask */
N
N#define SYSCLK_CLKSEL0_HCLK_S_Pos               0                                       /*!< SYSCLK CLKSEL0: HCLK_S Position */
N#define SYSCLK_CLKSEL0_HCLK_S_Msk               (7ul << SYSCLK_CLKSEL0_HCLK_S_Pos)      /*!< SYSCLK CLKSEL0: HCLK_S Mask */
N
N/* SYSCLK CLKSEL1 Bit Field Definitions */
N#define SYSCLK_CLKSEL1_PWM23_S_Pos              30                                      /*!< SYSCLK CLKSEL1: PWM23_S Position */
N#define SYSCLK_CLKSEL1_PWM23_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM23_S_Pos)     /*!< SYSCLK CLKSEL1: PWM23_S Mask */
N
N#define SYSCLK_CLKSEL1_PWM01_S_Pos              28                                      /*!< SYSCLK CLKSEL1: PWM01_S Position */
N#define SYSCLK_CLKSEL1_PWM01_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM01_S_Pos)     /*!< SYSCLK CLKSEL1: PWM01_S Mask */
N
N#define SYSCLK_CLKSEL1_UART_S_Pos               24                                      /*!< SYSCLK CLKSEL1: UART_S Position */
N#define SYSCLK_CLKSEL1_UART_S_Msk               (3ul << SYSCLK_CLKSEL1_UART_S_Pos)      /*!< SYSCLK CLKSEL1: UART_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR3_S_Pos               20                                      /*!< SYSCLK CLKSEL1: TMR3_S Position */
N#define SYSCLK_CLKSEL1_TMR3_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR3_S_Pos)      /*!< SYSCLK CLKSEL1: TMR3_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR2_S_Pos               16                                      /*!< SYSCLK CLKSEL1: TMR2_S Position */
N#define SYSCLK_CLKSEL1_TMR2_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR2_S_Pos)      /*!< SYSCLK CLKSEL1: TMR2_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR1_S_Pos               12                                      /*!< SYSCLK CLKSEL1: TMR1_S Position */
N#define SYSCLK_CLKSEL1_TMR1_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR1_S_Pos)      /*!< SYSCLK CLKSEL1: TMR1_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR0_S_Pos               8                                       /*!< SYSCLK CLKSEL1: TMR0_S Position */
N#define SYSCLK_CLKSEL1_TMR0_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR0_S_Pos)      /*!< SYSCLK CLKSEL1: TMR0_S Mask */
N
N#define SYSCLK_CLKSEL1_SPI1_S_Pos               5                                       /*!< SYSCLK CLKSEL1: SPI1_S Position */
N#define SYSCLK_CLKSEL1_SPI1_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI1_S_Pos)      /*!< SYSCLK CLKSEL1: SPI1_S Mask */
N
N#define SYSCLK_CLKSEL1_SPI0_S_Pos               4                                       /*!< SYSCLK CLKSEL1: SPI0_S Position */
N#define SYSCLK_CLKSEL1_SPI0_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI0_S_Pos)      /*!< SYSCLK CLKSEL1: SPI0_S Mask */
N
N#define SYSCLK_CLKSEL1_ADC_S_Pos                2                                       /*!< SYSCLK CLKSEL1: ADC_S Position */
N#define SYSCLK_CLKSEL1_ADC_S_Msk                (3ul << SYSCLK_CLKSEL1_ADC_S_Pos)       /*!< SYSCLK CLKSEL1: ADC_S Mask */
N
N#define SYSCLK_CLKSEL1_WDT_S_Pos                0                                       /*!< SYSCLK CLKSEL1: WDT_S Position */
N#define SYSCLK_CLKSEL1_WDT_S_Msk                (3ul << SYSCLK_CLKSEL1_WDT_S_Pos)       /*!< SYSCLK CLKSEL1: WDT_S Mask */
N
N/* SYSCLK CLKSEL2 Bit Field Definitions */
N#define SYSCLK_CLKSEL2_WWDT_S_Pos               16                                      /*!< SYSCLK CLKSEL2: WWDT_S Position */
N#define SYSCLK_CLKSEL2_WWDT_S_Msk               (3ul << SYSCLK_CLKSEL2_WWDT_S_Pos)      /*!< SYSCLK CLKSEL2: WWDT_S Mask */
N
N#define SYSCLK_CLKSEL2_PWM67_S_Pos              6                                       /*!< SYSCLK CLKSEL2: PWM67_S Position */
N#define SYSCLK_CLKSEL2_PWM67_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM67_S_Pos)     /*!< SYSCLK CLKSEL2: PWM67_S Mask */
N
N#define SYSCLK_CLKSEL2_PWM45_S_Pos              4                                       /*!< SYSCLK CLKSEL2: PWM45_S Position */
N#define SYSCLK_CLKSEL2_PWM45_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM45_S_Pos)     /*!< SYSCLK CLKSEL2: PWM45_S Mask */
N
N#define SYSCLK_CLKSEL2_FRQDIV_S_Pos             2                                       /*!< SYSCLK CLKSEL2: FRQDIV_S Position */
N#define SYSCLK_CLKSEL2_FRQDIV_S_Msk             (3ul << SYSCLK_CLKSEL2_FRQDIV_S_Pos)    /*!< SYSCLK CLKSEL2: FRQDIV_S Mask */
N
N/* SYSCLK CLKDIV Bit Field Definitions */
N#define SYSCLK_CLKDIV_ADC_N_Pos                 16                                      /*!< SYSCLK CLKDIV: ADC_N Position */
N#define SYSCLK_CLKDIV_ADC_N_Msk                 (0xFFul << SYSCLK_CLKDIV_ADC_N_Pos)     /*!< SYSCLK CLKDIV: ADC_N Mask */
N
N#define SYSCLK_CLKDIV_UART_N_Pos                8                                       /*!< SYSCLK CLKDIV: UART_N Position */
N#define SYSCLK_CLKDIV_UART_N_Msk                (0xFul << SYSCLK_CLKDIV_UART_N_Pos)     /*!< SYSCLK CLKDIV: UART_N Mask */
N
N#define SYSCLK_CLKDIV_HCLK_N_Pos                0                                       /*!< SYSCLK CLKDIV: HCLK_N Position */
N#define SYSCLK_CLKDIV_HCLK_N_Msk                (0xFul << SYSCLK_CLKDIV_HCLK_N_Pos)     /*!< SYSCLK CLKDIV: HCLK_N Mask */
N
N/* SYSCLK PLLCON Bit Field Definitions */
N#define SYSCLK_PLLCON_PLL_SRC_Pos               19                                      /*!< SYSCLK PLLCON: PLL_SRC Position */
N#define SYSCLK_PLLCON_PLL_SRC_Msk               (1ul << SYSCLK_PLLCON_PLL_SRC_Pos)      /*!< SYSCLK PLLCON: PLL_SRC Mask */
N
N#define SYSCLK_PLLCON_OE_Pos                    18                                      /*!< SYSCLK PLLCON: OE Position */
N#define SYSCLK_PLLCON_OE_Msk                    (1ul << SYSCLK_PLLCON_OE_Pos)           /*!< SYSCLK PLLCON: OE Mask */
N
N#define SYSCLK_PLLCON_BP_Pos                    17                                      /*!< SYSCLK PLLCON: BP Position */
N#define SYSCLK_PLLCON_BP_Msk                    (1ul << SYSCLK_PLLCON_BP_Pos)           /*!< SYSCLK PLLCON: BP Mask */
N
N#define SYSCLK_PLLCON_PD_Pos                    16                                      /*!< SYSCLK PLLCON: PD Position */
N#define SYSCLK_PLLCON_PD_Msk                    (1ul << SYSCLK_PLLCON_PD_Pos)           /*!< SYSCLK PLLCON: PD Mask */
N
N#define SYSCLK_PLLCON_OUT_DV_Pos                14                                      /*!< SYSCLK PLLCON: OUT_DV Position */
N#define SYSCLK_PLLCON_OUT_DV_Msk                (3ul << SYSCLK_PLLCON_OUT_DV_Pos)       /*!< SYSCLK PLLCON: OUT_DV Mask */
N
N#define SYSCLK_PLLCON_IN_DV_Pos                 9                                       /*!< SYSCLK PLLCON: IN_DV Position */
N#define SYSCLK_PLLCON_IN_DV_Msk                 (0x1Ful << SYSCLK_PLLCON_IN_DV_Pos)     /*!< SYSCLK PLLCON: IN_DV Mask */
N
N#define SYSCLK_PLLCON_FB_DV_Pos                 0                                       /*!< SYSCLK PLLCON: FB_DV Position */
N#define SYSCLK_PLLCON_FB_DV_Msk                 (0x1FFul << SYSCLK_PLLCON_FB_DV_Pos)    /*!< SYSCLK PLLCON: FB_DV Mask */
N
N/* SYSCLK FRQDIV Bit Field Definitions */
N#define SYSCLK_FRQDIV_DIVIDER_EN_Pos            4                                       /*!< SYSCLK FRQDIV: DIVIDER_EN Position */
N#define SYSCLK_FRQDIV_DIVIDER_EN_Msk            (1ul << SYSCLK_FRQDIV_DIVIDER_EN_Pos)   /*!< SYSCLK FRQDIV: DIVIDER_EN Mask */
N
N#define SYSCLK_FRQDIV_FSEL_Pos                  0                                       /*!< SYSCLK FRQDIV: FSEL Position */
N#define SYSCLK_FRQDIV_FSEL_Msk                  (0xFul << SYSCLK_FRQDIV_FSEL_Pos)       /*!< SYSCLK FRQDIV: FSEL Mask */
N/*@}*/ /* end of group M051_SYSCLK */
N
N/*---------------------------- Global Controller -----------------------------*/
N
N/** @addtogroup M051_GCR M051 GCR
N  Memory Mapped Structure for M051 Series System Global Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * PDID
N     * ===================================================================================================
N     * Offset: 0x00  Part Device Identification Number Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDID      |This register reflects device part number code. S/W can read this register to identify which device is 
N     * |        |          |used.
N     */
N    __I  uint32_t PDID;                 
X    volatile const  uint32_t PDID;                 
N    
N    /**
N     * RSTSRC
N     * ===================================================================================================
N     * Offset: 0x04  System Reset Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:8]  |Reserved  |Reserved
N     * |[7]     |RSTS_CPU  |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).
N     * |        |          |1 = The Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST to 1.
N     * |        |          |0 = No reset from CPU
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[6]     |Reserved  |Reserved
N     * |[5]     |RSTS_MCU  |The RSTS_MCU flag is set by the "reset signal" from the MCU Cortex_M0 kernel to indicate the previous reset source.
N     * |        |          |1= The MCU Cortex_M0 had issued the reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.
N     * |        |          |0= No reset from MCU
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[4]     |RSTS_BOD  |The RSTS_BOD flag is set by the "reset signal" from the Brown-Out Detector to indicate the previous reset source.
N     * |        |          |1= The Brown-Out Detector module had issued the reset signal to reset the system.
N     * |        |          |0= No reset from BOD
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[3]     |RSTS_LVR  |The RSTS_LVR flag is set by the "reset signal" from the Low-Voltage-Reset controller to indicate the previous reset source.
N     * |        |          |1= The LVR module had issued the reset signal to reset the system.
N     * |        |          |0= No reset from LVR
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[2]     |RSTS_WDT  |The RSTS_WDT flag is set by the "reset signal" from the Watchdog timer to indicate the previous reset source.
N     * |        |          |1= The Watchdog timer had issued the reset signal to reset the system.
N     * |        |          |0= No reset from Watchdog timer
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[1]     |RSTS_RESET|The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.
N     * |        |          |1= The Pin /RESET had issued the reset signal to reset the system.
N     * |        |          |0= No reset from Pin /RESET
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[0]     |RSTS_POR  |The RSTS_POR flag is set by the "reset signal", which is from the Power-On Reset (POR) module or bit CHIP_RST (IPRSTC1[0]) is set, to indicate the previous reset source.
N     * |        |          |1= The Power-On-Reset (POR) or CHIP_RST had issued the reset signal to reset the system.
N     * |        |          |0= No reset from POR or CHIP_RST
N     * |        |          |Software can write 1 to clear this bit to zero.
N     */    
N    __IO uint32_t RSTSRC;
X    volatile uint32_t RSTSRC;
N
N    /**
N     * IPRSTC1
N     * ===================================================================================================
N     * Offset: 0x08  Peripheral Reset Control Resister 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIP_RST  |CHIP one shot reset.
N     * |        |          |Set this bit will reset the CHIP, including CPU kernel and all peripherals, and this bit will 
N     * |        |          |automatically return to "0" after the 2 clock cycles.
N     * |        |          |The CHIP_RST is same as the POR reset , all the chip module is reset and the chip setting from 
N     * |        |          |flash are also reload
N     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
N     * |        |          |+ 0x100
N     * |        |          |0= Normal
N     * |        |          |1= Reset CHIP
N     * |[1]     |CPU_RST   |CPU kernel one shot reset.
N     * |        |          |Set this bit will reset the Cortex-M0 CPU kernel and Flash memory controller (FMC). This bit will 
N     * |        |          |automatically return to "0" after the 2 clock cycles
N     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
N     * |        |          |+ 0x100
N     * |        |          |0= Normal
N     * |        |          |1= Reset CPU
N     * |[3]     |EBI_RST   |EBI Controller Reset
N     * |        |          |Set these bit "1" will generate a reset signal to the EBI. User need to set this bit to "0" to release 
N     * |        |          |from the reset state
N     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
N     * |        |          |+ 0x100
N     * |        |          |0= Normal operation
N     * |        |          |1= EBI IP reset
N     */    
N    __IO uint32_t IPRSTC1;
X    volatile uint32_t IPRSTC1;
N
N    /**
N     * IPRSTC2
N     * ===================================================================================================
N     * Offset: 0x0C  Peripheral Reset Control Resister 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |GPIO_RST  |GPIO (P0~P4) controller Reset
N     * |        |          |0= GPIO controller normal operation
N     * |        |          |1= GPIO controller reset
N     * |[2]     |TMR0_RST  |Timer0 controller Reset
N     * |        |          |0= Timer0 controller normal operation
N     * |        |          |1= Timer0 controller reset
N     * |[3]     |TMR1_RST  |Timer1 controller Reset
N     * |        |          |0= Timer1 controller normal operation
N     * |        |          |1= Timer1 controller reset
N     * |[4]     |TMR2_RST  |Timer2 controller Reset
N     * |        |          |0= Timer2 controller normal operation
N     * |        |          |1= Timer2 controller reset
N     * |[5]     |TMR3_RST  |Timer3 controller Reset
N     * |        |          |0= Timer3 controller normal operation
N     * |        |          |1= Timer3 controller reset
N     * |[8]     |I2C_RST   |I2C controller Reset
N     * |        |          |0= I2C controller normal operation
N     * |        |          |1= I2C controller reset
N     * |[12]    |SPI0_RST  |SPI0 controller Reset
N     * |        |          |0= SPI0 controller normal operation
N     * |        |          |1= SPI0 controller reset
N     * |[13]    |SPI1_RST  |SPI1 controller Reset
N     * |        |          |0= SPI1 controller normal operation
N     * |        |          |1= SPI1 controller reset
N     * |[16]    |UART0_RST |UART0 controller Reset
N     * |        |          |0= UART0 controller Normal operation
N     * |        |          |1= UART0 controller reset
N     * |[17]    |UART1_RST |UART1 controller Reset
N     * |        |          |0 = UART1 controller normal operation
N     * |        |          |1 = UART1 controller reset
N     * |[20]    |PWM03_RST |PWM0~3 controller Reset
N     * |        |          |0= PWM0~3 controller normal operation
N     * |        |          |1= PWM0~3 controller reset
N     * |[21]    |PWM47_RST |PWM4~7 controller Reset
N     * |        |          |0= PWM4~7 controller normal operation
N     * |        |          |1= PWM4~7 controller reset
N     * |[28]    |ADC_RST   |ADC Controller Reset
N     * |        |          |0= ADC controller normal operation
N     * |        |          |1= ADC controller reset
N     */    
N    __IO uint32_t IPRSTC2;
X    volatile uint32_t IPRSTC2;
N
N    /**
N     * RESERVED0
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    uint32_t RESERVED0[2];
N
N    /**
N     * BODCR
N     * ===================================================================================================
N     * Offset: 0x18  Brown-Out Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BOD_EN    |Brown Out Detector Enable (initiated & write-protected bit)
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[23]
N     * |        |          |1= Brown Out Detector function is enabled
N     * |        |          |0= Brown Out Detector function is disabled
N     * |[2:1]   |BOD_VL    |Brown Out Detector Threshold Voltage Selection (initiated & write-protected bit)
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[22:21]
N     * |        |          |BOV_VL[1]
N     * |        |          |BOV_VL[0]
N     * |        |          |Brown out voltage
N     * |        |          |11 = 4.5V
N     * |        |          |10 = 3.8V
N     * |        |          |01 = 2.7V
N     * |        |          |00 = 2.2V
N     * |[3]     |BOD_RSTEN |Brown Out Reset Enable (initiated & write-protected bit)
N     * |        |          |1= Enable the Brown Out "RESET" function, when the Brown Out Detector function is enable 
N     * |        |          |and the detected voltage is lower than the threshold then assert a signal to reset the chip
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[20]
N     * |        |          |0= Enable the Brown Out "INTERRUPT" function, when the Brown Out Detector function is 
N     * |        |          |enable and the detected voltage is lower than the threshold then assert a signal to interrupt 
N     * |        |          |the MCU Cortex-M0
N     * |        |          |When the BOD_EN is enabled and the interrupt is assert, the interrupt will keep till to the 
N     * |        |          |BOD_EN set to "0". The interrupt for CPU can be blocked by disable the NVIC in CPU for BOD 
N     * |        |          |interrupt or disable the interrupt source by disable the BOD_EN and then re-enable the BOD_EN 
N     * |        |          |function if the BOD function is required
N     * |[4]     |BOD_INTF  |Brown Out Detector Interrupt Flag
N     * |        |          |1= When Brown Out Detector detects the VDD is dropped through the voltage of BOD_VL setting 
N     * |        |          |or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to "1" and the 
N     * |        |          |brown out interrupt is requested if brown out interrupt is enabled.
N     * |        |          |0= Brown Out Detector does not detect any voltage draft at VDD down through or up through the 
N     * |        |          |voltage of BOD_VL setting.
N     * |[5]     |BOD_LPM   |Brown Out Detector Low power Mode (write-protected bit)
N     * |        |          |1= Enable the BOD low power mode
N     * |        |          |0= BOD operate in normal mode (default)
N     * |        |          |The BOD consumes about 100uA in normal mode, the low power mode can reduce the current 
N     * |        |          |to about 1/10 but slow the BOD response.
N     * |[6]     |BOD_OUT   |The status for Brown Out Detector output state
N     * |        |          |1= Brown Out Detector status output is 1, the detected voltage is lower than BOD_VL setting. If 
N     * |        |          |the BOD_EN is "0"(disabled), this bit always response "0"
N     * |        |          |0= Brown Out Detector status output is 0, the detected voltage is higher than BOD_VL setting
N     * |[7]     |LVR_EN    |Low Voltage Reset Enable (write-protected bit)
N     * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting. 
N     * |        |          |LVR function is enabled in default.
N     * |        |          |1= Enabled Low Voltage Reset function - After enable the bit, the LVR function will active with 
N     * |        |          |100uS delay for LVR output stable.(default).
N     * |        |          |0= Disabled Low Voltage Reset function
N     */    
N    __IO uint32_t BODCR;
X    volatile uint32_t BODCR;
N
N    /**
N     * TEMPCR
N     * ===================================================================================================
N     * Offset: 0x1C  Temperature Sensor Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TEMPCR;
X    volatile uint32_t TEMPCR;
N
N    /**
N     * RESERVED1
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    uint32_t RESERVED1;
N
N    /**
N     * PORCR
N     * ===================================================================================================
N     * Offset: 0x24  Power-On-Reset Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field       |Descriptions
N     * | :----: | :----:     | :---- |
N     * |[15:0]  |POR_DIS_CODE|The register is used for the Power-On-Reset enable control. 
N     * |        |            |When power on, the POR circuit generates a reset signal to reset the whole chip function, 
N     * |        |            |but noise on the power may cause the POR active again. If set the POR_DIS_CODE equal 
N     * |        |            |to 0x5AA5, the POR reset function will be disabled and the POR function will re-active till 
N     * |        |            |the power voltage is lower to set the POR_DIS_CODE to another value or reset by chip 
N     * |        |            |other reset function. Include:
N     * |        |            |PIN reset, Watch dog, LVR reset BOD reset, ICE reset command and the software-chip 
N     * |        |            |reset function
N     * |        |            |This register is the protected register, program this need an open lock sequence, write 
N     * |        |            |"59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register 
N     * |        |            |REGWRPROT at address GCR_BA + 0x100
N     */    
N    __IO uint32_t PORCR;
X    volatile uint32_t PORCR;
N
N    /**
N     * RESERVED2
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    uint32_t RESERVED2[2];
N
N    /**
N     * P0_MFP
N     * ===================================================================================================
N     * Offset: 0x30  P0 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P0_MFP    |P0 multiple function Selection
N     * |        |          |The pin function of P0 is depending on P0_MFP and P0_ALT.
N     * |        |          |Refer to P0_ALT descriptions in detail.
N     * |[8]     |P0_ALT0   |P0.0 alternate function Selection
N     * |        |          |The pin function of P0.0 is depend on P0_MFP[0] and P0_ALT[0].
N     * |        |          |P0_ALT[0]P0_MFP[0] = P0.0 Function
N     * |        |          |00 = P0.0
N     * |        |          |01 = AD0(EBI)
N     * |        |          |10 = CTS1(UART1)
N     * |        |          |11 = Reserved
N     * |[9]     |P0_ALT1   |P0.1 alternate function Selection
N     * |        |          |The pin function of P0.1 is depend on P0_MFP[1] and P0_ALT[1].
N     * |        |          |P0_ALT[1] P0_MFP[1] = P0.1 Function
N     * |        |          |00 = P0.1
N     * |        |          |01 = AD1(EBI)
N     * |        |          |10 = RTS1(UART1)
N     * |        |          |11 = Reserved
N     * |[10]    |P0_ALT2   |P0.2 alternate function Selection
N     * |        |          |The pin function of P0.2 is depend on P0_MFP[2] and P0_ALT[2].
N     * |        |          |P0_ALT[2] P0_MFP[2] = P0.2 Function
N     * |        |          |00 = P0.2
N     * |        |          |01 = AD2(EBI)
N     * |        |          |10 = CTS0(UART0)
N     * |        |          |11 = Reserved
N     * |[11]    |P0_ALT3   |P0.3 alternate function Selection
N     * |        |          |The pin function of P0.3 is depend on P0_MFP[3] and P0_ALT[3].
N     * |        |          |P0_ALT[3] P0_MFP[3] = P0.3 Function
N     * |        |          |00 = P0.3
N     * |        |          |01 = AD3(EBI)
N     * |        |          |10 = RTS0(UART0)
N     * |        |          |11 = Reserved
N     * |[12]    |P0_ALT4   |P0.4 alternate function Selection
N     * |        |          |The pin function of P0.4 is depend on P0_MFP[4] and P0_ALT[4].
N     * |        |          |P0_ALT[4] P0_MFP[4] = P0.4 Function
N     * |        |          |00 = P0.4
N     * |        |          |01 = AD4(EBI)
N     * |        |          |10 = SPISS1(SPI1)
N     * |        |          |11 = Reserved
N     * |[13]    |P0_ALT5   |P0.5 alternate function Selection
N     * |        |          |The pin function of P0.5 is depend on P0_MFP[5] and P0_ALT[5].
N     * |        |          |P0_ALT[5] P0_MFP[5] = P0.5 Function
N     * |        |          |00 = P0.5
N     * |        |          |01 = AD5(EBI)
N     * |        |          |10 = MOSI_1(SPI1)
N     * |        |          |11 = Reserved
N     * |[14]    |P0_ALT6   |P0.6 alternate function Selection
N     * |        |          |The pin function of P0.6 is depend on P0_MFP[6] and P0_ALT[6].
N     * |        |          |P0_ALT[6] P0_MFP[6] = P0.6 Function
N     * |        |          |00 = P0.6
N     * |        |          |01 = AD6(EBI)
N     * |        |          |10 = MISO_1(SPI1)
N     * |        |          |11 = Reserved
N     * |[15]    |P0_ALT7   |P0.7 alternate function Selection
N     * |        |          |The pin function of P0.7 is depend on P0_MFP[7] and P0_ALT[7].
N     * |        |          |P0_ALT[7] P0_MFP[7] = P0.7 Function
N     * |        |          |00 = P0.7
N     * |        |          |01 = AD7(EBI)
N     * |        |          |10 = SPICLK1(SPI1)
N     * |        |          |11 = Reserved
N     * |[23:16] |P0_TYPEn  |P0[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P0[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P0[7:0] I/O input Schmitt Trigger function disable 
N     */    
N    __IO uint32_t P0_MFP;
X    volatile uint32_t P0_MFP;
N
N    /**
N     * P1_MFP
N     * ===================================================================================================
N     * Offset: 0x34  P1 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P1_MFP    |P1 multiple function Selection
N     * |        |          |The pin function of P1 is depending on P1_MFP and P1_ALT.
N     * |        |          |Refer to P1_ALT descriptions in detail.
N     * |[8]     |P1_ALT0   |P1.0 alternate function Selection
N     * |        |          |The pin function of P1.0 is depend on P1_MFP[0] and P1_ALT[0].
N     * |        |          |P1_ALT[0] P1_MFP[0] = P1.0 Function
N     * |        |          |00 = P1.0
N     * |        |          |01 = AIN0(ADC)
N     * |        |          |10 = T2(Timer2)
N     * |        |          |11 = Reserved
N     * |[9]     |P1_ALT1   |P1.1 alternate function Selection
N     * |        |          |The pin function of P1.1 is depend on P1_MFP[1] and P1_ALT[1].
N     * |        |          |P1_ALT[1] P1_MFP[1] = P1.1 Function
N     * |        |          |00 = P1.1
N     * |        |          |01 = AIN1(ADC)
N     * |        |          |10 = T3(Timer3)
N     * |        |          |11 = Reserved
N     * |[10]    |P1_ALT2   |P1.2 alternate function Selection
N     * |        |          |The pin function of P1.2 is depend on P1_MFP[2] and P1_ALT[2].
N     * |        |          |P1_ALT[2] P1_MFP[2] = P1.2 Function
N     * |        |          |00 = P1.2
N     * |        |          |01 = AIN2(ADC)
N     * |        |          |10 = RXD1(UART1)
N     * |        |          |11 = Reserved
N     * |[11]    |P1_ALT3   |P1.3 alternate function Selection
N     * |        |          |The pin function of P1.3 is depend on P1_MFP[3] and P1_ALT[3].
N     * |        |          |P1_ALT[3] P1_MFP[3] = P1.3 Function
N     * |        |          |00 = P1.3
N     * |        |          |01 = AIN3(ADC)
N     * |        |          |10 = TXD1(UART1)
N     * |        |          |11 = Reserved
N     * |[12]    |P1_ALT4   |P1.4 alternate function Selection
N     * |        |          |The pin function of P1.4 is depend on P1_MFP[4] and P1_ALT[4].
N     * |        |          |P1_ALT[4] P1_MFP[4] = P1.4 Function
N     * |        |          |00 = P1.4
N     * |        |          |01 = AIN4(ADC)
N     * |        |          |10 = SPISS0(SPI0)
N     * |        |          |11 = Reserved
N     * |[13]    |P1_ALT5   |P1.5 alternate function Selection
N     * |        |          |The pin function of P1.5 is depend on P1_MFP[5] and P1_ALT[5].
N     * |        |          |P1_ALT[5] P1_MFP[5] = P1.5 Function
N     * |        |          |00 = P1.5
N     * |        |          |01 = AIN5(ADC)
N     * |        |          |10 = MOSI_0(SPI0)
N     * |        |          |11 = Reserved
N     * |[14]    |P1_ALT6   |P1.6 alternate function Selection
N     * |        |          |The pin function of P1.6 is depend on P1_MFP[6] and P1_ALT[6].
N     * |        |          |P1_ALT[6] P1_MFP[6] = P1.6 Function
N     * |        |          |00 = P1.6
N     * |        |          |01 = AIN6(ADC)
N     * |        |          |10 = MISO_0(SPI0)
N     * |        |          |11 = Reserved
N     * |[15]    |P1_ALT7   |P1.7 alternate function Selection
N     * |        |          |The pin function of P1.7 is depend on P1_MFP[7] and P1_ALT[7].
N     * |        |          |P1_ALT[7] P1_MFP[7] = P1.7 Function
N     * |        |          |00 = P1.7
N     * |        |          |01 = AIN7(ADC)
N     * |        |          |10 = SPICLK0(SPI0)
N     * |        |          |11 = Reserved
N     * |[23:16] |P1_TYPEn  |P1[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P1[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P1[7:0] I/O input Schmitt Trigger function disable 
N     */    
N    __IO uint32_t P1_MFP;
X    volatile uint32_t P1_MFP;
N
N    /**
N     * P2_MFP
N     * ===================================================================================================
N     * Offset: 0x38  P2 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P2_MFP    |P2 multiple function Selection
N     * |        |          |The pin function of P2 is depending on P2_MFP and P2_ALT.
N     * |        |          |Refer to P2_ALT descriptions in detail.
N     * |[8]     |P2_ALT0   |P2.0 alternate function Selection
N     * |        |          |The pin function of P2.0 is depend on P2_MFP[0] and P2_ALT[0].
N     * |        |          |P2_ALT[0] P2_MFP[0] = P2.0 Function
N     * |        |          |00 = P2.0
N     * |        |          |01 = AD8(EBI)
N     * |        |          |10 = PWM0(PWM generator 0)
N     * |        |          |11 = Reserved
N     * |[9]     |P2_ALT1   |P2.1 alternate function Selection
N     * |        |          |The pin function of P2.1 is depend on P2_MFP[1] and P2_ALT[1].
N     * |        |          |P2_ALT[1] P2_MFP[1] = P2.1 Function
N     * |        |          |00 = P2.1
N     * |        |          |01 = AD9(EBI)
N     * |        |          |10 = PWM1(PWM generator 0)
N     * |        |          |11 = Reserved
N     * |[10]    |P2_ALT2   |P2.2 alternate function Selection
N     * |        |          |The pin function of P2.2 is depend on P2_MFP[2] and P2_ALT[2].
N     * |        |          |P2_ALT[2] P2_MFP[2] = P2.2 Function
N     * |        |          |00 = P2.2
N     * |        |          |01 = AD10(EBI)
N     * |        |          |10 = PWM2(PWM generator 2)
N     * |        |          |11 = Reserved
N     * |[11]    |P2_ALT3   |P2.3 alternate function Selection
N     * |        |          |The pin function of P2.3 is depend on P2_MFP[3] and P2_ALT[3].
N     * |        |          |P2_ALT[3] P2_MFP[3] = P2.3 Function
N     * |        |          |00 = P2.3
N     * |        |          |01 = AD11(EBI)
N     * |        |          |10 = PWM3(PWM generator 2)
N     * |        |          |11 = Reserved
N     * |[12]    |P2_ALT4   |P2.4 alternate function Selection
N     * |        |          |The pin function of P2.4 is depend on P2_MFP[4] and P2_ALT[4].
N     * |        |          |P2_ALT[4] P2_MFP[4] = P0.4 Function
N     * |        |          |00 = P0.4
N     * |        |          |01 = AD12(EBI)
N     * |        |          |10 = PWM4(PWM generator 4)
N     * |        |          |11 = Reserved
N     * |[13]    |P2_ALT5   |P2.5 alternate function Selection
N     * |        |          |The pin function of P2.5 is depend on P2_MFP[5] and P2_ALT[5].
N     * |        |          |P2_ALT[5] P2_MFP[5] = P2.5 Function
N     * |        |          |00 = P2.5
N     * |        |          |01 = AD13(EBI)
N     * |        |          |10 = PWM5(PWM generator 4)
N     * |        |          |11 = Reserved
N     * |[14]    |P2_ALT6   |P2.6 alternate function Selection
N     * |        |          |The pin function of P2.6 is depend on P2_MFP[6] and P2_ALT[6].
N     * |        |          |P2_ALT[6] P2_MFP[6] = P2.6 Function
N     * |        |          |00 = P2.6
N     * |        |          |01 = AD14(EBI)
N     * |        |          |10 = PWM6(PWM generator 6)
N     * |        |          |11 = Reserved
N     * |[15]    |P2_ALT7   |P2.7 alternate function Selection
N     * |        |          |The pin function of P2.7 is depend on P2_MFP[7] and P2_ALT[7].
N     * |        |          |P2_ALT[7] P2_MFP[7] = P2.7 Function
N     * |        |          |00 = P2.7
N     * |        |          |01 = AD15(EBI)
N     * |        |          |10 = PWM7(PWM generator 6)
N     * |        |          |11 = Reserved
N     * |[23:16] |P2_TYPEn  |P2[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P2[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P2[7:0] I/O input Schmitt Trigger function disable 
N     */    
N    __IO uint32_t P2_MFP;
X    volatile uint32_t P2_MFP;
N
N    /**
N     * P3_MFP
N     * ===================================================================================================
N     * Offset: 0x3C  P3 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P3_MFP    |P3 multiple function Selection
N     * |        |          |The pin function of P3 is depending on P3_MFP and P3_ALT.
N     * |        |          |Refer to P3_ALT descriptions in detail.
N     * |[8]     |P3_ALT0   |P3.0 alternate function Selection
N     * |        |          |The pin function of P3.0 is depend on P3_MFP[0] and P3_ALT[0].
N     * |        |          |P3_ALT[0] P3_MFP[0] = P3.0 Function
N     * |        |          |00 = P3.0
N     * |        |          |01 = RXD(UART0)
N     * |        |          |1x = Reserved
N     * |[9]     |P3_ALT1   |P3.1 alternate function Selection
N     * |        |          |The pin function of P3.1 is depend on P3_MFP[1] and P3_ALT[1].
N     * |        |          |P3_ALT[1] P3_MFP[1] = P3.1 Function
N     * |        |          |00 = P3.1
N     * |        |          |01 = TXD(UART0)
N     * |        |          |1x = Reserved
N     * |[10]    |P3_ALT2   |P3.2 alternate function Selection
N     * |        |          |The pin function of P3.2 is depend on P3_MFP[2] and P3_ALT[2].
N     * |        |          |P3_ALT[2] P3_MFP[2] = P3.2 Function
N     * |        |          |00 = P3.2
N     * |        |          |01 = /INT0
N     * |        |          |11 = Reserved
N     * |[11]    |P3_ALT3   |P3.3 alternate function Selection
N     * |        |          |The pin function of P3.3 is depend on P3_MFP[3] and P3_ALT[3].
N     * |        |          |P3_ALT[3] P3_MFP[3] = P3.3 Function
N     * |        |          |00 = P3.3
N     * |        |          |01 = /INT1
N     * |        |          |10 = MCLK(EBI)
N     * |        |          |1x = Reserved
N     * |[12]    |P3_ALT4   |P3.4 alternate function Selection
N     * |        |          |The pin function of P3.4 is depend on P3_MFP[4] and P3_ALT[4].
N     * |        |          |P3_ALT[4] P3_MFP[4] = P3.4 Function
N     * |        |          |00 = P3.4
N     * |        |          |01 = T0(Timer0)
N     * |        |          |10 = SDA(I2C)
N     * |        |          |11 = Reserved
N     * |[13]    |P3_ALT5   |P3.5 alternate function Selection
N     * |        |          |The pin function of P3.5 is depend on P3_MFP[5] and P3_ALT[5].
N     * |        |          |P3_ALT[5] P3_MFP[5] = P3.5 Function
N     * |        |          |00 = P3.5
N     * |        |          |01 = T1(Timer1)
N     * |        |          |10 = SCL(I2C)
N     * |        |          |11 = Reserved
N     * |[14]    |P3_ALT6   |P3.6 alternate function Selection
N     * |        |          |The pin function of P3.6 is depend on P3_MFP[6] and P3_ALT[6].
N     * |        |          |P3_ALT[6] P3_MFP[6] = P3.6 Function
N     * |        |          |00 = P3.6
N     * |        |          |01 = WR(EBI)
N     * |        |          |10 = CKO(Clock Driver output)
N     * |        |          |11 = Reserved
N     * |[15]    |P3_ALT7   |P3.7 alternate function Selection
N     * |        |          |The pin function of P3.7 is depend on P3_MFP[7] and P3_ALT[7].
N     * |        |          |P3_ALT[7] P3_MFP[7] = P3.7 Function
N     * |        |          |00 = P3.7
N     * |        |          |01 = RD(EBI)
N     * |        |          |1x = Reserved
N     * |[23:16] |P3_TYPEn  |P3[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P3[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P3[7:0] I/O input Schmitt Trigger function disable 
N     */    
N    __IO uint32_t P3_MFP;
X    volatile uint32_t P3_MFP;
N
N    /**
N     * P4_MFP
N     * ===================================================================================================
N     * Offset: 0x40  P4 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P4_MFP    |P4 multiple function Selection
N     * |        |          |The pin function of P4 is depending on P4_MFP and P4_ALT.
N     * |        |          |Refer to P4_ALT descriptions in detail.
N     * |[8]     |P4_ALT0   |P4.0 alternate function Selection
N     * |        |          |The pin function of P4.0 is depend on P4_MFP[0] and P4_ALT[0].
N     * |        |          |P4_ALT[0] P4_MFP[0] = P4.0 Function
N     * |        |          |00 = P4.0
N     * |        |          |01 = PWM0(PWM generator 0)
N     * |        |          |1x = Reserved
N     * |[9]     |P4_ALT1   |P4.1 alternate function Selection
N     * |        |          |The pin function of P4.1 is depend on P4_MFP[1] and P4_ALT[1].
N     * |        |          |P4_ALT[1] P4_MFP[1] = P4.1 Function
N     * |        |          |00 = P4.1
N     * |        |          |01 = PWM1(PWM generator 0)
N     * |        |          |1x = Reserved
N     * |[10]    |P4_ALT2   |P4.2 alternate function Selection
N     * |        |          |The pin function of P4.2 is depend on P4_MFP[2] and P4_ALT[2].
N     * |        |          |P4_ALT[2] P4_MFP[2] = P4.2 Function
N     * |        |          |00 = P4.2
N     * |        |          |01 = PWM2(PWM generator 2)
N     * |        |          |1x = Reserved
N     * |[11]    |P4_ALT3   |P4.3 alternate function Selection
N     * |        |          |The pin function of P4.3 is depend on P4_MFP[3] and P4_ALT[3].
N     * |        |          |P4_ALT[3] P4_MFP[3] = P4.3 Function
N     * |        |          |00 = P4.3
N     * |        |          |01 = PWM3(PWM generator 2)
N     * |        |          |1x = Reserved
N     * |[12]    |P4_ALT4   |P4.4 alternate function Selection
N     * |        |          |The pin function of P4.4 is depend on P4_MFP[4] and P4_ALT[4].
N     * |        |          |P4_ALT[4] P4_MFP[4] = P4.4 Function
N     * |        |          |00 = P4.4
N     * |        |          |01 = /CS(EBI)
N     * |        |          |1x = Reserved
N     * |[13]    |P4_ALT5   |P4.5 alternate function Selection
N     * |        |          |The pin function of P4.5 is depend on P4_MFP[5] and P4_ALT[5].
N     * |        |          |P4_ALT[5] P4_MFP[5] = P4.5 Function
N     * |        |          |00 = P4.5
N     * |        |          |01 = ALE(EBI)
N     * |        |          |1x = Reserved
N     * |[14]    |P4_ALT6   |P4.6 alternate function Selection
N     * |        |          |The pin function of P4.6 is depend on P4_MFP[6] and P4_ALT[6].
N     * |        |          |P4_ALT[6] P4_MFP[6] = P4.6 Function
N     * |        |          |00 = P4.6
N     * |        |          |01 = ICE_CLK(ICE)
N     * |        |          |1x = Reserved
N     * |[15]    |P4_ALT7   |P4.7 alternate function Selection
N     * |        |          |The pin function of P4.7 is depend on P4_MFP[7] and P4_ALT[7].
N     * |        |          |P4_ALT[7] P4_MFP[7] = P4.7 Function
N     * |        |          |00 = P4.7
N     * |        |          |01 = ICE_DAT(ICE)
N     * |        |          |1x = Reserved
N     * |[23:16] |P4_TYPEn  |P4[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P4[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P4[7:0] I/O input Schmitt Trigger function disable 
N     */    
N    __IO uint32_t P4_MFP;
X    volatile uint32_t P4_MFP;
N
N    /**
N     * RESERVED3
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    uint32_t RESERVED3[47];
N
N    /**
N     * REGWRPROT
N     * ===================================================================================================
N     * Offset: 0x100 Register Write-Protection Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |REGWRPROT |Register Write-Protected Code (Write Only)
N     * |        |          |Some write-protected registers have to be disabled the protected function by writing the 
N     * |        |          |sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the 
N     * |        |          |REGPROTDIS bit will be set to 1 and write-protected registers can be normal write.
N     * |[0]     |REGPROTDIS|Register Write-Protected Disable index (Read only)
N     * |        |          |1 = Protection is disabled for writing protected registers
N     * |        |          |0 = Protection is enabled for writing protected registers. Any write to the protected register is 
N     * |        |          |ignored.
N     * |        |          |The Write-Protected registers list are below table:
N     * |        |          |Registers Address Note
N     * |        |          |IPRSTC1 0x5000_0008 None
N     * |        |          |BODCR 0x5000_0018 None
N     * |        |          |PORCR 0x5000_001C None
N     * |        |          |PWRCON 0x5000_0200 bit[6] is not protected for power, wake-up interrupt clear
N     * |        |          |APBCLK bit[0] 0x5000_0208 bit[0] is watch dog clock enable
N     * |        |          |CLKSEL0 0x5000_0210 HCLK and CPU STCLK clock source select
N     * |        |          |CLK_SEL1 bit[1:0] 0x5000_0214 Watch dog clock source select
N     * |        |          |ISPCON 0x5000_C000 Flash ISP Control register
N     * |        |          |WTCR 0x4000_4000 None
N     * |        |          |FATCON 0x5000_C018 None
N     */    
N    __IO uint32_t REGWRPROT;
X    volatile uint32_t REGWRPROT;
N
N} GCR_T;
N
N/* GCR RSTSRC Bit Field Definitions */
N#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                       /*!< GCR RSTSRC: RSTS_CPU Position */
N#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)        /*!< GCR RSTSRC: RSTS_CPU Mask */
N
N#define SYS_RSTSRC_RSTS_MCU_Pos                 5                                       /*!< GCR RSTSRC: RSTS_MCU Position */
N#define SYS_RSTSRC_RSTS_MCU_Msk                 (1ul << SYS_RSTSRC_RSTS_MCU_Pos)        /*!< GCR RSTSRC: RSTS_MCU Mask */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                       /*!< GCR RSTSRC: RSTS_BOD Position */
N#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)        /*!< GCR RSTSRC: RSTS_BOD Mask */
N
N#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                       /*!< GCR RSTSRC: RSTS_LVR Position */
N#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)        /*!< GCR RSTSRC: RSTS_LVR Mask */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                       /*!< GCR RSTSRC: RSTS_WDT Position */
N#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)        /*!< GCR RSTSRC: RSTS_WDT Mask */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos               1                                       /*!< GCR RSTSRC: RSTS_RESET Position */
N#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)      /*!< GCR RSTSRC: RSTS_RESET Mask */
N
N#define SYS_RSTSRC_RSTS_POR_Pos                 0                                       /*!< GCR RSTSRC: RSTS_POR Position */
N#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)        /*!< GCR RSTSRC: RSTS_POR Mask */
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define SYS_IPRSTC1_EBI_RST_Pos                 3                                       /*!< GCR IPRSTC1: EBI_RST Position */
N#define SYS_IPRSTC1_EBI_RST_Msk                 (1ul << SYS_IPRSTC1_EBI_RST_Pos)        /*!< GCR IPRSTC1: EBI_RST Mask */
N
N#define SYS_IPRSTC1_CPU_RST_Pos                 1                                       /*!< GCR IPRSTC1: CPU_RST Position */
N#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)        /*!< GCR IPRSTC1: CPU_RST Mask */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos                0                                       /*!< GCR IPRSTC1: CHIP_RST Position */
N#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)       /*!< GCR IPRSTC1: CHIP_RST Mask */
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define SYS_IPRSTC2_ADC_RST_Pos                 28                                      /*!< GCR IPRSTC2: ADC_RST Position */
N#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)        /*!< GCR IPRSTC2: ADC_RST Mask */
N
N#define SYS_IPRSTC2_ACMP1_RST_Pos               23                                      /*!< GCR IPRSTC2: ACMP1_RST Position */
N#define SYS_IPRSTC2_ACMP1_RST_Msk               (1ul << SYS_IPRSTC2_ACMP1_RST_Pos)      /*!< GCR IPRSTC2: ACMP1_RST Mask */
N
N#define SYS_IPRSTC2_ACMP0_RST_Pos               22                                      /*!< GCR IPRSTC2: ACMP0_RST Position */
N#define SYS_IPRSTC2_ACMP0_RST_Msk               (1ul << SYS_IPRSTC2_ACMP0_RST_Pos)      /*!< GCR IPRSTC2: ACMP0_RST Mask */
N#define SYS_IPRSTC2_ACMP_RST_Pos                22                                      /*!< GCR IPRSTC2: ACMP_RST Position */
N#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)       /*!< GCR IPRSTC2: ACMP_RST Mask */
N
N#define SYS_IPRSTC2_PWM47_RST_Pos               21                                      /*!< GCR IPRSTC2: PWM47_RST Position */
N#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)      /*!< GCR IPRSTC2: PWM47_RST Mask */
N
N#define SYS_IPRSTC2_PWM03_RST_Pos               20                                      /*!< GCR IPRSTC2: PWM03_RST Position */
N#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)      /*!< GCR IPRSTC2: PWM03_RST Mask */
N
N#define SYS_IPRSTC2_UART1_RST_Pos               17                                      /*!< GCR IPRSTC2: UART1_RST Position */
N#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)      /*!< GCR IPRSTC2: UART1_RST Mask */
N
N#define SYS_IPRSTC2_UART0_RST_Pos               16                                      /*!< GCR IPRSTC2: UART0_RST Position */
N#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)      /*!< GCR IPRSTC2: UART0_RST Mask */
N
N#define SYS_IPRSTC2_SPI1_RST_Pos                13                                      /*!< GCR IPRSTC2: SPI1_RST Position */
N#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)       /*!< GCR IPRSTC2: SPI1_RST Mask */
N
N#define SYS_IPRSTC2_SPI0_RST_Pos                12                                      /*!< GCR IPRSTC2: SPI0_RST Position */
N#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)       /*!< GCR IPRSTC2: SPI0_RST Mask */
N
N#define SYS_IPRSTC2_I2C1_RST_Pos                9                                       /*!< GCR IPRSTC2: I2C1_RST Position */
N#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)       /*!< GCR IPRSTC2: I2C1_RST Mask */
N
N#define SYS_IPRSTC2_I2C0_RST_Pos                8                                       /*!< GCR IPRSTC2: I2C0_RST Position */
N#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)       /*!< GCR IPRSTC2: I2C0_RST Mask */
N#define SYS_IPRSTC2_I2C_RST_Pos                 8                                       /*!< GCR IPRSTC2: I2C_RST Position */
N#define SYS_IPRSTC2_I2C_RST_Msk                 (1ul << SYS_IPRSTC2_I2C_RST_Pos)        /*!< GCR IPRSTC2: I2C_RST Mask */
N
N#define SYS_IPRSTC2_TMR3_RST_Pos                5                                       /*!< GCR IPRSTC2: TMR3_RST Position */
N#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)       /*!< GCR IPRSTC2: TMR3_RST Mask */
N
N#define SYS_IPRSTC2_TMR2_RST_Pos                4                                       /*!< GCR IPRSTC2: TMR2_RST Position */
N#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)       /*!< GCR IPRSTC2: TMR2_RST Mask */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos                3                                       /*!< GCR IPRSTC2: TMR1_RST Position */
N#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)       /*!< GCR IPRSTC2: TMR1_RST Mask */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos                2                                       /*!< GCR IPRSTC2: TMR0_RST Position */
N#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)       /*!< GCR IPRSTC2: TMR0_RST Mask */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos                1                                       /*!< GCR IPRSTC2: GPIO_RST Position */
N#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)       /*!< GCR IPRSTC2: GPIO_RST Mask */
N
N/* GCR BODCR Bit Field Definitions */
N#define SYS_BODCR_LVR_EN_Pos                    7                                       /*!< GCR BODCR: LVR_EN Position */
N#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)           /*!< GCR BODCR: LVR_EN Mask */
N
N#define SYS_BODCR_BOD_OUT_Pos                   6                                       /*!< GCR BODCR: BOD_OUT Position */
N#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)          /*!< GCR BODCR: BOD_OUT Mask */
N
N#define SYS_BODCR_BOD_LPM_Pos                   5                                       /*!< GCR BODCR: BOD_LPM Position */
N#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)          /*!< GCR BODCR: BOD_LPM Mask */
N
N#define SYS_BODCR_BOD_INTF_Pos                  4                                       /*!< GCR BODCR: BOD_INTF Position */
N#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)         /*!< GCR BODCR: BOD_INTF Mask */
N
N#define SYS_BODCR_BOD_RSTEN_Pos                 3                                       /*!< GCR BODCR: BOD_RSTEN Position */
N#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)        /*!< GCR BODCR: BOD_RSTEN Mask */
N
N#define SYS_BODCR_BOD_VL_Pos                    1                                       /*!< GCR BODCR: BOD_VL Position */
N#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)           /*!< GCR BODCR: BOD_VL Mask */
N
N#define SYS_BODCR_BOD_EN_Pos                    0                                       /*!< GCR BODCR: BOD_EN Position */
N#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)           /*!< GCR BODCR: BOD_EN Mask */
N
N/* GCR TEMPCR Bit Field Definitions */
N#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                       /*!< GCR TEMPCR: VTEMP_EN Position */
N#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)        /*!< GCR TEMPCR: VTEMP_EN Mask */
N
N/* GCR PORCR Bit Field Definitions */
N#define SYS_PORCR_POR_DIS_CODE_Pos              0                                       /*!< GCR PORCR: POR_DIS_CODE Position */
N#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)/*!< GCR PORCR: POR_DIS_CODE Mask */
N
N/* GCR P0_MFP Bit Field Definitions */
N#define SYS_P0_MFP_P0_ALT1_Pos                  24                                      /*!< GCR P0_MFP: P0_ALT1 Position */
N#define SYS_P0_MFP_P0_ALT1_Msk                  (3ul << SYS_P0_MFP_P0_ALT1_Pos)         /*!< GCR P0_MFP: P0_ALT1 Mask */
N
N#define SYS_P0_MFP_P0_TYPE_Pos                  16                                      /*!< GCR P0_MFP: P0_TYPE Position */
N#define SYS_P0_MFP_P0_TYPE_Msk                  (0xFFul << SYS_P0_MFP_P0_TYPE_Pos)      /*!< GCR P0_MFP: P0_TYPE Mask */
N
N#define SYS_P0_MFP_P0_ALT_Pos                   8                                       /*!< GCR P0_MFP: P0_ALT Position */
N#define SYS_P0_MFP_P0_ALT_Msk                   (0xFFul << SYS_P0_MFP_P0_ALT_Pos)       /*!< GCR P0_MFP: P0_ALT Mask */
N
N#define SYS_P0_MFP_P0_MFP_Pos                   0                                       /*!< GCR P0_MFP: P0_MFP Position */
N#define SYS_P0_MFP_P0_MFP_Msk                   (0xFFul << SYS_P0_MFP_P0_MFP_Pos)       /*!< GCR P0_MFP: P0_MFP Mask */
N
N/* GCR P1_MFP Bit Field Definitions */
N#define SYS_P1_MFP_P1_TYPE_Pos                  16                                      /*!< GCR P1_MFP: P1_TYPE Position */
N#define SYS_P1_MFP_P1_TYPE_Msk                  (0xFFul << SYS_P1_MFP_P1_TYPE_Pos)      /*!< GCR P1_MFP: P1_TYPE Mask */
N
N#define SYS_P1_MFP_P1_ALT_Pos                   8                                       /*!< GCR P1_MFP: P1_ALT Position */
N#define SYS_P1_MFP_P1_ALT_Msk                   (0xFFul << SYS_P1_MFP_P1_ALT_Pos)       /*!< GCR P1_MFP: P1_ALT Mask */
N
N#define SYS_P1_MFP_P1_MFP_Pos                   0                                       /*!< GCR P1_MFP: P1_MFP Position */
N#define SYS_P1_MFP_P1_MFP_Msk                   (0xFFul << SYS_P1_MFP_P1_MFP_Pos)       /*!< GCR P1_MFP: P1_MFP Mask */
N
N/* GCR P2_MFP Bit Field Definitions */
N#define SYS_P2_MFP_P2_TYPE_Pos                  16                                      /*!< GCR P2_MFP: P2_TYPE Position */
N#define SYS_P2_MFP_P2_TYPE_Msk                  (0xFFul << SYS_P2_MFP_P2_TYPE_Pos)      /*!< GCR P2_MFP: P2_TYPE Mask */
N
N#define SYS_P2_MFP_P2_ALT_Pos                   8                                       /*!< GCR P2_MFP: P2_ALT Position */
N#define SYS_P2_MFP_P2_ALT_Msk                   (0xFFul << SYS_P2_MFP_P2_ALT_Pos)       /*!< GCR P2_MFP: P2_ALT Mask */
N
N#define SYS_P2_MFP_P2_MFP_Pos                   0                                       /*!< GCR P2_MFP: P2_MFP Position */
N#define SYS_P2_MFP_P2_MFP_Msk                   (0xFFul << SYS_P2_MFP_P2_MFP_Pos)       /*!< GCR P2_MFP: P2_MFP Mask */
N
N/* GCR P3_MFP Bit Field Definitions */
N#define SYS_P3_MFP_P3_TYPE_Pos                  16                                      /*!< GCR P3_MFP: P3_TYPE Position */
N#define SYS_P3_MFP_P3_TYPE_Msk                  (0xFFul << SYS_P3_MFP_P3_TYPE_Pos)      /*!< GCR P3_MFP: P3_TYPE Mask */
N
N#define SYS_P3_MFP_P3_ALT_Pos                   8                                       /*!< GCR P3_MFP: P3_ALT Position */
N#define SYS_P3_MFP_P3_ALT_Msk                   (0xFFul << SYS_P3_MFP_P3_ALT_Pos)       /*!< GCR P3_MFP: P3_ALT Mask */
N
N#define SYS_P3_MFP_P3_MFP_Pos                   0                                       /*!< GCR P3_MFP: P3_MFP Position */
N#define SYS_P3_MFP_P3_MFP_Msk                   (0xFFul << SYS_P3_MFP_P3_MFP_Pos)       /*!< GCR P3_MFP: P3_MFP Mask */
N
N/* GCR P4_MFP Bit Field Definitions */
N#define SYS_P4_MFP_P4_TYPE_Pos                  16                                      /*!< GCR P4_MFP: P4_TYPE Position */
N#define SYS_P4_MFP_P4_TYPE_Msk                  (0xFFul << SYS_P4_MFP_P4_TYPE_Pos)      /*!< GCR P4_MFP: P4_TYPE Mask */
N
N#define SYS_P4_MFP_P4_ALT_Pos                   8                                       /*!< GCR P4_MFP: P4_ALT Position */
N#define SYS_P4_MFP_P4_ALT_Msk                   (0xFFul << SYS_P4_MFP_P4_ALT_Pos)       /*!< GCR P4_MFP: P4_ALT Mask */
N
N#define SYS_P4_MFP_P4_MFP_Pos                   0                                       /*!< GCR P4_MFP: P4_MFP Position */
N#define SYS_P4_MFP_P4_MFP_Msk                   (0xFFul << SYS_P4_MFP_P4_MFP_Pos)       /*!< GCR P4_MFP: P4_MFP Mask */
N
N/* GCR REGWRPROT Bit Field Definitions */
N#define SYS_REGWRPROT_REGWRPROT_Pos             0                                       /*!< GCR REGWRPROT: REGWRPROT Position */
N#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos) /*!< GCR REGWRPROT: REGWRPROT Mask */
N
N#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                       /*!< GCR REGWRPROT: REGPROTDIS Position */
N#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)   /*!< GCR REGWRPROT: REGPROTDIS Mask */
N
N/*@}*/ /* end of group M051_GCR */
N
N
N/** @addtogroup M051_INT M051 INT
N  Memory Mapped Structure for M051 Series Interrupt Source Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * IRQSRC
N     * ===================================================================================================
N     * Offset: 0x00-0x7C MCU IRQn(n=0~31) Interrupt Source Identity Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t IRQSRC[32];
X    volatile const  uint32_t IRQSRC[32];
N
N    /**
N     * NMISEL
N     * ===================================================================================================
N     * Offset: 0x80 NMI Interrupt Source Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t NMISEL;
X    volatile uint32_t NMISEL;
N
N    /**
N     * MCUIRQ
N     * ===================================================================================================
N     * Offset: 0x84      MCU Interrupt Request Source Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t MCUIRQ;
X    volatile uint32_t MCUIRQ;
N
N} GCR_INT_T;
N
N/* INT NMI_SEL Bit Field Definitions */
N#define INT_NMI_SEL_NMI_EN_Pos                  8                                       /*!< INT NMI_SEL: NMI_EN Position */
N#define INT_NMI_SEL_NMI_EN_Msk                  (1ul << INT_NMI_SEL_NMI_EN_Pos)         /*!< INT NMI_SEL: NMI_EN Mask */
N
N#define INT_NMI_SEL_NMI_SEL_Pos                 0                                       /*!< INT NMI_SEL: NMI_SEL Position */
N#define INT_NMI_SEL_NMI_SEL_Msk                 (0x1Ful << INT_NMI_SEL_NMI_SEL_Pos)     /*!< INT NMI_SEL: NMI_SEL Mask */
N/*@}*/ /* end of group M051_INT */
N
N/*-------------------------- FLASH Memory Controller -------------------------*/
N
N/** @addtogroup M051_FMC M051 FMC
N  Memory Mapped Structure for M051 Series Flash Memory Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * ISPCON
N     * ===================================================================================================
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable
N     * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
N     * |        |          |1 = Enable ISP function
N     * |        |          |0 = Disable ISP function
N     * |[1]     |BS        |Boot Select 
N     * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM, 
N     * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where 
N     * |        |          |MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-
N     * |        |          |on reset; It keeps the same value at other reset.
N     * |        |          |1 = boot from LDROM
N     * |        |          |0 = boot from APROM
N     * |[4]     |CFGUEN    |Config Update Enable
N     * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program 
N     * |        |          |code is running in APROM or LDROM.
N     * |        |          |1 = Config update enable 
N     * |        |          |0 = Config update disable
N     * |[5]     |LDUEN     |LDROM Update Enable
N     * |        |          |LDROM update enable bit. 
N     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N     * |        |          |0 = LDROM cannot be updated
N     * |[6]     |ISPFF     |ISP Fail Flag
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself.
N     * |        |          |(2) LDROM writes to itself. 
N     * |        |          |(3) Destination address is illegal, such as over an available range.
N     * |        |          |Write 1 to clear.
N     * |[7]     |SWRST     |Software Reset
N     * |        |          |Writing 1 to this bit to start software reset. 
N     * |        |          |It is cleared by hardware after reset is finished.
N     * |[10:8]  |PT        |Flash Program Time
N     * |        |          |000 = 40 us
N     * |        |          |001 = 45 us
N     * |        |          |010 = 50 us
N     * |        |          |011 = 55 us
N     * |        |          |100 = 20 us
N     * |        |          |101 = 25 us
N     * |        |          |110 = 30 us
N     * |        |          |111 = 35 us
N     * |[14:12] |ET        |Flash Erase Time
N     * |        |          |000 = 20 ms (default)
N     * |        |          |001 = 25 ms 
N     * |        |          |010 = 30 ms 
N     * |        |          |011 = 35 ms 
N     * |        |          |100 = 3  ms 
N     * |        |          |101 = 5  ms 
N     * |        |          |110 = 10 ms 
N     * |        |          |111 = 15 ms 
N     */    
N    __IO uint32_t ISPCON;
X    volatile uint32_t ISPCON;
N
N    /**
N     * ISPADR
N     * ===================================================================================================
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADR    |ISP Address 
N     * |        |          |NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program 
N     * |        |          |only. ISPARD[1:0] must be kept 2'b00 for ISP operation. 
N     */    
N    __IO uint32_t ISPADR;
X    volatile uint32_t ISPADR;
N
N    /**
N     * ISPDAT
N     * ===================================================================================================
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data 
N     * |        |          |Write data to this register before ISP program operation
N     * |        |          |Read data from this register after ISP read operation
N     */    
N    __IO uint32_t ISPDAT;
X    volatile uint32_t ISPDAT;
N
N    /**
N     * ISPCMD
N     * ===================================================================================================
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command 
N     * |        |          |ISP command table is shown below:
N     * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
N     * |        |          |Read          ,    0,    0, 0000
N     * |        |          |Program       ,    1,    0, 0001
N     * |        |          |Page Erase    ,    1,    0, 0010
N     */    
N    __IO uint32_t ISPCMD;
X    volatile uint32_t ISPCMD;
N
N    /**
N     * ISPTRG
N     * ===================================================================================================
N     * Offset: 0x10  IISP Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP start trigger
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP 
N     * |        |          |operation is finish. 
N     * |        |          |1 = ISP is on going 
N     * |        |          |0 = ISP done
N     */    
N    __IO uint32_t ISPTRG;
X    volatile uint32_t ISPTRG;
N
N    /**
N     * DFBADR
N     * ===================================================================================================
N     * Offset: 0x14  Data Flash Base Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates data flash start address. 
N     * |        |          | 
N     * |        |          |It is a read only register. 
N     * |        |          | 
N     * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at 
N     * |        |          |0x01F000 by hardware internally.
N     */    
N    __I  uint32_t DFBADR;
X    volatile const  uint32_t DFBADR;
N
N    /**
N     * FATCON
N     * ===================================================================================================
N     * Offset: 0x18  Flash Access Time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FPSEN     |Flash Power Save Enable
N     * |        |          |If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
N     * |        |          |1 = Enable flash power saving
N     * |        |          |0 = Disable flash power saving
N     * |[3:1]   |FATS      |Flash Access Time Window Select
N     * |        |          |These bits are used to decide flash sense amplifier active duration.
N     * |        |          |000 = 40 ns
N     * |        |          |001 = 50 ns
N     * |        |          |010 = 60 ns
N     * |        |          |011 = 70 ns
N     * |        |          |100 = 80 ns
N     * |        |          |101 = 90 ns
N     * |        |          |110 = 100 ns
N     * |        |          |111 = Reserved
N     * |[4]     |L_SPEED   |Flash Low Speed Mode Enable
N     * |        |          |1 = Flash access always no wait state (zero wait state)
N     * |        |          |0 = Insert wait state while Flash access discontinued address. 
N     * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong 
N     * |        |          |code and cause fail result.
N     */    
N    __IO uint32_t FATCON;
X    volatile uint32_t FATCON;
N
N} FMC_T;
N
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC ISPCON: ISPFF Position */
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC ISPCON: ISPFF Mask */
N
N#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC ISPCON: LDUEN Position */
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC ISPCON: LDUEN Mask */
N
N#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC ISPCON: CFGUEN Position */
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC ISPCON: CFGUEN Mask */
N
N#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC ISPCON: APUEN Position */
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC ISPCON: APUEN Mask */
N
N#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC ISPCON: BS Position */
N#define FMC_ISPCON_BS_Msk                       (1ul << FMC_ISPCON_BS_Pos)              /*!< FMC ISPCON: BS Mask */
N                                                                                        
N#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC ISPCON: ISPEN Position */
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC ISPCON: ISPEN Mask */
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC ISPCMD: FOEN Position */
N#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC ISPCMD: FOEN Mask */
N
N#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC ISPCMD: FCEN Position */
N#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC ISPCMD: FCEN Mask */
N
N#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC ISPCMD: FCTRL Position */
N#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC ISPCMD: FCTRL Mask */
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC ISPTRG: ISPGO Position */
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC ISPTRG: ISPGO Mask */
N
N/* FMC FATCON Bit Field Definitions */
N#define FMC_FATCON_LFOM_Pos                     4                                       /*!< FMC FATCON: LFOM Position */
N#define FMC_FATCON_LFOM_Msk                     (1ul << FMC_FATCON_LFOM_Pos)            /*!< FMC FATCON: LFOM Mask */
N
N#define FMC_FATCON_FATS_Pos                     1                                       /*!< FMC FATCON: FATS Position */
N#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)            /*!< FMC FATCON: FATS Mask */
N
N#define FMC_FATCON_FPSEN_Pos                    0                                       /*!< FMC FATCON: FPSEN Position */
N#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)           /*!< FMC FATCON: FPSEN Mask */
N/*@}*/ /* end of group M051_FMC */
N
N/*----------------------------- PWM Controller -------------------------------*/
N
N/** @addtogroup M051_PWM M051 PWM
N  Memory Mapped Structure for M051 Series PWM Generator and Capture Timer
N  @{
N */
Ntypedef struct
N{
N    /**
N     * PPR
N     * ===================================================================================================
N     * Offset: 0x00  PWM Pre-Scale Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CP01      |Clock pre-scalar 0(PWM counter 0 & 1 for group A and PWM counter 4 & 5 for group B)
N     * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
N     * |        |          |If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM 
N     * |        |          |counter will be stopped also.
N     * |[15:8]  |CP23      |Clock pre-scalar 2(PWM counter 2 & 3 for group A and PWM counter 6 & 7 for group B)
N     * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
N     * |        |          |If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM 
N     * |        |          |counter will be stopped also.
N     * |[23:16] |DZI01     |Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair 
N     * |        |          |for PWM group A, PWM4 and PWM5 pair for PWM group B)
N     * |        |          |These 8 bits determine dead zone length.
N     * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
N     * |[31:24] |DZI23     |Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair 
N     * |        |          |for PWM group A, PWM6 and PWM7 pair for PWM group B)
N     * |        |          |These 8 bits determine dead zone length.
N     * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
N     */    
N    __IO uint32_t PPR;
X    volatile uint32_t PPR;
N
N    /**
N     * CSR
N     * ===================================================================================================
N     * Offset: 0x04  PWM Clock Source Divider Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |(Table is the same as CSR3)
N     * |[6:4]   |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |(Table is the same as CSR3)
N     * |[10:8]  |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |(Table is the same as CSR3)
N     * |[14:12] |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |CSRx[2:0] = Input clock divider
N     * |        |          |100 = 1
N     * |        |          |011 = 16
N     * |        |          |010 = 8
N     * |        |          |001 = 4
N     * |        |          |000 = 2
N     */    
N    __IO uint32_t CSR;
X    volatile uint32_t CSR;
N
N    /**
N     * PCR
N     * ===================================================================================================
N     * Offset: 0x08  PWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CH0EN     |PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.
N     * |[4]     |DZEN01    |Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A, 
N     * |        |          |PWM4 and PWM5 pair for PWM group B)
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a 
N     * |        |          |complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a 
N     * |        |          |complementary pair for PWM group B.
N     * |[5]     |DZEN23    |Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A, 
N     * |        |          |PWM6 and PWM7 pair for PWM group B)
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a 
N     * |        |          |complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a 
N     * |        |          |complementary pair for PWM group B.
N     * |[8]     |CH1EN     |PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[10]    |CH1INV    |PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[11]    |CH1MOD    |PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.
N     * |[16]    |CH2EN     |PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[18]    |CH2INV    |PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[19]    |CH2MOD    |PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.
N     * |[24]    |CH3EN     |PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[26]    |CH3INV    |PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[27]    |CH3MOD    |PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.
N     */    
N    __IO uint32_t PCR;
X    volatile uint32_t PCR;
N
N    /**
N     * CNR0
N     * ===================================================================================================
N     * Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR0;
X    volatile uint32_t CNR0;
N
N    /**
N     * CMR0
N     * ===================================================================================================
N     * Offset: 0x10  PWM Comparator 0 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR0;
X    volatile uint32_t CMR0;
N
N    /**
N     * PDR0
N     * ===================================================================================================
N     * Offset: 0x14  PWM Data 0 Register(current counter 0 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR0;
X    volatile const  uint32_t PDR0;
N
N    /**
N     * CNR1
N     * ===================================================================================================
N     * Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR1;
X    volatile uint32_t CNR1;
N
N    /**
N     * CMR1
N     * ===================================================================================================
N     * Offset: 0x1C  PWM Comparator 1 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR1;
X    volatile uint32_t CMR1;
N
N    /**
N     * PDR1
N     * ===================================================================================================
N     * Offset: 0x20  PWM Data 1 Register(current counter 1 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR1;
X    volatile const  uint32_t PDR1;
N
N    /**
N     * CNR2
N     * ===================================================================================================
N     * Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR2;
X    volatile uint32_t CNR2;
N
N    /**
N     * CMR2
N     * ===================================================================================================
N     * Offset: 0x28  PWM Comparator 2 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR2;
X    volatile uint32_t CMR2;
N
N    /**
N     * PDR2
N     * ===================================================================================================
N     * Offset: 0x2C  PWM Data 2 Register(current counter 2 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR2;
X    volatile const  uint32_t PDR2;
N
N    /**
N     * CNR3
N     * ===================================================================================================
N     * Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR3;
X    volatile uint32_t CNR3;
N
N    /**
N     * CMR3
N     * ===================================================================================================
N     * Offset: 0x34  PWM Comparator 3 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR3;
X    volatile uint32_t CMR3;
N
N    /**
N     * PDR3
N     * ===================================================================================================
N     * Offset: 0x38  PWM Data 3 Register(current counter 3 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR3;
X    volatile const  uint32_t PDR3;
N
N    /**
N     * RESERVE0
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I uint32_t RESERVE0;
X    volatile const uint32_t RESERVE0;
N
N    /**
N     * PIER
N     * ===================================================================================================
N     * Offset: 0x40  PWM Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWMIE0    |PWM channel 0 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     * |[1]     |PWMIE1    |PWM channel 1 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     * |[2]     |PWMIE2    |PWM channel 2 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     * |[3]     |PWMIE3    |PWM channel 3 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     */    
N    __IO uint32_t PIER;
X    volatile uint32_t PIER;
N
N    /**
N     * PIIR
N     * ===================================================================================================
N     * Offset: 0x44  PWM Interrupt Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWMIF0    |PWM channel 0 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM0 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     * |[1]     |PWMIF1    |PWM channel 1 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM1 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     * |[2]     |PWMIF2    |PWM channel 2 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM2 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     * |[3]     |PWMIF3    |PWM channel 3 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM3 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     */    
N    __IO uint32_t PIIR;
X    volatile uint32_t PIIR;
N
N    /**
N     * RESERVE1
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I uint32_t    RESERVE1[2];
X    volatile const uint32_t    RESERVE1[2];
N
N    /**
N     * CCR0
N     * ===================================================================================================
N     * Offset: 0x50  Capture 0/1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INV0      | 
N     * |        |          |PWM Group Channel 0 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[1]     |CRL_IE0   |PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 0 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[2]     |CFL_IE0   |PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 0 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[3]     |CAPCH0EN  |Capture Channel 0 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 0.
N     * |        |          |0 = Disable capture function on PWM group channel 0
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 0 Interrupt.
N     * |[4]     |CAPIF0    | 
N     * |        |          |Capture0 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs 
N     * |        |          |at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[6]     |CRLRI0    | 
N     * |        |          |CRLR0 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[7]     |CFLRI0    | 
N     * |        |          |CFLR0 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[16]    |INV1      | 
N     * |        |          |PWM Group Channel 1 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[17]    |CRL_IE1   |PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 1 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[18]    |CFL_IE1   |PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 1 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[19]    |CAPCH1EN  |Capture Channel 1 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 1.
N     * |        |          |0 = Disable capture function on PWM group channel 1
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 1 Interrupt.
N     * |[20]    |CAPIF1    | 
N     * |        |          |Capture1 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs 
N     * |        |          |at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[22]    |CRLRI1    | 
N     * |        |          |CRLR1 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[23]    |CFLRI1    | 
N     * |        |          |CFLR1 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     */    
N    __IO uint32_t CCR0;
X    volatile uint32_t CCR0;
N
N    /**
N     * CCR2
N     * ===================================================================================================
N     * Offset: 0x54  Capture 2/3 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INV2      | 
N     * |        |          |PWM Group Channel 2 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[1]     |CRL_IE2   |PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 2 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[2]     |CFL_IE2   |PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 2 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[3]     |CAPCH2EN  |Capture Channel 2 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 2.
N     * |        |          |0 = Disable capture function on PWM group channel 2
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 2 Interrupt.
N     * |[4]     |CAPIF2    | 
N     * |        |          |Capture2 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs 
N     * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[6]     |CRLRI2    | 
N     * |        |          |CRLR2 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[7]     |CFLRI2    | 
N     * |        |          |CFLR2 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[16]    |INV3      | 
N     * |        |          |PWM Group Channel 3 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[17]    |CRL_IE3   |PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 3 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[18]    |CFL_IE3   |PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 3 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[19]    |CAPCH3EN  |Capture Channel 3 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 3.
N     * |        |          |0 = Disable capture function on PWM group channel 3
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 3 Interrupt.
N     * |[20]    |CAPIF3    | 
N     * |        |          |Capture3 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs 
N     * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[22]    |CRLRI3    | 
N     * |        |          |CRLR3 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[23]    |CFLRI3    | 
N     * |        |          |CFLR3 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     */    
N    __IO uint32_t CCR2;
X    volatile uint32_t CCR2;
N
N    /**
N     * CRLR0
N     * ===================================================================================================
N     * Offset: 0x58  Capture 0 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR0;
X    volatile uint32_t CRLR0;
N
N    /**
N     * CFLR0
N     * ===================================================================================================
N     * Offset: 0x5C  Capture 0 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR0;
X    volatile uint32_t CFLR0;
N
N    /**
N     * CRLR1
N     * ===================================================================================================
N     * Offset: 0x60  Capture 1 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR1;
X    volatile uint32_t CRLR1;
N
N    /**
N     * CFLR1
N     * ===================================================================================================
N     * Offset: 0x64  Capture 1 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR1;
X    volatile uint32_t CFLR1;
N
N    /**
N     * CRLR2
N     * ===================================================================================================
N     * Offset: 0x68  Capture 2 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR2;
X    volatile uint32_t CRLR2;
N
N    /**
N     * CFLR2
N     * ===================================================================================================
N     * Offset: 0x6C  Capture 2 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR2;
X    volatile uint32_t CFLR2;
N
N    /**
N     * CRLR3
N     * ===================================================================================================
N     * Offset: 0x70  Capture 3 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR3;
X    volatile uint32_t CRLR3;
N
N    /**
N     * CFLR3
N     * ===================================================================================================
N     * Offset: 0x74  Capture 3 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR3;
X    volatile uint32_t CFLR3;
N
N    /**
N     * CAPENR
N     * ===================================================================================================
N     * Offset: 0x78  Capture Input Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |CAPENR    |Capture Input Enable Register
N     * |        |          |There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or 
N     * |        |          |OFF. 
N     * |        |          |0 = OFF (PWMx multi-function pin input does not affect input capture function.)
N     * |        |          |1 = (PWMx multi-function pin input will affect its input capture function.)
N     * |        |          |CAPENR
N     * |        |          |Bit 3210 for PWM group A
N     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [0] 
N     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [1] 
N     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [2]
N     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [3]
N     * |        |          |Bit 3210 for PWM group B
N     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [4] 
N     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [5] 
N     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [6]
N     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [7]
N     */    
N    __IO uint32_t CAPENR;
X    volatile uint32_t CAPENR;
N
N    /**
N     * POE
N     * ===================================================================================================
N     * Offset: 0x7C  PWM Output Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWM0      |PWM Channel 0 Output Enable Register
N     * |        |          |1 = Enable PWM channel 0 output to pin.
N     * |        |          |0 = Disable PWM channel 0 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     * |[1]     |PWM1      |PWM Channel 1 Output Enable Register
N     * |        |          |1 = Enable PWM channel 1 output to pin.
N     * |        |          |0 = Disable PWM channel 1 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     * |[2]     |PWM2      |PWM Channel 2 Output Enable Register
N     * |        |          |1 = Enable PWM channel 2 output to pin.
N     * |        |          |0 = Disable PWM channel 2 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     * |[3]     |PWM3      |PWM Channel 3 Output Enable Register
N     * |        |          |1 = Enable PWM channel 3 output to pin.
N     * |        |          |0 = Disable PWM channel 3 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     */    
N    __IO uint32_t POE;
X    volatile uint32_t POE;
N
N    /**
N     * TCON
N     * ===================================================================================================
N     * Offset: 0x80  PWM Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TCON;
X    volatile uint32_t TCON;
N
N    /**
N     * TSTATUS
N     * ===================================================================================================
N     * Offset: 0x84  PWM Trigger Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TSTATUS;
X    volatile uint32_t TSTATUS;
N
N    /**
N     * RESERVE2
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  RESERVE2[4];
X    volatile const  uint32_t  RESERVE2[4];
N
N    /**
N     * PSCR
N     * ===================================================================================================
N     * Offset: 0x98  PWM Synchronous Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t PSCR;
X    volatile uint32_t PSCR;
N        
N} PWM_T;
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM PPR: DZI23 Position */
N#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM PPR: DZI23 Mask */
N
N#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM PPR: DZI01 Position */
N#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM PPR: DZI01 Mask */
N
N#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM PPR: CP23 Position */
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM PPR: CP23 Mask */
N
N#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM PPR: CP01 Position */
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM PPR: CP01 Mask */
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM CSR: CSR3 Position */
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM CSR: CSR3 Mask */
N
N#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM CSR: CSR2 Position */
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM CSR: CSR2 Mask */
N
N#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM CSR: CSR1 Position */
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM CSR: CSR1 Mask */
N
N#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM CSR: CSR0 Position */
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM CSR: CSR0 Mask */
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM PCR: PWM23TYPE Position */
N#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM PCR: PWM23TYPE Mask */
N
N#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM PCR: PWM01TYPE Position */
N#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM PCR: PWM01TYPE Mask */
N
N#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM PCR: CH3MOD Position */
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM PCR: CH3MOD Mask */
N
N#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM PCR: CH3INV Position */
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM PCR: CH3INV Mask */
N
N#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM PCR: CH3PINV Position */
N#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM PCR: CH3PINV Mask */
N
N#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM PCR: CH3EN Position */
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM PCR: CH3EN Mask */
N
N#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM PCR: CH2MOD Position */
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM PCR: CH2MOD Mask */
N
N#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM PCR: CH2INV Position */
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM PCR: CH2INV Mask */
N
N#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM PCR: CH2PINV Position */
N#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM PCR: CH2PINV Mask */
N
N#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM PCR: CH2EN Position */
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM PCR: CH2EN Mask */
N
N#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM PCR: CH1MOD Position */
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM PCR: CH1MOD Mask */
N
N#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM PCR: CH1INV Position */
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM PCR: CH1INV Mask */
N
N#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM PCR: CH1PINV Position */
N#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM PCR: CH1PINV Mask */
N
N#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM PCR: CH1EN Position */
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM PCR: CH1EN Mask */
N
N#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM PCR: DZEN23 Position */
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM PCR: DZEN23 Mask */
N
N#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM PCR: DZEN01 Position */
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM PCR: DZEN01 Mask */
N
N#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM PCR: CH0MOD Position */
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM PCR: CH0MOD Mask */
N
N#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM PCR: CH0INV Position */
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM PCR: CH0INV Mask */
N
N#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM PCR: CH0PINV Position */
N#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM PCR: CH0PINV Mask */
N
N#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM PCR: CH0EN Position */
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM PCR: CH0EN Mask */
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM CNR: CNR Position */
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM CNR: CNR Mask */
N
N/* PWM CMR Bit Field Definitions */
N#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM CMR: CMR Position */
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM CMR: CMR Mask */
N
N/* PWM PDR Bit Field Definitions */
N#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM PDR: PDR Position */
N#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM PDR: PDR Mask */
N
N
N/* PWM PIER Bit Field Definitions */
N#define PWM_PIER_INT23DTYPE_Pos                 25                                  /*!< PWM PIER: INT23DTYPE Position */
N#define PWM_PIER_INT23DTYPE_Msk                    (1ul << PWM_PIER_INT23DTYPE_Pos) /*!< PWM PIER: INT23DTYPE Mask */
N
N#define PWM_PIER_INT01DTYPE_Pos                 24                                  /*!< PWM PIER: INT01DTYPE Position */
N#define PWM_PIER_INT01DTYPE_Msk                     (1ul << PWM_PIER_INT01DTYPE_Pos)/*!< PWM PIER: INT01DTYPE Mask */
N
N#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM PIER: INT23TYPE Position */
N#define PWM_PIER_INT23TYPE_Msk                     (1ul << PWM_PIER_INT23TYPE_Pos)  /*!< PWM PIER: INT23TYPE Mask */
N
N#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM PIER: INT01TYPE Position */
N#define PWM_PIER_INT01TYPE_Msk                     (1ul << PWM_PIER_INT01TYPE_Pos)  /*!< PWM PIER: INT01TYPE Mask */
N
N#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM PIER: PWMDIE3 Position */
N#define PWM_PIER_PWMDIE3_Msk                     (1ul << PWM_PIER_PWMDIE3_Pos)      /*!< PWM PIER: PWMDIE3 Mask */
N
N#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM PIER: PWMDIE2 Position */
N#define PWM_PIER_PWMDIE2_Msk                     (1ul << PWM_PIER_PWMDIE2_Pos)      /*!< PWM PIER: PWMDIE2 Mask */
N
N#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM PIER: PWMDIE1 Position */
N#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM PIER: PWMDIE1 Mask */
N
N#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM PIER: PWMDIE0 Position */
N#define PWM_PIER_PWMDIE0_Msk                     (1ul << PWM_PIER_PWMDIE0_Pos)      /*!< PWM PIER: PWMDIE0 Mask */
N
N#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM PIER: PWMIE3 Position */
N#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM PIER: PWMIE3 Mask */
N
N#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM PIER: PWMIE2 Position */
N#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM PIER: PWMIE2 Mask */
N
N#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM PIER: PWMIE1 Position */
N#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM PIER: PWMIE1 Mask */
N
N#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM PIER: PWMIE0 Position */
N#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM PIER: PWMIE0 Mask */
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM PIIR: PWMDIF3 Position */
N#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM PIIR: PWMDIF3 Mask */
N
N#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM PIIR: PWMDIF2 Position */
N#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM PIIR: PWMDIF2 Mask */
N
N#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM PIIR: PWMDIF1 Position */
N#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM PIIR: PWMDIF1 Mask */
N
N#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM PIIR: PWMDIF0 Position */
N#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM PIIR: PWMDIF0 Mask */
N
N#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM PIIR: PWMIF3 Position */
N#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM PIIR: PWMIF3 Mask */
N
N#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM PIIR: PWMIF2 Position */
N#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM PIIR: PWMIF2 Mask */
N
N#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM PIIR: PWMIF1 Position */
N#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM PIIR: PWMIF1 Mask */
N
N#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM PIIR: PWMIF0 Position */
N#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM PIIR: PWMIF0 Mask */
N
N/* PWM CCR0 Bit Field Definitions */
N#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM CCR0: CFLRI1 Position */
N#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM CCR0: CFLRI1 Mask */
N
N#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM CCR0: CRLRI1 Position */
N#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM CCR0: CRLRI1 Mask */
N
N#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM CCR0: CAPIF1 Position */
N#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM CCR0: CAPIF1 Mask */
N
N#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM CCR0: CAPCH1EN Position */
N#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM CCR0: CAPCH1EN Mask */
N
N#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM CCR0: CFL_IE1 Position */
N#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM CCR0: CFL_IE1 Mask */
N
N#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM CCR0: CRL_IE1 Position */
N#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM CCR0: CRL_IE1 Mask */
N
N#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM CCR0: INV1 Position */
N#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM CCR0: INV1 Mask */
N
N#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM CCR0: CFLRI0 Position */
N#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM CCR0: CFLRI0 Mask */
N
N#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM CCR0: CRLRI0 Position */
N#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM CCR0: CRLRI0 Mask */
N
N#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM CCR0: CAPIF0 Position */
N#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM CCR0: CAPIF0 Mask */
N
N#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM CCR0: CAPCH0EN Position */
N#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM CCR0: CAPCH0EN Mask */
N
N#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM CCR0: CFL_IE0 Position */
N#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM CCR0: CFL_IE0 Mask */
N
N#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM CCR0: CRL_IE0 Position */
N#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM CCR0: CRL_IE0 Mask */
N
N#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM CCR0: INV0 Position */
N#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM CCR0: INV0 Mask */
N
N/* PWM CCR2 Bit Field Definitions */
N#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM CCR2: CFLRI3 Position */
N#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM CCR2: CFLRI3 Mask */
N
N#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM CCR2: CRLRI3 Position */
N#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM CCR2: CRLRI3 Mask */
N
N#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM CCR2: CAPIF3 Position */
N#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM CCR2: CAPIF3 Mask */
N
N#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM CCR2: CAPCH3EN Position */
N#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM CCR2: CAPCH3EN Mask */
N
N#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM CCR2: CFL_IE3 Position */
N#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM CCR2: CFL_IE3 Mask */
N
N#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM CCR2: CRL_IE3 Position */
N#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM CCR2: CRL_IE3 Mask */
N
N#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM CCR2: INV3 Position */
N#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM CCR2: INV3 Mask */
N
N#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM CCR2: CFLRI2 Position */
N#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM CCR2: CFLRI2 Mask */
N
N#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM CCR2: CRLRI2 Position */
N#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM CCR2: CRLRI2 Mask */
N
N#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM CCR2: CAPIF2 Position */
N#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM CCR2: CAPIF2 Mask */
N
N#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM CCR2: CAPCH2EN Position */
N#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM CCR2: CAPCH2EN Mask */
N
N#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM CCR2: CFL_IE2 Position */
N#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM CCR2: CFL_IE2 Mask */
N
N#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM CCR2: CRL_IE2 Position */
N#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM CCR2: CRL_IE2 Mask */
N
N#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM CCR2: INV2 Position */
N#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM CCR2: INV2 Mask */
N
N/* PWM CRLR Bit Field Definitions */
N#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM CRLR: CRLR Position */
N#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM CRLR: CRLR Mask */
N
N/* PWM CFLR Bit Field Definitions */
N#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM CFLR: CFLR Position */
N#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM CFLR: CFLR Mask */
N
N/* PWM CAPENR Bit Field Definitions */
N#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM CAPENR: CINEN3 Position */
N#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM CAPENR: CINEN3 Mask */   
N
N#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM CAPENR: CINEN2 Position */
N#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM CAPENR: CINEN2 Mask */  
N
N#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM CAPENR: CINEN1 Position */
N#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM CAPENR: CINEN1 Mask */  
N
N#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM CAPENR: CINEN0 Position */
N#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM CAPENR: CINEN0 Mask */ 
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_PWM3_Pos                        3                                   /*!< PWM POE: POE3 Position */
N#define PWM_POE_PWM3_Msk                        (1ul << PWM_POE_PWM3_Pos)           /*!< PWM POE: POE3 Mask */   
N
N#define PWM_POE_PWM2_Pos                        2                                   /*!< PWM POE: POE2 Position */
N#define PWM_POE_PWM2_Msk                        (1ul << PWM_POE_PWM2_Pos)           /*!< PWM POE: POE2 Mask */  
N
N#define PWM_POE_PWM1_Pos                        1                                   /*!< PWM POE: POE1 Position */
N#define PWM_POE_PWM1_Msk                        (1ul << PWM_POE_PWM1_Pos)           /*!< PWM POE: POE1 Mask */  
N
N#define PWM_POE_PWM0_Pos                        0                                   /*!< PWM POE: POE0 Position */
N#define PWM_POE_PWM0_Msk                        (1ul << PWM_POE_PWM0_Pos)           /*!< PWM POE: POE0 Mask */  
N
N/* PWM TCON Bit Field Definitions */
N#define PWM_TCON_PWM3DTEN_Pos                   11                                  /*!< PWM TCON: PWM3DTEN Position */
N#define PWM_TCON_PWM3DTEN_Msk                   (1ul << PWM_TCON_PWM3DTEN_Pos)      /*!< PWM TCON: PWM3DTEN Mask */   
N
N#define PWM_TCON_PWM2DTEN_Pos                   10                                  /*!< PWM TCON: PWM2DTEN Position */
N#define PWM_TCON_PWM2DTEN_Msk                   (1ul << PWM_TCON_PWM2DTEN_Pos)      /*!< PWM TCON: PWM2DTEN Mask */ 
N
N#define PWM_TCON_PWM1DTEN_Pos                   9                                   /*!< PWM TCON: PWM1DTEN Position */
N#define PWM_TCON_PWM1DTEN_Msk                   (1ul << PWM_TCON_PWM1DTEN_Pos)      /*!< PWM TCON: PWM1DTEN Mask */ 
N
N#define PWM_TCON_PWM0DTEN_Pos                   8                                   /*!< PWM TCON: PWM0DTEN Position */
N#define PWM_TCON_PWM0DTEN_Msk                   (1ul << PWM_TCON_PWM0DTEN_Pos)      /*!< PWM TCON: PWM0DTEN Mask */ 
N
N#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM TCON: PWM3TEN Position */
N#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM TCON: PWM3TEN Mask */ 
N
N#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM TCON: PWM2TEN Position */
N#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM TCON: PWM2TEN Mask */ 
N
N#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM TCON: PWM1TEN Position */
N#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM TCON: PWM1TEN Mask */ 
N
N#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM TCON: PWM0TEN Position */
N#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM TCON: PWM0TEN Mask */ 
N
N#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM TSTATUS: PWM3TF Position */
N#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM TSTATUS: PWM3TF Mask */ 
N
N#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM TSTATUS: PWM2TF Position */
N#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM TSTATUS: PWM2TF Mask */ 
N
N#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM TSTATUS: PWM1TF Position */
N#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM TSTATUS: PWM1TF Mask */ 
N
N#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM TSTATUS: PWM0TF Position */
N#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM TSTATUS: PWM0TF Mask */ 
N
N#define PWM_PSCR_PSSEN3_Pos                     24                                  /*!< PWM PSCR: PSSEN3 Position */
N#define PWM_PSCR_PSSEN3_Msk                     (1ul << PWM_PSCR_PSSEN3_Pos)        /*!< PWM PSCR: PSSEN3 Mask */ 
N
N#define PWM_PSCR_PSSEN2_Pos                     16                                  /*!< PWM PSCR: PSSEN2 Position */
N#define PWM_PSCR_PSSEN2_Msk                     (1ul << PWM_PSCR_PSSEN2_Pos)        /*!< PWM PSCR: PSSEN2 Mask */ 
N
N#define PWM_PSCR_PSSEN1_Pos                     8                                   /*!< PWM PSCR: PSSEN1 Position */
N#define PWM_PSCR_PSSEN1_Msk                     (1ul << PWM_PSCR_PSSEN1_Pos)        /*!< PWM PSCR: PSSEN1 Mask */ 
N
N#define PWM_PSCR_PSSEN0_Pos                     0                                   /*!< PWM PSCR: PSSEN0 Position */
N#define PWM_PSCR_PSSEN0_Msk                     (1ul << PWM_PSCR_PSSEN0_Pos)        /*!< PWM PSCR: PSSEN0 Mask */ 
N/*@}*/ /* end of group M051_PWM */
N
N
N/*----------------------- External Bus Interface Controller ------------------*/
N/** @addtogroup M051_EBI M051 External Bus Interface
N  Memory Mapped Structure for M051 Series External Bus Interface Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * EBICON
N     * ===================================================================================================
N     * Offset: 0x00  EBI Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ExtEN     |EBI Enable 
N     * |        |          |This bit is the functional enable bit for EBI. 
N     * |        |          |0 = EBI function is disabled 
N     * |        |          |1 = EBI function is enabled
N     * |[1]     |ExtBW16   |EBI data width 16 bit 
N     * |        |          |This bit defines if the data bus is 8-bit or 16-bit. 
N     * |        |          |0 = EBI data width is 8 bit 
N     * |        |          |1 = EBI data width is 16 bit
N     * |[10:8]  |MCLKDIV   |External Output Clock Divider 
N     * |        |          |The frequency of EBI output clock is controlled by MCLKDIV.
N     * |        |          |000 = HCLK/1
N     * |        |          |001 = HCLK/2
N     * |        |          |010 = HCLK/4
N     * |        |          |011 = HCLK/8
N     * |        |          |100 = HCLK/16
N     * |        |          |101 = HCKL/32
N     * |        |          |11X = default
N     * |        |          | 
N     * |        |          |Notice: Default value of output clock is HCLK/1
N     * |[18:16] |ExttALE   |Expand Time of ALE 
N     * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE. 
N     * |        |          |tALE = (ExttALE + 1) * MCLK
N     */    
N    __IO uint32_t EBICON;
X    volatile uint32_t EBICON;
N
N    /**
N     * EXTIME
N     * ===================================================================================================
N     * Offset: 0x04  EBI Timing Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:3]   |ExttACC   |EBI Data Accesss Time 
N     * |        |          |ExttACC define data access time (tACC). 
N     * |        |          |tACC = (ExttACC + 1) * MCLK
N     * |[10:8]  |ExttAHD   |EBI Data Access Hold Time 
N     * |        |          |ExttAHD define data access hold time (tAHD). 
N     * |        |          |tAHD = (ExttAHD + 1) * MCLK
N     * |[15:12] |ExtIW2X   |Idle State Cycle After Write 
N     * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero. 
N     * |        |          |Idle state cycle = (ExtIW2X * MCLK)
N     * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read 
N     * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS return 
N     * |        |          |to high if ExtIR2R is not zero. 
N     * |        |          |Idle state cycle = (ExtIR2R * MCLK)
N     */    
N    __IO uint32_t EXTIME;
X    volatile uint32_t EXTIME;
N
N} EBI_T;
N
N/* EBI EBICON Bit Field Definitions */
N#define EBI_EBICON_ExttALE_Pos      16                                          /*!< EBI EBICON: ExttALE Position */
N#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)           /*!< EBI EBICON: ExttALE Mask */
N
N#define EBI_EBICON_MCLKDIV_Pos      8                                           /*!< EBI EBICON: MCLKDIV Position */
N#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)           /*!< EBI EBICON: MCLKDIV Mask */
N
N#define EBI_EBICON_ExtBW16_Pos      1                                           /*!< EBI EBICON: ExtBW16 Position */
N#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)             /*!< EBI EBICON: ExtBW16 Mask */
N
N#define EBI_EBICON_ExtEN_Pos        0                                           /*!< EBI EBICON: ExtEN Position */
N#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)               /*!< EBI EBICON: ExtEN Mask */
N
N/* EBI EXTIME Bit Field Definitions */
N#define EBI_EXTIME_ExtIR2R_Pos      24                                          /*!< EBI EXTIME: ExtIR2R Position */
N#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)           /*!< EBI EXTIME: ExtIR2R Mask */
N
N#define EBI_EXTIME_ExtIW2X_Pos      12                                          /*!< EBI EXTIME: ExtIW2X Position */
N#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)           /*!< EBI EXTIME: ExtIW2X Mask */
N
N#define EBI_EXTIME_ExttAHD_Pos      8                                           /*!< EBI EXTIME: ExttAHD Position */
N#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)           /*!< EBI EXTIME: ExttAHD Mask */
N
N#define EBI_EXTIME_ExttACC_Pos      3                                           /*!< EBI EXTIME: ExttACC Position */
N#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)          /*!< EBI EXTIME: ExttACC Mask */
N/*@}*/ /* end of group M051_EBI */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup M051_PERIPHERAL_MEM_MAP M051 Peripheral Memory Map
N  Memory Mapped Structure for M051 Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE       + 0x4000)                   /*!< GPIO Base Address                                   */
N#define P0_BASE             (GPIO_BASE              )                   /*!< GPIO P0 Base Address                                */  
N#define P1_BASE             (GPIO_BASE      + 0x0040)                   /*!< GPIO P1 Base Address                                */
N#define P2_BASE             (GPIO_BASE      + 0x0080)                   /*!< GPIO P2 Base Address                                */
N#define P3_BASE             (GPIO_BASE      + 0x00C0)                   /*!< GPIO P3 Base Address                                */
N#define P4_BASE             (GPIO_BASE      + 0x0100)                   /*!< GPIO P4 Base Address                                */
N#define GPIO_DBNCECON_BASE  (GPIO_BASE      + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
N#define GPIO_PIN_DATA_BASE  (GPIO_BASE      + 0x200)                    /*!< GPIO Pin Data Input/Output Control Base Address     */
N
N#define UART0_BASE           (APB1_BASE      + 0x50000)                 /*!< UART0 Base Address                               */
N#define UART1_BASE           (APB2_BASE      + 0x50000)                 /*!< UART1 Base Address                               */
N
N#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
N#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
N#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
N#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
N
N#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watch Dog Timer Base Address                     */
N
N#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watch Dog Timer Base Address              */
N
N#define SPI0_BASE            (APB1_BASE      + 0x30000)                 /*!< SPI0 Base Address                                */
N#define SPI1_BASE            (APB1_BASE      + 0x34000)                 /*!< SPI1 Base Address                                */
N
N#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
N#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
N
N#define RTC_BASE             (APB1_BASE      + 0x08000)                 /*!< RTC Base Address                                 */
N
N#define ADC_BASE             (APB1_BASE      + 0xE0000)                 /*!< ADC Base Address                                 */
N
N#define ACMP0_BASE           (APB1_BASE      + 0xD0000)                 /*!< ACMP0 Base Address                               */
N#define ACMP1_BASE           (APB2_BASE      + 0xD0000)                 /*!< ACMP1 Base Address                               */
N
N#define SYSCLK_BASE          (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
N
N#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
N
N#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
N
N#define FMC_BASE             (AHB_BASE       + 0x0C000)                 /*!< Flash Memory Controller Base Address             */
N
N#define PWMA_BASE            (APB1_BASE      + 0x40000)                 /*!< PWMA Base Address                                */
N#define PWMB_BASE            (APB2_BASE      + 0x40000)                 /*!< PWMB Base Address                                */
N
N#define EBI_BASE             (AHB_BASE       + 0x10000)                 /*!< EBI Base Address                                 */
N
N/*@}*/ /* end of group M051_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/ 
N
N/** @addtogroup M051_PERIPHERAL_DECLARATION M051 Peripheral Declaration
N  The Declaration of M051 Series Peripheral
N  @{
N */
N#define P0                  ((GPIO_T *) P0_BASE)                        /*!< GPIO PORT0 Configuration Struct                        */
N#define P1                  ((GPIO_T *) P1_BASE)                        /*!< GPIO PORT1 Configuration Struct                        */
N#define P2                  ((GPIO_T *) P2_BASE)                        /*!< GPIO PORT2 Configuration Struct                        */
N#define P3                  ((GPIO_T *) P3_BASE)                        /*!< GPIO PORT3 Configuration Struct                        */
N#define P4                  ((GPIO_T *) P4_BASE)                        /*!< GPIO PORT4 Configuration Struct                        */
N#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */ 
N
N#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
N#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< TIMER0 Configuration Struct                      */
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< TIMER1 Configuration Struct                      */
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< TIMER2 Configuration Struct                      */
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< TIMER3 Configuration Struct                      */
N
N#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watch Dog Timer Configuration Struct             */
N
N#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watch Dog Timer Configuration Struct      */
N
N#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
N#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
N
N#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
N#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
N
N#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
N
N#define ACMP0               ((ACMP_T *) ACMP0_BASE)                     /*!< ACMP0 Configuration Struct                       */
N#define ACMP1               ((ACMP_T *) ACMP1_BASE)                     /*!< ACMP1 Configuration Struct                       */
N
N#define SYSCLK              ((SYSCLK_T *) SYSCLK_BASE)                  /*!< System Clock Controller Configuration Struct     */
N
N#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
N
N#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
N
N#define FMC                 ((FMC_T *) FMC_BASE)                        /*!< Flash Memory Controller Configuration Struct     */
N
N#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
N#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
N
N#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
N
N/*@}*/ /* end of group M051_PERIPHERAL_DECLARATION */
N
N/*@}*/ /* end of group M051_SERIES_REG */
N
N
N//=============================================================================
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N
N#define outpw(port,value)   (*((volatile unsigned int *)(port))=value)
N#define inpw(port)          ((*((volatile unsigned int *)(port))))
N#define outpb(port,value)   (*((volatile unsigned char *)(port))=value)
N#define inpb(port)          ((*((volatile unsigned char *)(port))))
N#define outps(port,value)   (*((volatile unsigned short *)(port))=value)
N#define inps(port)          ((*((volatile unsigned short *)(port))))
N
N#define outp32(port,value)  (*((volatile unsigned int *)(port))=value)
N#define inp32(port)         ((*((volatile unsigned int *)(port))))
N#define outp8(port,value)   (*((volatile unsigned char *)(port))=value)
N#define inp8(port)          ((*((volatile unsigned char *)(port))))
N#define outp16(port,value)  (*((volatile unsigned short *)(port))=value)
N#define inp16(port)         ((*((volatile unsigned short *)(port))))
N
N
N#define E_SUCCESS   0
N#ifndef NULL
S#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE      1
N#define DISABLE     0
N
N/* Bit Mask Definitions */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/ 
N#include "SYS.h"
L 1 "..\..\LibM051Series\StdDriver\inc\SYS.h" 1
N/**************************************************************************//**
N * @file     SYS.h
N * @version  V2.1
N * $Revision: 11 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series Global Control and Clock Control Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#include "M051Series.h"
L 1 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 1
N/**************************************************************************//**
N * @file     M051Series.h
N * @version  V2.1
N * $Revision: 10 $
N * $Date: 12/06/19 11:18a $
N * @brief    M051 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __M051Series_H__
S#define __M051Series_H__
S                 
S
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S */
S 
S/**
S * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
S */
Stypedef enum IRQn
S{
S/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
S  NonMaskableInt_IRQn       = -14,      /*!< 2 Non Maskable Interrupt                             */
S  HardFault_IRQn            = -13,      /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
S  SVCall_IRQn               = -5,       /*!< 11 Cortex-M0 SV Call Interrupt                       */
S  PendSV_IRQn               = -2,       /*!< 14 Cortex-M0 Pend SV Interrupt                       */
S  SysTick_IRQn              = -1,       /*!< 15 Cortex-M0 System Tick Interrupt                   */
S
S/******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
S  BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
S  WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
S  EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
S  EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
S  GPIO_P0P1_IRQn            = 4,        /*!< GPIO_P0P1 Interrupt                                  */
S  GPIO_P2P3P4_IRQn          = 5,        /*!< GPIO_P2P3P4 Interrupt                                */
S  PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
S  PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
S  TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
S  TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
S  TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
S  TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
S  UART0_IRQn                = 12,       /*!< UART0 Interrupt                                      */
S  UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
S  SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
S  SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
S  I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
S  I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
S  ACMP0_IRQn                = 25,       /*!< ACMP0 Interrupt                                      */
S  ACMP1_IRQn                = 26,       /*!< ACMP1 Interrupt                                      */
S  PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
S  ADC_IRQn                  = 29        /*!< ADC Interrupt                                        */
S           
S} IRQn_Type;
S
S
S/*
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M0 Processor and Core Peripherals */
S#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
S#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
S#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
S
S
S#include "core_cm0.h"                   /*!< Cortex-M0 processor and core peripherals             */
S#include "system_M051Series.h"          /*!< M051Series System                                    */
S
S
S#if defined ( __CC_ARM   )
S#pragma anon_unions
S#endif
S
S
S/**
S * Initialize the system clock
S *
S * @param  none
S * @return none
S *
S * @brief  Setup the microcontroller system
S *         Initialize the PLL and update the SystemFrequency variable
S */
Sextern void SystemInit (void);                
S
S
S/******************************************************************************/
S/*                Device Specific Peripheral registers structures             */
S/******************************************************************************/
S
S/** @addtogroup M051_SERIES_REG M051 Series Registers
S @{             
S*/
S
S
S/*--------------------- General Purpose Input and Ouptut ---------------------*/
S/** @addtogroup M051_GPIO M051 GPIO
S  Memory Mapped Structure for M051 Series General Purpose I/O
S  @{
S */
Stypedef struct
S{
S    /**
S     * PMD
S     * ===================================================================================================
S     * Offset: 0x00  Port 0-4  I/O Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |PMD0      |P0 I/O Pin[0] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[0] pin is in INPUT mode. 
S     * |        |          |01 = P0[0] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[0] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[0] pin is in Quasi-bidirectional mode.
S     * |[3:2]   |PMD1      |P0 I/O Pin[1] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[1] pin is in INPUT mode. 
S     * |        |          |01 = P0[1] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[1] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[1] pin is in Quasi-bidirectional mode.
S     * |[5:4]   |PMD2      |P0 I/O Pin[2] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[2] pin is in INPUT mode. 
S     * |        |          |01 = P0[2] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[2] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[2] pin is in Quasi-bidirectional mode.
S     * |[7:6]   |PMD3      |P0 I/O Pin[3] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[3] pin is in INPUT mode. 
S     * |        |          |01 = P0[3] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[3] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[3] pin is in Quasi-bidirectional mode.
S     * |[9:8]   |PMD4      |P0 I/O Pin[4] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[4] pin is in INPUT mode. 
S     * |        |          |01 = P0[4] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[4] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[4] pin is in Quasi-bidirectional mode.
S     * |[11:10] |PMD5      |P0 I/O Pin[5] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[5] pin is in INPUT mode. 
S     * |        |          |01 = P0[5] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[5] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[5] pin is in Quasi-bidirectional mode.
S     * |[13:12] |PMD6      |P0 I/O Pin[6] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[6] pin is in INPUT mode. 
S     * |        |          |01 = P0[6] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[6] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[6] pin is in Quasi-bidirectional mode.
S     * |[15:14] |PMD7      |P0 I/O Pin[7] Mode Control 
S     * |        |          |Determine each I/O type of P0 pins 
S     * |        |          |00 = P0[7] pin is in INPUT mode. 
S     * |        |          |01 = P0[7] pin is in OUTPUT mode. 
S     * |        |          |10 = P0[7] pin is in Open-Drain mode. 
S     * |        |          |11 = P0[7] pin is in Quasi-bidirectional mode.
S     */    
S    __IO uint32_t  PMD;                         
S
S    /**
S     * OFFD
S     * ===================================================================================================
S     * Port 0-4 Digital Input Path Disable Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:16] |OFFD      |OFFD: P0 Pin OFF digital input path Enable 
S     * |        |          |1 = Disable IO digital input path (digital input tied to low) 
S     * |        |          |0 = Enable IO digital input path
S     */    
S    __IO uint32_t  OFFD;                        
S
S    /**
S     * DOUT
S     * ===================================================================================================
S     * Port 0-4 Data Output Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DOUT0     |P0 Pin[0] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.
S     * |[1]     |DOUT1     |P0 Pin[1] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.
S     * |[2]     |DOUT2     |P0 Pin[2] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.
S     * |[3]     |DOUT3     |P0 Pin[3] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.
S     * |[4]     |DOUT4     |P0 Pin[4] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.
S     * |[5]     |DOUT5     |P0 Pin[5] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.
S     * |[6]     |DOUT6     |P0 Pin[6] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.
S     * |[7]     |DOUT7     |P0 Pin[7] Output Value 
S     * |        |          |Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain 
S     * |        |          |and quasi-mode. 
S     * |        |          |1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set. 
S     * |        |          |0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.
S     */    
S    __IO uint32_t  DOUT;                        
S
S    /**
S     * DMASK
S     * ===================================================================================================
S     * Port0-4 Data Output Write Mask
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DMASK0    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the 
S     * |        |          |DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[0] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[0] bit is protected
S     * |[1]     |DMASK1    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the 
S     * |        |          |DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[1] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[1] bit is protected
S     * |[2]     |DMASK2    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the 
S     * |        |          |DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[2] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[2] bit is protected
S     * |[3]     |DMASK3    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the 
S     * |        |          |DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[3] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[3] bit is protected
S     * |[4]     |DMASK4    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the 
S     * |        |          |DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[4] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[4] bit is protected
S     * |[5]     |DMASK5    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the 
S     * |        |          |DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[6] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[6] bit is protected
S     * |[6]     |DMASK6    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the 
S     * |        |          |DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[6] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[6] bit is protected
S     * |[7]     |DMASK7    |P0 Data Output Write Mask 
S     * |        |          |These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the 
S     * |        |          |DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write 
S     * |        |          |data to the protect bit is ignored 
S     * |        |          |0 = The corresponding P0_DOUT[7] bit can be updated 
S     * |        |          |1 = The corresponding P0_DOUT[7] bit is protected
S     */    
S    __IO uint32_t  DMASK;                       
S
S    /**
S     * PIN;
S     * ===================================================================================================
S     * Port 0-4 Pin Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PIN0      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[0].
S     * |[1]     |PIN1      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[1].
S     * |[2]     |PIN2      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[2].
S     * |[3]     |PIN3      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[3].
S     * |[4]     |PIN4      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[4].
S     * |[5]     |PIN5      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[5].
S     * |[6]     |PIN6      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[6].
S     * |[7]     |PIN7      |P0 Pin Values 
S     * |        |          |The value read from each of these bit reflects the actual status of the respective P0 Pin[7].
S     */    
S    __IO uint32_t  PIN;                         
S
S    /**
S     * DBEN
S     * ===================================================================================================
S     * Port 0-4 De-bounce Enable
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DBEN0     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[0] de-bounce function is disabled 
S     * |        |          |1 = The bit[0] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     * |[1]     |DBEN1     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[1] de-bounce function is disabled 
S     * |        |          |1 = The bit[1] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     * |[2]     |DBEN2     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[2] de-bounce function is disabled 
S     * |        |          |1 = The bit[2] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     * |[3]     |DBEN3     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[3] de-bounce function is disabled 
S     * |        |          |1 = The bit[3] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     * |[4]     |DBEN4     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[4] de-bounce function is disabled 
S     * |        |          |1 = The bit[4] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     * |[5]     |DBEN5     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[5] de-bounce function is disabled 
S     * |        |          |1 = The bit[5] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     * |[6]     |DBEN6     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[6] de-bounce function is disabled 
S     * |        |          |1 = The bit[6] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     * |[7]     |DBEN7     |P0 Input Signal De-bounce Enable 
S     * |        |          |DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse 
S     * |        |          |width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen 
S     * |        |          |as the signal bounce and will not trigger the interrupt. 
S     * |        |          |The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt 
S     * |        |          |0 = The bit[7] de-bounce function is disabled 
S     * |        |          |1 = The bit[7] de-bounce function is enabled 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, 
S     * |        |          |the de-bounce enable bit is ignored.
S     */    
S    __IO uint32_t  DBEN;                        
S
S    /**
S     * IMD
S     * ===================================================================================================
S     * Port 0-4 Interrupt Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |IMD0      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     * |[1]     |IMD1      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     * |[2]     |IMD2      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     * |[3]     |IMD3      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     * |[4]     |IMD4      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     * |[5]     |IMD5      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     * |[6]     |IMD6      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     * |[7]     |IMD7      |Port 0 Interrupt Mode Control 
S     * |        |          |IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge 
S     * |        |          |trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is 
S     * |        |          |sampled by one clock and the generate the interrupt 
S     * |        |          |0 = Edge trigger interrupt 
S     * |        |          |1 = Level trigger interrupt 
S     * |        |          |if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN. 
S     * |        |          |if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur. 
S     * |        |          |The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the 
S     * |        |          |de-bounce enable bit is ignored.
S     */    
S    __IO uint32_t  IMD;                         
S
S    /**
S     * IEN
S     * ===================================================================================================
S     * Port 0-4 Interrupt Enable Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |IF_EN0    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[0] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[0] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[0] state low-level or high-to-low change interrupt
S     * |[1]     |IF_EN1    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[1] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[1] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[1] state low-level or high-to-low change interrupt
S     * |[2]     |IF_EN2    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[2] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[2] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[2] state low-level or high-to-low change interrupt
S     * |[3]     |IF_EN3    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[3] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[3] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[3] state low-level or high-to-low change interrupt
S     * |[4]     |IF_EN4    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[4] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[4] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[4] state low-level or high-to-low change interrupt
S     * |[5]     |IF_EN5    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[5] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[5] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[5] state low-level or high-to-low change interrupt
S     * |[6]     |IF_EN6    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[6] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[6] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[6] state low-level or high-to-low change interrupt
S     * |[7]     |IF_EN7    |Port0 Interrupt Enable by Input Falling Edge or Input Level Low 
S     * |        |          |IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IF_EN[7] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[7] state low-level or high-to-low change interrupt 
S     * |        |          |0 = Disable the P0[7] state low-level or high-to-low change interrupt
S     * |[16]    |IR_EN0    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[0] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[0] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[0] level-high or low-to-high interrupt
S     * |[17]    |IR_EN1    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[1] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[1] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[1] level-high or low-to-high interrupt
S     * |[18]    |IR_EN2    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[2] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[2] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[2] level-high or low-to-high interrupt
S     * |[19]    |IR_EN3    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[3] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[3] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[3] level-high or low-to-high interrupt
S     * |[20]    |IR_EN4    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[4] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[4] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[4] level-high or low-to-high interrupt
S     * |[21]    |IR_EN5    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[5] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[5] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[5] level-high or low-to-high interrupt
S     * |[22]    |IR_EN6    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[6] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[6] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[6] level-high or low-to-high interrupt
S     * |[23]    |IR_EN7    |Port 0 Interrupt Enable by Input Rising Edge or Input Level High 
S     * |        |          |IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also 
S     * |        |          |enable the pin wakeup function. 
S     * |        |          |When set the IR_EN[7] bit "1": 
S     * |        |          |If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt. 
S     * |        |          |If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate 
S     * |        |          |the interrupt. 
S     * |        |          |1 = Enable the P0[7] level-high or low-to-high interrupt 
S     * |        |          |0 = Disable the P0[7] level-high or low-to-high interrupt
S     */    
S    __IO uint32_t  IEN;                         
S
S    /**
S     * ISRC
S     * ===================================================================================================
S     * Port 0-4 Interrupt Trigger Source
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISRC0     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[0] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[0] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     * |[1]     |ISRC1     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[1] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[1] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     * |[2]     |ISRC2     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[2] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[2] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     * |[3]     |ISRC3     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[3] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[3] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     * |[4]     |ISRC4     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[4] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[4] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     * |[5]     |ISRC5     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[5] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[5] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     * |[6]     |ISRC6     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[6] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[6] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     * |[7]     |ISRC7     |Port 0 Interrupt Trigger Source Indicator 
S     * |        |          |Read: 
S     * |        |          |1 = Indicates P0[7] generate an interrupt 
S     * |        |          |0 = No interrupt at P0[7] 
S     * |        |          |Write: 
S     * |        |          |1 = Clear the correspond pending interrupt 
S     * |        |          |0 = No action
S     */    
S    __IO uint32_t  ISRC;                        
S} GPIO_T;                                  
S                                                
Stypedef struct                                  
S{                                               
S    /**
S     * DBNCECON
S     * ===================================================================================================
S     * Offset: 0x180 Interrupt De-bounce Cycle Control
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |DBCLKSEL  |De-bounce sampling cycle selection
S     * |        |          |DBCLKSEL
S     * |        |          |Description
S     * |        |          |0 = Sample interrupt input once per 1 clocks
S     * |        |          |1 = Sample interrupt input once per 2 clocks
S     * |        |          |2 = Sample interrupt input once per 4 clocks
S     * |        |          |3 = Sample interrupt input once per 8 clocks
S     * |        |          |4 = Sample interrupt input once per 16 clocks
S     * |        |          |5 = Sample interrupt input once per 32 clocks
S     * |        |          |6 = Sample interrupt input once per 64 clocks
S     * |        |          |7 = Sample interrupt input once per 128 clocks
S     * |        |          |8 = Sample interrupt input once per 256 clocks
S     * |        |          |9 = Sample interrupt input once per 2*256 clocks
S     * |        |          |10 = Sample interrupt input once per 4*256clocks
S     * |        |          |11 = Sample interrupt input once per 8*256 clocks
S     * |        |          |12 = Sample interrupt input once per 16*256 clocks
S     * |        |          |13 = Sample interrupt input once per 32*256 clocks
S     * |        |          |14 = Sample interrupt input once per 64*256 clocks
S     * |        |          |15 = Sample interrupt input once per 128*256 clocks
S     * |[4]     |DBCLKSRC  |De-bounce counter clock source select
S     * |        |          |1 = De-bounce counter clock source is the internal 10KHz clock
S     * |        |          |0 = De-bounce counter clock source is the HCLK
S     * |[5]     |ICLK_ON   |Interrupt clock On mode
S     * |        |          |Set this bit "0" will disable the interrupt generate circuit clock, if the pin[n] interrupt is disabled
S     * |        |          |0 = disable the clock if the P0/1/2/3/4[n] interrupt is disabled
S     * |        |          |1 = interrupt generated circuit clock always enable 
S     * |        |          |n=0~7
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DBNCECON;                    
S} GPIO_DBNCECON_T;
S
S/* GPIO PMD Bit Field Definitions */
S#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO PMD: PMD7 Position */
S#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO PMD: PMD7 Mask */
S
S#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO PMD: PMD6 Position */    
S#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO PMD: PMD6 Mask */
S
S#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO PMD: PMD5 Position */
S#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO PMD: PMD5 Mask */
S
S#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO PMD: PMD4 Position */
S#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO PMD: PMD4 Mask */
S
S#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO PMD: PMD3 Position */
S#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO PMD: PMD3 Mask */
S
S#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO PMD: PMD2 Position */
S#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO PMD: PMD2 Mask */
S
S#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO PMD: PMD1 Position */
S#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO PMD: PMD1 Mask */
S
S#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO PMD: PMD0 Position */
S#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO PMD: PMD0 Mask */
S
S/* GPIO OFFD Bit Field Definitions */
S#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO OFFD: OFFD Position */
S#define GPIO_OFFD_OFFD_Msk          (0xFFul << GPIO_OFFD_OFFD_Pos)              /*!< GPIO OFFD: OFFD Mask */
S
S/* GPIO DOUT Bit Field Definitions */                                           
S#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO DOUT: DOUT Position */
S#define GPIO_DOUT_DOUT_Msk          (0xFFul << GPIO_DOUT_DOUT_Pos)              /*!< GPIO DOUT: DOUT Mask */
S
S/* GPIO DMASK Bit Field Definitions */
S#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO DMASK: DMASK Position */
S#define GPIO_DMASK_DMASK_Msk        (0xFFul << GPIO_DMASK_DMASK_Pos)            /*!< GPIO DMASK: DMASK Mask */
S
S/* GPIO PIN Bit Field Definitions */
S#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO PIN: PIN Position */   
S#define GPIO_PIN_PIN_Msk            (0xFFul << GPIO_PIN_PIN_Pos)                /*!< GPIO PIN: PIN Mask */
S
S/* GPIO DBEN Bit Field Definitions */
S#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO DBEN: DBEN Position */
S#define GPIO_DBEN_DBEN_Msk          (0xFFul << GPIO_DBEN_DBEN_Pos)              /*!< GPIO DBEN: DBEN Mask */
S
S/* GPIO IMD Bit Field Definitions */
S#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO IMD: IMD Position */
S#define GPIO_IMD_IMD_Msk            (0xFFul << GPIO_IMD_IMD_Pos)                /*!< GPIO IMD: IMD Mask */
S
S/* GPIO IEN Bit Field Definitions */
S#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO IEN: IR_EN Position */
S#define GPIO_IEN_IR_EN_Msk          (0xFFul << GPIO_IEN_IR_EN_Pos)              /*!< GPIO IEN: IR_EN Mask */
S
S#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO IEN: IF_EN Position */
S#define GPIO_IEN_IF_EN_Msk          (0xFFul << GPIO_IEN_IF_EN_Pos)              /*!< GPIO IEN: IF_EN Mask */
S
S/* GPIO ISRC Bit Field Definitions */
S#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO ISRC: ISRC Position */
S#define GPIO_ISRC_ISRC_Msk          (0xFFul << GPIO_ISRC_ISRC_Pos)              /*!< GPIO ISRC: ISRC Mask */
S
S/* GPIO DBNCECON Bit Field Definitions */
S#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO DBNCECON: ICLK_ON  Position */
S#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO DBNCECON: ICLK_ON  Mask */
S
S#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO DBNCECON: DBCLKSRC Position */
S#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO DBNCECON: DBCLKSRC Mask */
S
S#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO DBNCECON: DBCLKSEL Position */
S#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO DBNCECON: DBCLKSEL Mask */
S/*@}*/ /* end of group M051_GPIO */
S
S
S/*------------------------- UART Interface Controller ------------------------*/
S
S/** @addtogroup M051_UART M051 UART
S  Memory Mapped Structure for M051 Series UART Serial Interface Controller
S  @{
S */
Stypedef struct
S{
S                                
S    union {                             
S    __IO uint32_t DATA;                 
S
S    /**
S     * THR
S     * ===================================================================================================
S     * Offset: 0x00 Transmit Holding DATA
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |          |bitTransmittedData
S     * |        |          |Transmit Holding Register
S     * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB 
S     * |        |          |first).
S     */    
S    __IO uint32_t THR;                  
S
S    /**
S     * RBR
S     * ===================================================================================================
S     * Offset: 0x00 Receive Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |          |Receive Buffer Register
S     * |        |          |By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).
S     */    
S    __IO uint32_t RBR;                  
S    };
S
S    /**
S     * IER
S     * ===================================================================================================
S     * Offset: 0x04  UART Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable.
S     * |        |          |0 = Mask off INT_RDA
S     * |        |          |1 = Enable INT_RDA
S     * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable
S     * |        |          |0 = Mask off INT_THRE
S     * |        |          |1 = Enable INT_THRE
S     * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable 
S     * |        |          |0 = Mask off INT_RLS
S     * |        |          |1 = Enable INT_RLS
S     * |[3]     |Modem_IEN |Modem Status Interrupt Enable 
S     * |        |          |0 = Mask off INT_MOS
S     * |        |          |1 = Enable INT_MOS
S     * |[4]     |RTO_IEN   |Rx Time out Interrupt Enable
S     * |        |          |0 = Mask off INT_tout
S     * |        |          |1 = Enable INT_tout 
S     * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable
S     * |        |          |0 = Mask off INT_Buf_err
S     * |        |          |1 = Enable INT_Buf_err
S     * |[6]     |Wake_EN   |Wake up CPU function enable 
S     * |        |          |0 = Disable UART wake up CPU function
S     * |        |          |1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS 
S     * |        |          |change will wake up CPU from deep sleep mode.
S     * |[11]    |Time_Out_EN|Time-Out Counter Enable
S     * |        |          |1 = Enable Time-out counter.
S     * |        |          |0 = Disable Time-out counter.
S     * |[12]    |Auto_RTS_EN|RTS Auto Flow Control Enable 
S     * |        |          |1 = Enable RTS auto flow control.
S     * |        |          |0 = Disable RTS auto flow control.
S     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR 
S     * |[RTS_Tri_Lev], the UART will dessert RTS signal.|[13]      |Auto_CTS_EN
S     * |        |          |CTS Auto Flow Control Enable
S     * |        |          |1 = Enable CTS auto flow control.
S     * |        |          |0 = Disable CTS auto flow control.
S     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input 
S     * |        |          |assert (UART will not send data to device until CTS is asserted).
S     */    
S    __IO uint32_t IER;                  
S
S    /**
S     * FCR
S     * ===================================================================================================
S     * Offset: 0x08  UART FIFO Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RFR       |Rx Software Reset
S     * |        |          |When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are 
S     * |        |          |cleared.
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
S     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
S     * |[2]     |TFR       |Tx Software Reset
S     * |        |          |When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are 
S     * |        |          |cleared.
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
S     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
S     * |[7:4]   |RFITL     |Word Length Select
S     * |        |          |INTR_RDA Tigger Level(Bytes)
S     * |        |          |0000 = 01 Bytes
S     * |        |          |0001 = 04 Bytes
S     * |        |          |0010 = 08 Bytes
S     * |        |          |0011 = 14 Bytes
S     * |[8]     |RX_DIS    |Receiver Disable register.
S     * |        |          |The receiver is disabled or not (set 1 is disable receiver)
S     * |        |          |1: Disable Receiver
S     * |        |          |0: Enable Receiver
S     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before 
S     * |        |          |RS-485 enable function in UA_FUN_SEL. FUN_SEL is programmed.
S     * |[19:16] |RTS_Tri_Lev|Word Length Select
S     * |        |          |0000 = 01 Bytes
S     * |        |          |0001 = 04 Bytes
S     * |        |          |0010 = 08 Bytes
S     * |        |          |0011 = 14 Bytes
S     */    
S    __IO uint32_t FCR;                  
S
S    /**
S     * LCR
S     * ===================================================================================================
S     * Offset: 0x0C  UART Line Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WLS       |Word Length Select
S     * |        |          |00 = 5 bits
S     * |        |          |01 = 6 bits
S     * |        |          |10 = 7 bits
S     * |        |          |11 = 8 bits
S     * |[2]     |NSB       |Number of "STOP bit"
S     * |        |          |0= One "STOP bit" is generated in the transmitted data
S     * |        |          |1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
S     * |        |          |Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.
S     * |[3]     |PBE       |Parity Bit Enable
S     * |        |          |0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
S     * |        |          |1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
S     * |[4]     |EPE       |Even Parity Enable
S     * |        |          |0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
S     * |        |          |1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
S     * |        |          |This bit has effect only when bit 3 (parity bit enable) is set.
S     * |[5]     |SPE       |Stick Parity Enable 
S     * |        |          |0 = Disable stick parity 
S     * |        |          |1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When 
S     * |        |          |PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.
S     * |[6]     |BCB       |Break Control Bit 
S     * |        |          |When this bit is set to logic 1, the serial data output (Tx) is forced to the Spacing State (logic 0). This bit 
S     * |        |          |acts only on Tx and has no effect on the transmitter logic.
S     */    
S    __IO uint32_t LCR;                  
S
S    /**
S     * MCR
S     * ===================================================================================================
S     * Offset: 0x10  UART Modem Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RTS       |RTS (Request-To-Send) Signal 
S     * |        |          |0: Drive RTS pin to logic 1 (If the Lev_RTS set to low level triggered).
S     * |        |          |1: Drive RTS pin to logic 0 (If the Lev_RTS set to low level triggered).
S     * |        |          |0: Drive RTS pin to logic 0 (If the Lev_RTS set to high level triggered).
S     * |        |          |1: Drive RTS pin to logic 1 (If the Lev_RTS set to high level triggered).
S     * |[9]     |Lev_RTS   |RTS Trigger Level 
S     * |        |          |This bit can change the RTS trigger level.
S     * |        |          |0= low level triggered
S     * |        |          |1= high level triggered
S     * |[13]    |RTS_St    |RTS Pin State 
S     * |        |          |This bit is the pin status of RTS.
S     */    
S    __IO uint32_t MCR;                  
S
S    /**
S     * MSR
S     * ===================================================================================================
S     * Offset: 0x14  UART Modem Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DCTSF     |Detect CTS State Change Flag 
S     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU 
S     * |        |          |when IER [Modem_IEN].
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[4]     |CTS_St    |CTS Pin Status 
S     * |        |          |This bit is the pin status of CTS. 
S     * |[8]     |Lev_CTS   |CTS Trigger Level
S     * |        |          |This bit can change the CTS trigger level.
S     * |        |          |0= low level triggered
S     * |        |          |1= high level triggered
S     */    
S    __IO uint32_t MSR;                  
S
S    /**
S     * FSR
S     * ===================================================================================================
S     * Offset: 0x18  UART FIFO Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |Rx_Over_IF|Rx overflow Error IF (Read Only) 
S     * |        |          |This bit is set when Rx FIFO overflow.
S     * |        |          |If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 16 bytes of 
S     * |        |          |UART0/UART1, this bit will be set.
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[3]     |RS-       |485_Add_Det
S     * |        |          |RS-485 Address Byte Detection Flag
S     * |        |          |This bit is set to logic 1 and set UA_RS-485_CSR [RS-485_Add_EN] whenever in RS-485 
S     * |        |          |mode the receiver detect any address byte received address byte character (bit9 = '1') bit", 
S     * |        |          |and it is reset whenever the CPU writes 1 to this bit.
S     * |        |          |Note: This field is used for RS-485 mode.
S     * |[4]     |PEF       |Parity Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", 
S     * |        |          |and is reset whenever the CPU writes 1 to this bit.
S     * |[5]     |FEF       |Framing Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that 
S     * |        |          |is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset 
S     * |        |          |whenever the CPU writes 1 to this bit.
S     * |[6]     |BIF       |Break Interrupt Flag
S     * |        |          |This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" 
S     * |        |          |(logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data 
S     * |        |          |bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
S     * |[13:8]  |Rx_Pointer|Rx FIFO pointer (Read Only)
S     * |        |          |This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external 
S     * |        |          |device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer 
S     * |        |          |decreases one.
S     * |[14]    |Rx_Empty  |Receiver FIFO Empty (Read Only)
S     * |        |          |This bit initiate Rx FIFO empty or not.
S     * |        |          |When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be 
S     * |        |          |cleared when UART receives any new data.
S     * |[15]    |Rx_Full   |Receiver FIFO Full (Read Only)
S     * |        |          |This bit initiates Rx FIFO full or not.
S     * |        |          |This bit is set when Rx_Pointer is equal to 16(UART0/UART1), otherwise is cleared by 
S     * |        |          |hardware.
S     * |[21:16] |Tx_Pointer|TX FIFO Pointer (Read Only)
S     * |        |          |This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, 
S     * |        |          |Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift 
S     * |        |          |Register, Tx_Pointer decreases one.
S     * |[22]    |Tx_Empty  |Transmitter FIFO Empty (Read Only)
S     * |        |          |This bit indicates Tx FIFO empty or not.
S     * |        |          |When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware 
S     * |        |          |sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).
S     * |[23]    |Tx_Full   |Transmitter FIFO Full (Read Only)
S     * |        |          |This bit indicates Tx FIFO full or not.
S     * |        |          |This bit is set when Tx_Pointer is equal to 64/16(UART0/UART1), otherwise is cleared by 
S     * |        |          |hardware.
S     * |[24]    |Tx_Over_IF|Tx Overflow Error Interrupt Flag (Read Only)
S     * |        |          |If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[28]    |TE_Flag   |Transmitter Empty Flag (Read Only)
S     * |        |          |Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte 
S     * |        |          |has been transmitted.
S     * |        |          |Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not 
S     * |        |          |completed.
S     * |        |          |NOTE: This bit is read only. 
S     */    
S    __IO uint32_t FSR;                  
S
S    /**
S     * ISR
S     * ===================================================================================================
S     * Offset: 0x1C  UART Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only).
S     * |        |          |When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If 
S     * |        |          |IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
S     * |        |          |NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO 
S     * |        |          |drops below the threshold level (RFITL).
S     * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only). 
S     * |        |          |This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If 
S     * |        |          |IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and it will be cleared when writing data into THR (Tx FIFO not empty).
S     * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only).
S     * |        |          |In UART mode this bit is set when the Rx receive data have parity error, framing error or break 
S     * |        |          |error (at least one of 3 bits, BIF, FEF and PEF, is set). In RS-485 mode, the field includes RS-485 
S     * |        |          |Address Byte Detection Flag. If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS-485_Add_Det 
S     * |        |          |are cleared.
S     * |[3]     |Modem_IF  |MODEM Interrupt Flag (Read Only) 
S     * |        |          |This bit is set when the CTS pin has state change (DCTSF=1). If IER[Modem_IEN] is enabled, the 
S     * |        |          |Modem interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.
S     * |[4]     |Tout_IF   |Time Out Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Rx FIFO is not empty and no activities occur in the Rx FIFO and the time 
S     * |        |          |out counter equal to TOIC. If IER [Tout_IEN] is enabled, the Tout interrupt will be generated. 
S     * |        |          |NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.
S     * |[5]     |Buf_Err_IF|Buffer Error Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When 
S     * |        |          |Buf_Err_IF is set, the transfer maybe not correct. If IER[Buf_Err_IEN] is enabled, the buffer error 
S     * |        |          |interrupt will be generated.
S     * |        |          |NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared. 
S     * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator to Interrupt Controller (INT_RDA).
S     * |        |          |An AND output with inputs of RDA_IEN and RDA_IF
S     * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller (INT_THRE).
S     * |        |          |An AND output with inputs of THRE_IEN and THRE_IF
S     * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator to Interrupt Controller (INT_RLS). 
S     * |        |          |An AND output with inputs of RLS_IEN and RLS_IF
S     * |        |          |Note: In RS-485 mode, the field includes RS-485 Address Byte Detection Flag.
S     * |[11]    |Modem_INT |MODEM Status Interrupt Indicator to Interrupt Controller (INT_MOS). 
S     * |        |          |An AND output with inputs of Modem_IEN and Modem_IF
S     * |[12]    |Tout_INT  |Time Out Interrupt Indicator to Interrupt Controller (INT_Tout)
S     * |        |          |An AND output with inputs of RTO_IEN and Tout_IF
S     * |[13]    |Buf_Err_INT|Buffer Error Interrupt Indicator to Interrupt Controller (INT_Buf_err)
S     * |        |          |An AND output with inputs of BUF_ERR_IEN and Buf_Err_IF
S     */    
S    __IO uint32_t ISR;                  
S
S    /**
S     * TOR
S     * ===================================================================================================
S     * Offset: 0x20  UART Time Out Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6:0]   |TOIC      |Time Out Interrupt Comparator
S     * |        |          |The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO 
S     * |        |          |receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out 
S     * |        |          |interrupt comparator (TOIC), a receiver time out interrupt (INT_TOUT) is generated if UA_IER[RTO_IEN]. 
S     * |        |          |A new incoming data word or RX FIFO empty clears INT_TOUT. 
S     * |[15:8]  |DLY       |TX Delay time value
S     * |        |          |This field is use to programming the transfer delay time between the last stop bit leaving the TX-FIFO 
S     * |        |          |and the de-assertion of by setting UA_TOR. DLY register.
S     */    
S    __IO uint32_t TOR;                  
S
S    /**
S     * BAUD
S     * ===================================================================================================
S     * Offset: 0x24  UART Baud Rate Divisor Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |BRD_LowByte|Baud Rate Divider 
S     * |        |          |The low byte of the baud rate divider
S     * |[15:8]  |BRD_HighByte|Baud Rate Divider 
S     * |        |          |The high byte of the baud rate divider
S     * |[27:24] |Divider_X |Divider X
S     * |        |          |The baud rate divider M = X+1.
S     * |[28]    |DIV_X_ONE |Divider X equal 1
S     * |        |          |0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must > 8)
S     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must > 3).
S     * |[29]    |DIV_X_EN  |Divider X Enable
S     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is  
S     * |        |          |Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
S     * |        |          |0 = Disable divider X (the equation of M = 16)
S     * |        |          |1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must > 8).
S     * |        |          |NOTE: When in IrDA mode, this bit must disable.
S     */    
S    __IO uint32_t BAUD;                 
S
S    /**
S     * IRCR
S     * ===================================================================================================
S     * Offset: 0x28  UART IrDA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |Tx_SELECT |Tx_SELECT
S     * |        |          |1: Enable IrDA transmitter
S     * |        |          |0: Enable IrDA receiver
S     * |[2]     |LB        |IrDA loop back mode for self test.
S     * |        |          |1: Enable IrDA loop back mode
S     * |        |          |0: Disable IrDA loop back mode
S     * |[5]     |INV_Tx    |INV_Tx
S     * |        |          |1= Inverse Tx output signal
S     * |        |          |0= No inversion
S     * |[6]     |INV_Rx    |INV_Rx
S     * |        |          |1= Inverse Rx input signal
S     * |        |          |0= No inversion
S     */    
S    __IO uint32_t IRCR;                 
S
S    /**
S     * ALT_CSR
S     * ===================================================================================================
S     * Offset: 0x2C  UART Alternate Control/Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8]     |RS-485_NMM|RS-485 Normal Multi-drop Operation Mode (NMM)
S     * |        |          |1: Enable RS-485 Normal Multi-drop Operation Mode (NMM)
S     * |        |          |0: Disable RS-485 Normal Multi-drop Operation Mode (NMM)
S     * |        |          |Note: It can't be active with RS-485_AAD operation mode.
S     * |[9]     |RS-485_AAD|RS-485 Auto Address Detection Operation Mode (AAD)
S     * |        |          |1: Enable RS-485 Auto Address Detection Operation Mode (AAD)
S     * |        |          |0: Disable RS-485 Auto Address Detection Operation Mode (AAD)
S     * |        |          |Note: It can't be active with RS-485_NMM operation mode.
S     * |[10]    |RS-485_AUD|RS-485 Auto Direction Mode (AUD)
S     * |        |          |1: Enable RS-485 Auto Direction Mode (AUD)
S     * |        |          |0: Disable RS-485 Auto Direction Mode (AUD)
S     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
S     * |[15]    |RS-485_Add_EN|RS-485 Address Detection Enable
S     * |        |          |This bit is use to enable RS-485 address detection mode. 
S     * |        |          |1: Enable address detection mode
S     * |        |          |0: Disable address detection mode 
S     * |        |          |Note: This field is used for RS-485 any operation mode.
S     * |[31:24] |ADDR_MATCH|Address match value register
S     * |        |          |This field contains the RS-485 address match values.
S     * |        |          |Note: This field is used for RS-485 auto address detection mode.
S     */    
S    __IO uint32_t ALT_CSR;               
S
S    /**
S     * FUNSEL
S     * ===================================================================================================
S     * Offset: 0x30  UART Function Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |FUN_SEL   |Function Select Enable
S     * |        |          |00 = UART Function.
S     * |        |          |01 = Reserved.
S     * |        |          |10 = Enable IrDA Function.
S     * |        |          |11 = Enable RS-485 Function.
S     */    
S    __IO uint32_t FUNSEL;               
S} UART_T;
S
S
S
S
S/* UART THR Bit Field Definitions */
S#define UART_THR_THR_Pos         0                                          /*!< UART THR: THR Position  */
S#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART THR: THR Mask      */
S
S/* UART RBR Bit Field Definitions */
S#define UART_RBR_RBR_Pos         0                                          /*!< UART RBR: RBR Posistion */
S#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART RBR: RBR Mask      */
S
S/* UART IER Bit Field Definitions */
S#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART IER: AUTO_CTS_EN Posistion      */
S#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART IER: AUTO_CTS_EN Mask           */
S
S#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART IER: AUTO_RTS_EN Posistion      */
S#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART IER: AUTO_RTS_EN Mask           */
S
S#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART IER: TIME_OUT_EN Posistion      */
S#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART IER: TIME_OUT_EN Mask           */
S
S#define UART_IER_LIN_RX_BRK_IEN_Pos 8                                       /*!< UART IER: LIN_RX_BRK_IEN Posistion   */
S#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)    /*!< UART IER: LIN_RX_BRK_IEN Mask        */
S
S#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART IER: WAKE_EN Posistion          */
S#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART IER: WAKE_EN Mask               */
S
S#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART IER: BUF_ERR_IEN Posistion      */
S#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART IER: BUF_ERR_IEN Mask           */
S
S#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART IER: RTO_IEN Posistion          */
S#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART IER: RTO_IEN Mask               */
S
S#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART IER: MODEM_IEN Posistion        */
S#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART IER: MODEM_IEN Mask             */
S
S#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART IER: RLS_IEN Posistion          */
S#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART IER: RLS_IEN Mask               */
S
S#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART IER: THRE_IEN Posistion         */
S#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART IER: THRE_IEN Mask              */
S
S#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART IER: RDA_IEN Position           */
S#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART IER: RDA_IEN Mask               */
S
S/* UART FCR Bit Field Definitions */
S#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART FCR: RTS_TRI_LEV Position       */
S#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART FCR: RTS_TRI_LEV Mask           */
S
S#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART FCR: RX_DIS Position            */
S#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART FCR: RX_DIS Mask                */
S
S#define UART_FCR_RFITL_Pos          4                                       /*!< UART FCR: RFITL Position             */
S#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART FCR: RFITL Mask                 */
S
S#define UART_FCR_TFR_Pos            2                                       /*!< UART FCR: TFR Position               */
S#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART FCR: TFR Mask                   */
S
S#define UART_FCR_RFR_Pos            1                                       /*!< UART FCR: RFR Position               */
S#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART FCR: RFR Mask                   */
S
S/* UART LCR Bit Field Definitions */
S#define UART_LCR_BCB_Pos            6                                       /*!< UART LCR: BCB Position               */
S#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART LCR: BCB Mask                   */
S
S#define UART_LCR_SPE_Pos            5                                       /*!< UART LCR: SPE Position               */
S#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART LCR: SPE Mask                   */
S
S#define UART_LCR_EPE_Pos            4                                       /*!< UART LCR: EPE Position               */
S#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART LCR: EPE Mask                   */
S
S#define UART_LCR_PBE_Pos            3                                       /*!< UART LCR: PBE Position               */
S#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART LCR: PBE Mask                   */
S
S#define UART_LCR_NSB_Pos            2                                       /*!< UART LCR: NSB Position               */
S#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART LCR: NSB Mask                   */
S
S#define UART_LCR_WLS_Pos            0                                       /*!< UART LCR: WLS Position               */
S#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART LCR: WLS Mask                   */
S
S/* UART MCR Bit Field Definitions */
S#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART MCR: RTS_ST Position            */
S#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART MCR: RTS_ST Mask                */
S
S#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART MCR: LEV_RTS Position           */
S#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART MCR: LEV_RTS Mask               */
S
S#define UART_MCR_RTS_Pos            1                                       /*!< UART MCR: RTS Position               */
S#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART MCR: RTS Mask                   */
S
S
S/* UART MSR Bit Field Definitions */
S#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART MSR: LEV_CTS Position           */
S#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART MSR: LEV_CTS Mask               */
S
S#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART MSR: CTS_ST Position            */
S#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART MSR: CTS_ST Mask                */
S
S#define UART_MSR_DCTSF_Pos          0                                       /*!< UART MSR: DCTST Position             */
S#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART MSR: DCTST Mask                 */
S
S
S/* UART FSR Bit Field Definitions */
S#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART FSR: TE_FLAG Position           */
S#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART FSR: TE_FLAG Mask               */
S
S#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART FSR: TX_OVER_IF Position        */
S#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART FSR: TX_OVER_IF Mask            */
S
S#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART FSR: TX_FULL Position           */
S#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART FSR: TX_FULL Mask               */
S
S#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART FSR: TX_EMPTY Position          */
S#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART FSR: TX_EMPTY Mask              */
S
S#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART FSR: TX_POINTER Position        */
S#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART FSR: TX_POINTER Mask            */
S
S#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART FSR: RX_FULL Position           */
S#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART FSR: RX_FULL Mask               */
S
S#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART FSR: RX_EMPTY Position          */
S#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART FSR: RX_EMPTY Mask              */
S
S#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART FSR: RX_POINTERS Position       */
S#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART FSR: RX_POINTER Mask            */
S
S#define UART_FSR_BIF_Pos            6                                       /*!< UART FSR: BIF Position               */
S#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART FSR: BIF Mask                   */
S
S#define UART_FSR_FEF_Pos            5                                       /*!< UART FSR: FEF Position               */
S#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART FSR: FEF Mask                   */
S
S#define UART_FSR_PEF_Pos            4                                       /*!< UART FSR: PEF Position               */
S#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART FSR: PEF Mask                   */
S
S#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART FSR: RS485_ADD_DETF Position    */
S#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART FSR: RS485_ADD_DETF Mask        */
S
S#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART FSR: RX_OVER_IF Position        */
S#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART FSR: RX_OVER_IF Mask            */
S
S/* UART ISR Bit Field Definitions */
S#define UART_ISR_LIN_RX_BREAK_INT_Pos    15                                      /*!< UART ISR: LIN_RX_BREAK_INT Position       */
S#define UART_ISR_LIN_RX_BREAK_INT_Msk    (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)  /*!< UART ISR: LIN_RX_BREAK_INT Mask           */
S
S#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART ISR: BUF_ERR_INT Position       */
S#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART ISR: BUF_ERR_INT Mask           */
S
S#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART ISR: TOUT_INT Position          */
S#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART ISR: TOUT_INT Mask              */
S
S#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART ISR: MODEM_INT Position         */
S#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART ISR: MODEM_INT Mask             */
S
S#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART ISR: RLS_INT Position           */
S#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART ISR: RLS_INT Mask               */
S
S#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART ISR: THRE_INT Position          */
S#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART ISR: THRE_INT Mask              */
S
S#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART ISR: RDA_INT Position           */
S#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART ISR: RDA_INT Mask               */
S
S#define UART_ISR_LIN_RX_BREAK_IF_Pos 7                                      /*!< UART ISR: LIN RX BREAK IF Position   */
S#define UART_ISR_LIN_RX_BREAK_IF_Msk (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)  /*!< UART ISR: LIN RX BREAK IF Mask       */
S           
S#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART ISR: BUF_ERR_IF Position        */
S#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART ISR: BUF_ERR_IF Mask            */
S
S#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART ISR: TOUT_IF Position           */
S#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART ISR: TOUT_IF Mask               */
S
S#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART ISR: MODEM_IF Position          */
S#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART ISR: MODEM_IF Mask              */
S
S#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART ISR: RLS_IF Position            */
S#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART ISR: RLS_IF Mask                */
S
S#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART ISR: THRE_IF Position           */
S#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART ISR: THRE_IF Mask               */
S
S#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART ISR: RDA_IF Position            */
S#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART ISR: RDA_IF Mask                */
S
S
S/* UART TOR Bit Field Definitions */
S#define UART_TOR_DLY_Pos           8                                        /*!< UART TOR: DLY Position               */
S#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART TOR: DLY Mask                   */
S
S#define UART_TOR_TOIC_Pos          0                                        /*!< UART TOR: TOIC Position              */
S#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)            /*!< UART TOR: TOIC Mask                  */
S
S/* UART BAUD Bit Field Definitions */
S#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
S#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
S
S#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
S#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
S
S#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
S#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
S
S#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
S#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
S
S/* UART IRCR Bit Field Definitions */
S#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART IRCR: INV_RX Position           */
S#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART IRCR: INV_RX Mask               */
S
S#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART IRCR: INV_TX Position           */
S#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART IRCR: INV_TX Mask               */
S
S#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART IRCR: TX_SELECT Position        */
S#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART IRCR: TX_SELECT Mask            */
S
S/* UART ALT_CSR Bit Field Definitions */
S#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART ALT_CSR: ADDR_MATCH Position    */
S#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART ALT_CSR: ADDR_MATCH Mask        */
S
S#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART ALT_CSR: RS485_ADD_EN Position  */
S#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART ALT_CSR: RS485_ADD_EN Mask      */
S
S#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART ALT_CSR: RS485_AUD Position     */
S#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART ALT_CSR: RS485_AUD Mask         */
S
S#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART ALT_CSR: RS485_AAD Position     */
S#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART ALT_CSR: RS485_AAD Mask         */
S
S#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART ALT_CSR: RS485_NMM Position     */
S#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART ALT_CSR: RS485_NMM Mask         */
S
S#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART ALT_CSR: LIN TX Break Mode Enable Position     */
S#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART ALT_CSR: LIN TX Break Mode Enable Mask         */
S
S#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART ALT_CSR: LIN RX Enable Position     */
S#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART ALT_CSR: LIN RX Enable Mask         */
S
S#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART ALT_CSR: UART LIN Break Field Length Position     */
S#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART ALT_CSR: UART LIN Break Field Length Mask         */
S
S
S/* UART FUN_SEL Bit Field Definitions */
S#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART FUN_SEL: FUN_SEL Position       */
S#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART FUN_SEL: FUN_SEL Mask           */
S
S/*@}*/ /* end of group M051_UART */
S
S
S/*----------------------------- TIMER Controller -----------------------------*/
S/** @addtogroup M051_TIMER M051 TIMER
S  Memory Mapped Structure for M051 Series Timer Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * TCSR
S     * ===================================================================================================
S     * Offset: 0x00  Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |PRESCALE  |Pre-scale Counter
S     * |        |          |Clock input is divided by PRESCALE+1 before it is fed to the counter. If 
S     * |        |          |PRESCALE=0, then there is no scaling.
S     * |[16]    |TDR_EN    |Data Load Enable
S     * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with 
S     * |        |          |the 24-bit up-timer value as the timer is counting. 
S     * |        |          |1 = Timer Data Register update enable.
S     * |        |          |0 = Timer Data Register update disable. 
S     * |[25]    |CACT      |Timer Active Status Bit (Read only)
S     * |        |          |This bit indicates the up-timer status.
S     * |        |          |0 = Timer is not active.
S     * |        |          |1 = Timer is active.
S     * |[26]    |CRST      |Timer Reset Bit
S     * |        |          |Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 
S     * |        |          |0.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.
S     * |[28:27] |MODE      |Timer Operating Mode
S     * |        |          |00 =
S     * |        |          |The timer is operating in the one-shot mode. The associated 
S     * |        |          |interrupt signal is generated once (if IE is enabled) and CEN is 
S     * |        |          |automatically cleared by hardware.
S     * |        |          |01 =
S     * |        |          |The timer is operating in the periodic mode. The associated 
S     * |        |          |interrupt signal is generated periodically (if IE is enabled).
S     * |        |          |10 =
S     * |        |          |The timer is operating in the toggle mode. The interrupt signal is 
S     * |        |          |generated periodically (if IE is enabled). And the associated 
S     * |        |          |signal (tout) is changing back and forth with 50% duty cycle.
S     * |        |          |11 =
S     * |        |          |Reserved 
S     * |[29]    |IE        |Interrupt Enable Bit
S     * |        |          |1 = Enable timer Interrupt.
S     * |        |          |0 = Disable timer Interrupt. 
S     * |        |          |If timer interrupt is enabled, the timer asserts its interrupt signal when the associated 
S     * |        |          |up-timer value is equal to TCMPR.
S     * |[30]    |CEN       |Timer Enable Bit
S     * |        |          |1 = Starts counting
S     * |        |          |0 = Stops/Suspends counting
S     * |        |          |Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up 
S     * |        |          |counting from the last stop counting value.
S     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) 
S     * |        |          |when the associated timer interrupt is generated (IE[29]=1).
S     */    
S    __IO uint32_t  TCSR;                
S
S    /**
S     * TCMPR
S     * ===================================================================================================
S     * Offset: 0x04  Timer Compare Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |TCMP      |Timer Compared Value
S     * |        |          |TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value 
S     * |        |          |is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with 
S     * |        |          |TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
S     * |        |          |Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
S     * |        |          |NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
S     * |        |          |NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, 
S     * |        |          |TIMER will restart counting using this new value and abort previous count.
S     */    
S    __IO uint32_t  TCMPR;		        
S
S    /**
S     * TISR
S     * ===================================================================================================
S     * Offset: 0x08  Timer Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TIF       |Timer Interrupt Flag
S     * |        |          |This bit indicates the interrupt status of Timer.
S     * |        |          |TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer 
S     * |        |          |compared value (TCMP). It is cleared by writing 1 to this bit.
S     */    
S    __IO uint32_t  TISR;		        
S
S    /**
S     * TDR
S     * ===================================================================================================
S     * Timer Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |TDR       |Timer Data Register
S     * |        |          |When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. 
S     * |        |          |User can read this register for the up-timer value.
S     */    
S    __IO uint32_t  TDR;			        
S
S    /**
S     * TCAP
S     * ===================================================================================================
S     * Timer Capture Data Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TCAP;		        
S
S    /**
S     * TEXCON
S     * ===================================================================================================
S     * Offset: 0x14  Timer External Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TEXCON;	            
S
S    /**
S     * TEXISR
S     * ===================================================================================================
S     * Offset: 0x14  Timer External Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TEXISR;	            
S} TIMER_T;
S
S/* TIMER TCSR Bit Field Definitions */
S#define TIMER_TCSR_DBGACK_TMR_Pos   31											/*!< TIMER TCSR: DBGACK_TMR Position */
S#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER TCSR: DBGACK_TMR Mask */
S
S#define TIMER_TCSR_CEN_Pos          30											/*!< TIMER TCSR: CEN Position */
S#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)				    /*!< TIMER TCSR: CEN Mask */
S
S#define TIMER_TCSR_IE_Pos           29											/*!< TIMER TCSR: IE Position */
S#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)					/*!< TIMER TCSR: IE Mask */
S                                                                                 
S#define TIMER_TCSR_MODE_Pos         27											/*!< TIMER TCSR: MODE Position */
S#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)				/*!< TIMER TCSR: MODE Mask */
S
S#define TIMER_TCSR_CRST_Pos         26											/*!< TIMER TCSR: CRST Position */
S#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)				/*!< TIMER TCSR: CRST Mask */
S
S#define TIMER_TCSR_CACT_Pos         25											/*!< TIMER TCSR: CACT Position */
S#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)				/*!< TIMER TCSR: CACT Mask */
S
S#define TIMER_TCSR_CTB_Pos          24											/*!< TIMER TCSR: CTB Position */
S#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)					/*!< TIMER TCSR: CTB Mask */
S
S#define TIMER_TCSR_WAKE_EN_Pos      23											/*!< TIMER TCSR: WAKE_EN Position */
S#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)			    /*!< TIMER TCSR: WAKE_EN Mask */
S
S#define TIMER_TCSR_CAP_SRC_Pos      22											/*!< TIMER TCSR: CAP_SRC Position */
S#define TIMER_TCSR_CAP_SRC_Msk      (1ul << TIMER_TCSR_CAP_SRC_Pos)			    /*!< TIMER TCSR: CAP_SRC Mask */
S
S#define TIMER_TCSR_TOGGLE_PIN_Pos   21											/*!< TIMER TCSR: TOGGLE_PIN Position */
S#define TIMER_TCSR_TOGGLE_PIN_Msk   (1ul << TIMER_TCSR_TOGGLE_PIN_Pos)		    /*!< TIMER TCSR: TOGGLE_PIN Mask */
S
S#define TIMER_TCSR_ERIODIC_SEL_Pos  20											/*!< TIMER TCSR: PERIODIC_SEL Position */
S#define TIMER_TCSR_ERIODIC_SEL_Msk  (1ul << TIMER_TCSR_ERIODIC_SEL_Pos)		    /*!< TIMER TCSR: PERIODIC_SEL Mask */
S
S#define TIMER_TCSR_INTR_TRG_EN_Pos  19											/*!< TIMER TCSR: INTR_TRG_EN Position */
S#define TIMER_TCSR_INTR_TRG_EN_Msk  (1ul << TIMER_TCSR_INTR_TRG_EN_Pos)		    /*!< TIMER TCSR: INTR_TRG_EN Mask */
S
S#define TIMER_TCSR_TDR_EN_Pos       16											/*!< TIMER TCSR: TDR_EN Position */
S#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)				/*!< TIMER TCSR: TDR_EN Mask */
S
S#define TIMER_TCSR_PRESCALE_Pos     0											/*!< TIMER TCSR: PRESCALE Position */
S#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)			/*!< TIMER TCSR: PRESCALE Mask */
S
S/* TIMER TCMPR Bit Field Definitions */
S#define TIMER_TCMP_TCMP_Pos         0											/*!< TIMER TCMPR: TCMP Position */
S#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)		    /*!< TIMER TCMPR: TCMP Mask */
S
S/* TIMER TISR Bit Field Definitions */
S#define TIMER_TISR_TWF_Pos          1											/*!< TIMER TISR: TWF Position */
S#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)					/*!< TIMER TISR: TWF Mask */
S
S#define TIMER_TISR_TIF_Pos          0											/*!< TIMER TISR: TIF Position */
S#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)					/*!< TIMER TISR: TIF Mask */
S
S/* TIMER TDR Bit Field Definitions */
S#define TIMER_TDR_TDR_Pos           0								            /*!< TIMER TDR: TDR Position */
S#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)	        /*!< TIMER TDR: TDR Mask */
S
S/* TIMER TCAP Bit Field Definitions */
S#define TIMER_TCAP_TCAP_Pos         0									        /*!< TIMER TCAP: TCAP Position */
S#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER TCAP: TCAP Mask */
S
S/* TIMER TEXCON Bit Field Definitions */
S#define TIMER_TEXCON_TCDB_Pos       7											/*!< TIMER TEXCON: TCDB Position */
S#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)				/*!< TIMER TEXCON: TCDB Mask */
S
S#define TIMER_TEXCON_TEXDB_Pos      6											/*!< TIMER TEXCON: TEXDB Position */
S#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)				/*!< TIMER TEXCON: TEXDB Mask */
S
S#define TIMER_TEXCON_TEXIEN_Pos     5											/*!< TIMER TEXCON: TEXIEN Position */
S#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)			/*!< TIMER TEXCON: TEXIEN Mask */
S
S#define TIMER_TEXCON_RSTCAPSEL_Pos  4											/*!< TIMER TEXCON: RSTCAPSEL Position */
S#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)			/*!< TIMER TEXCON: RSTCAPSEL Mask */
S
S#define TIMER_TEXCON_TEXEN_Pos      3											/*!< TIMER TEXCON: TEXEN Position */
S#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)				/*!< TIMER TEXCON: TEXEN Mask */
S
S#define TIMER_TEXCON_TEX_EDGE_Pos   1											/*!< TIMER TEXCON: TEX_EDGE Position */
S#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)		/*!< TIMER TEXCON: TEX_EDGE Mask */
S
S#define TIMER_TEXCON_TX_PHASE_Pos   0											/*!< TIMER TEXCON: TX_PHASE Position */
S#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)			/*!< TIMER TEXCON: TX_PHASE Mask */
S
S/* TIMER TEXISR Bit Field Definitions */
S#define TIMER_TEXISR_TEXIF_Pos      0											/*!< TIMER TEXISR: TEXIF Position */
S#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)				/*!< TIMER TEXISR: TEXIF Mask */
S/*@}*/ /* end of group M051_TIMER */
S
S
S/*----------------------------- WDT Controller -----------------------------*/
S/** @addtogroup M051_WDT M051 WDT
S  Memory Mapped Structure for M051 Series Watchdog Timer
S  @{
S */
Stypedef struct
S{
S    /**
S     * WTCR
S     * ===================================================================================================
S     * Offset: 0x00  Watchdog Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WTR       |Clear Watchdog Timer 
S     * |        |          |Set this bit will clear the Watchdog timer. 
S     * |        |          |0= Writing 0 to this bit has no effect
S     * |        |          |1= Reset the contents of the Watchdog timer
S     * |        |          |NOTE: This bit will auto clear after few clock cycle
S     * |[1]     |WTRE      |Watchdog Timer Reset Enable
S     * |        |          |Setting this bit will enable the Watchdog timer reset function.
S     * |        |          |0= Disable Watchdog timer reset function
S     * |        |          |1= Enable Watchdog timer reset function
S     * |[2]     |WTRF      |Watchdog Timer Reset Flag
S     * |        |          |When the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by 
S     * |        |          |software to determine the source of reset. Software is responsible to clear it manually by writing 1 to 
S     * |        |          |it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.
S     * |        |          |0= Watchdog timer reset does not occur
S     * |        |          |1= Watchdog timer reset occurs
S     * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
S     * |[3]     |WTIF      |Watchdog Timer Interrupt Flag
S     * |        |          |If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the 
S     * |        |          |Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit 
S     * |        |          |indicates that a timeout period has elapsed.
S     * |        |          |0= Watchdog timer interrupt does not occur
S     * |        |          |1= Watchdog timer interrupt occurs
S     * |        |          |NOTE: Write 1 to clear this bit to zero.
S     * |[4]     |WTWKE     |Watchdog Timer Wakeup Function Enable bit
S     * |        |          |0 = Disable Watchdog timer Wakeup CPU function.
S     * |        |          |1 = Enable the Wakeup function that Watchdog timer timeout can wake up CPU from power-down 
S     * |        |          |mode.
S     * |[5]     |WTWKF     |Watchdog Timer Wakeup Flag
S     * |        |          |If Watchdog timer causes CPU wakes up from power-down mode, this bit will be set to high. It must 
S     * |        |          |be cleared by software with a write 1 to this bit.
S     * |        |          |1 = CPU wake up from sleep or power-down mode by Watchdog timeout.
S     * |        |          |0 = Watchdog timer does not cause CPU wakeup.
S     * |        |          |NOTE: Write 1 to clear this bit to zero.
S     * |[6]     |WTIE      |Watchdog Timer Interrupt Enable
S     * |        |          |0= Disable the Watchdog timer interrupt
S     * |        |          |1= Enable the Watchdog timer interrupt
S     * |[7]     |WTE       |Watchdog Timer Enable
S     * |        |          |0= Disable the Watchdog timer (This action will reset the internal counter)
S     * |        |          |1= Enable the Watchdog timer
S     * |[10:8]  |WTIS      |Watchdog Timer Interval Select (write protection bit)
S     * |        |          |These three bits select the timeout interval for the Watchdog timer. 
S     */    
S    __IO uint32_t  WTCR;                 
S
S    /**
S     * WTCRALT
S     * ===================================================================================================
S     * Offset: 0x04  Watchdog Timer Alternative Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WTCRALT;              
S} WDT_T;
S
S/* WDT WTCR Bit Field Definitions */
S#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT WTCR : DBGACK_WDT Position */
S#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT WTCR : DBGACK_WDT Mask */
S
S#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT WTCR : WTIS Position */
S#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT WTCR : WTIS Mask */
S
S#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT WTCR : WTE Position */
S#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT WTCR : WTE Mask */
S
S#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT WTCR : WTIE Position */
S#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT WTCR : WTIE Mask */
S
S#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT WTCR : WTWKF Position */
S#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT WTCR : WTWKF Mask */
S
S#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT WTCR : WTWKE Position */
S#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT WTCR : WTWKE Mask */
S
S#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT WTCR : WTIF Position */
S#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT WTCR : WTIF Mask */
S
S#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT WTCR : WTRF Position */
S#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT WTCR : WTRF Mask */
S
S#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT WTCR : WTRE Position */
S#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT WTCR : WTRE Mask */
S
S#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT WTCR : WTR Position */
S#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT WTCR : WTR Mask */
S
S/* WDT WTCRALT Bit Field Definitions */
S#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT WTCRALT : WTRDSEL Position */
S#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT WTCRALT : WTRDSEL Mask */
S/*@}*/ /* end of group M051_WDT */
S
S
S/*----------------------------- WWDT Controller -----------------------------*/
S/** @addtogroup M051_WWDT M051 WWDT
S  Memory Mapped Structure for M051 Series Window Watchdog Timer
S  @{
S */
Stypedef struct
S{
S    /**
S     * WWDTRLD
S     * ===================================================================================================
S     * WWDT Reload Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WWDTRLD;
S
S    /**
S     * WWDTCR
S     * ===================================================================================================
S     * Offset: 0x04  Window Watchdog Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WWDTCR;
S
S    /**
S     * WWDTSR
S     * ===================================================================================================
S     * Offset: 0x08  Window Watchdog Timer Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WWDTSR;
S
S    /**
S     * WWDTCVR
S     * ===================================================================================================
S     * Offset: 0x0C  Watchdog Timer Alternative Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WWDTCVR;
S
S} WWDT_T;
S
S/* WWDT WWDTRLD Bit Field Definitions */
S#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT WWDTRLD : WWDTRLD Position */
S#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT WWDTRLD : WWDTRLD Mask */
S
S/* WWDT WWDTCR Bit Field Definitions */
S#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT WWDTCR : DBGACK_WWDT Position */
S#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT WWDTCR : DBGACK_WWDT Mask */
S
S#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT WWDTCR : WINCMP Position */
S#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT WWDTCR : WINCMP Mask */
S
S#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT WWDTCR : PERIODSEL Position */
S#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT WWDTCR : PERIODSEL Mask */
S
S#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT WWDTCR : WWDTIE Position */
S#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT WWDTCR : WWDTIE Mask */
S
S#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT WWDTCR : WWDTEN Position */
S#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_PERIODSEL_Pos)          /*!< WWDT WWDTCR : WWDTEN Mask */
S
S/* WWDT WWDTSR Bit Field Definitions */
S#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT WWDTSR : WWDTRF Position */
S#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT WWDTSR : WWDTRF Mask */
S
S#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT WWDTSR : WWDTIF Position */
S#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT WWDTSR : WWDTIF Mask */
S
S/* WWDT WWDTCVR Bit Field Definitions */
S#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT WWDTCVR : WWDTRF Position */
S#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT WWDTCVR : WWDTRF Mask */
S/*@}*/ /* end of group M051_WWDT */
S
S
S/*------------------------- SPI Interface Controller -------------------------*/
S/** @addtogroup M051_SPI M051 SPI
S  Memory Mapped Structure for M051 Series SPI Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * CNTRL
S     * ===================================================================================================
S     * Offset: 0x00  SPI Control and Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GO_BUSY   |Go and Busy Status
S     * |        |          |1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave 
S     * |        |          |mode, writing 1 to this bit indicates that the slave is ready to communicate with a 
S     * |        |          |master.
S     * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
S     * |        |          |During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will 
S     * |        |          |be cleared automatically.
S     * |        |          |NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The 
S     * |        |          |transfer result will be unpredictable if software changes related settings when 
S     * |        |          |GO_BUSY bit is 1.
S     * |[1]     |RX_NEG    |Receive At Negative Edge
S     * |        |          |1 = The received data input signal is latched at the falling edge of SPICLK.
S     * |        |          |0 = The received data input signal is latched at the rising edge of SPICLK.
S     * |[2]     |TX_NEG    |Transmit At Negative Edge
S     * |        |          |1 = The transmitted data output signal is changed at the falling edge of SPICLK.
S     * |        |          |0 = The transmitted data output signal is changed at the rising edge of SPICLK.
S     * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
S     * |        |          |This field specifies how many bits are transmitted in one transaction. Up to 32 bits 
S     * |        |          |can be transmitted.
S     * |        |          |TX_BIT_LEN = 0x01 ... 1 bit
S     * |        |          |TX_BIT_LEN = 0x02 ... 2 bits
S     * |        |          |......
S     * |        |          |TX_BIT_LEN = 0x1f ... 31 bits
S     * |        |          |TX_BIT_LEN = 0x00 .. 32 bits
S     * |[9:8]   |TX_NUM    |Numbers of Transmit/Receive Word
S     * |        |          |This field specifies how many transmit/receive word numbers should be executed 
S     * |        |          |in one transfer.
S     * |        |          |00 = Only one transmit/receive word will be executed in one transfer.
S     * |        |          |01 = Two successive transmit/receive words will be executed in one transfer. (burst 
S     * |        |          |mode)
S     * |        |          |10 = Reserved.
S     * |        |          |11 = Reserved.
S     * |[10]    |LSB       |LSB First
S     * |        |          |1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received 
S     * |        |          |from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
S     * |        |          |0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 
S     * |        |          |register that is depends on the TX_BIT_LEN field).
S     * |[11]    |CLKP      |Clock Polarity
S     * |        |          |1 = SPICLK idle high.
S     * |        |          |0 = SPICLK idle low.
S     * |[15:12] |SP_CYCLE  |Suspend Interval (master only)
S     * |        |          |These four bits provide configurable suspend interval between two successive 
S     * |        |          |transmit/receive transactions in a transfer. The suspend interval is from the last 
S     * |        |          |falling clock edge of the current transaction to the first rising clock edge of the 
S     * |        |          |successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock 
S     * |        |          |edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, 
S     * |        |          |setting this field has no effect on transfer. The desired suspend interval is obtained 
S     * |        |          |according to the following equation:
S     * |        |          |(SP_CYCLE[3:0] + 2)*period of SPI clock
S     * |        |          |SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
S     * |        |          |SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
S     * |        |          |......
S     * |        |          |SP_CYCLE = 0xe ... 16 SPICLK clock cycle
S     * |        |          |SP_CYCLE = 0xf ... 17 SPICLK clock cycle
S     * |[16]    |IF        |Interrupt Flag
S     * |        |          |1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
S     * |        |          |0 = It indicates that the transfer does not finish yet.
S     * |        |          |NOTE: This bit can be cleared by writing 1 to itself.
S     * |[17]    |IE        |Interrupt Enable
S     * |        |          |1 = Enable MICROWIRE/SPI Interrupt.
S     * |        |          |0 = Disable MICROWIRE/SPI Interrupt.
S     * |[18]    |SLAVE     |SLAVE Mode Indication
S     * |        |          |1 = Slave mode.
S     * |        |          |0 = Master mode.
S     * |[20:19] |REORDER   |Reorder Mode Select
S     * |        |          |00 = Disable both byte reorder and byte suspend functions.
S     * |        |          |01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK 
S     * |        |          |cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. 
S     * |        |          |(32 bits/word).
S     * |        |          |10 = Enable byte reorder function, but disable byte suspend function.
S     * |        |          |11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK 
S     * |        |          |cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. 
S     * |        |          |(32 bits/word).
S     * |        |          |Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.
S     * |[23]    |VARCLK_EN |Variable Clock Enable (master only)
S     * |        |          |1 = The serial clock output frequency is variable. The output frequency is decided 
S     * |        |          |by the value of VARCLK, DIVIDER, and DIVIDER2.
S     * |        |          |0 = The serial clock output frequency is fixed and decided only by the value of 
S     * |        |          |DIVIDER. 
S     * |        |          |Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be 
S     * |        |          |programmed as 0x10 (16 bits mode)
S     */    
S    __IO uint32_t CNTRL;
S
S    /**
S     * DIVIDER
S     * ===================================================================================================
S     * Offset: 0x04  SPI Clock Divider Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |DIVIDER   |Clock Divider Register (master only) 
S     * |        |          |The value in this field is the frequency divider of the system clock, PCLK, to generate 
S     * |        |          |the serial clock on the output SPICLK. The desired frequency is obtained according to 
S     * |        |          |the following equation:
S     * |        |          |fsclk = fpclk / ((DIVIDER+1)*2)
S     * |        |          |In slave mode, the period of SPI clock driven by a master shall equal or over 5 times 
S     * |        |          |the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of 
S     * |        |          |the frequency of slave's PCLK.
S     * |[31:16] |DIVIDER2  |Clock Divider 2 Register (master only) 
S     * |        |          |The value in this field is the 2nd frequency divider of the system clock, PCLK, to 
S     * |        |          |generate the serial clock on the output SPICLK. The desired frequency is obtained 
S     * |        |          |according to the following equation:
S     * |        |          |fsclk = fpclk / ((DIVIDER2+1)*2)
S     */    
S    __IO uint32_t DIVIDER;
S
S    /**
S     * SSR
S     * ===================================================================================================
S     * Offset: 0x08  SPI Slave Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SSR       |Slave Select Register (master only)
S     * |        |          |If AUTOSS bit is cleared, writing 1 to this bit sets the SPISSx line to active state and 
S     * |        |          |writing 0 sets the line back to inactive state.
S     * |        |          |If AUTOSS bit is set, writing 1 to this bit will select the SPISSx line to be automatically 
S     * |        |          |driven to active state for the duration of the transmit/receive, and will be driven to 
S     * |        |          |inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in 
S     * |        |          |SS_LVL).
S     * |[2]     |SS_LVL    |Slave Select Active Level
S     * |        |          |It defines the active level of slave select signal (SPISSx). 
S     * |        |          |1 = The slave select signal SPISSx is active at high-level/rising-edge.
S     * |        |          |0 = The slave select signal SPISSx is active at low-level/falling-edge.
S     * |[3]     |AUTOSS    |Automatic Slave Select (master only)
S     * |        |          |1 = If this bit is set, SPISSx signal is generated automatically. It means that slave 
S     * |        |          |select signal will be asserted by the SPI controller when transmit/receive is started by 
S     * |        |          |setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
S     * |        |          |0 = If this bit is cleared, slave select signal will be asserted and de-asserted by setting 
S     * |        |          |and clearing SSR[0].
S     * |[4]     |SS_LTRIG  |Slave Select Level Trigger (slave only)
S     * |        |          |1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the 
S     * |        |          |signal is active low or active high.
S     * |        |          |0: The input slave select signal is edge-trigger. This is default value.
S     * |[5]     |LTRIG_FLAG|Level Trigger Flag
S     * |        |          |When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the 
S     * |        |          |received bit number is met the requirement or not.
S     * |        |          |1 = The transaction number and the transferred bit length met the specified 
S     * |        |          |requirements which defined in TX_NUM and TX_BIT_LEN.
S     * |        |          |0 = The transaction number or the transferred bit length of one transaction doesn't 
S     * |        |          |meet the specified requirements.
S     * |        |          |Note: This bit is READ only
S     */    
S    __IO uint32_t SSR;
S
S    /**
S     * RESERVE0
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t RESERVE0;
S
S    /**
S     * SPI_RX0, SPI_RX1
S     * ===================================================================================================
S     * Offset: 0x10, 0x14  Data Receive Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |RX        |Data Receive Register
S     * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer. The 
S     * |        |          |number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For 
S     * |        |          |example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the 
S     * |        |          |received data.
S     * |        |          |NOTE: The Data Receive Registers are read only registers.
S     */    
S    __I  uint32_t RX[2];
S
S    /**
S     * RESERVE1
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t RESERVE1;
S
S    /**
S     * RESERVE2
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t RESERVE2;
S
S    /**
S     * SPI_TX0, SPI_TX1
S     * ===================================================================================================
S     * Offset: 0x20, 0x24  Data Transmit Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |TX        |Data Transmit Register
S     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer. The number 
S     * |        |          |of valid bits depend on the transmit bit length field in the CNTRL register. 
S     * |        |          |For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be 
S     * |        |          |transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will 
S     * |        |          |perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], 
S     * |        |          |TX1[31:0]).
S     */    
S    __O  uint32_t TX[2];
S
S    /**
S     * RESERVE3
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t RESERVE3;
S
S    /**
S     * RESERVE4
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t RESERVE4;
S
S    /**
S     * RESERVE5
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t RESERVE5;
S
S    /**
S     * VARCLK
S     * ===================================================================================================
S     * Offset: 0x34  Variable Clock Pattern Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |VARCLK    |Variable Clock Pattern 
S     * |        |          |The value in this field is the frequency patterns of the SPI clock. If the bit patterns of 
S     * |        |          |VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If 
S     * |        |          |the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value 
S     * |        |          |of DIVIDER2. Refer to register SPI_DIVIDER.
S     */    
S    __IO uint32_t VARCLK;
S
S    /**
S     * RESERVE6
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t RESERVE6;
S
S    /**
S     * CNTRL2
S     * ===================================================================================================
S     * Offset: 0x3C  SPI Control and Status Register 2
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t CNTRL2;
S
S    /**
S     * FIFO_CTL
S     * ===================================================================================================
S     * Offset: 0x40  SPI FIFO Control Register 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t FIFO_CTL;
S
S    /**
S     * STATUS
S     * ===================================================================================================
S     * Offset: 0x44  SPI Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t STATUS;
S
S} SPI_T;
S
S
S/* SPI_CNTRL Bit Field Definitions */
S#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI CNTRL: TX_FULL Position */
S#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI CNTRL: TX_FULL Mask     */
S
S#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI CNTRL: TX_EMPTY Position */
S#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI CNTRL: TX_EMPTY Mask     */
S
S#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI CNTRL: RX_FULL Position */
S#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI CNTRL: RX_FULL Mask     */
S
S#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI CNTRL: RX_EMPTY Position */
S#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI CNTRL: RX_EMPTY Mask     */
S
S#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI CNTRL: VARCLK_EN Position */
S#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI CNTRL: VARCLK_EN Mask     */
S
S#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI CNTRL: FIFO Position */
S#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI CNTRL: FIFO Mask     */
S
S#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI CNTRL: REORDER Position */
S#define SPI_CNTRL_REORDER_Msk      (3ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI CNTRL: REORDER Mask     */
S
S#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI CNTRL: SLAVE Position */
S#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI CNTRL: SLAVE Mask     */
S
S#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI CNTRL: IE Position */
S#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI CNTRL: IE Mask     */
S
S#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI CNTRL: IF Position */
S#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI CNTRL: IF Mask     */
S
S#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI CNTRL: SP_CYCLE Position */
S#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI CNTRL: SP_CYCLE Mask     */
S
S#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI CNTRL: CLKP Position */
S#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI CNTRL: CLKP Mask     */
S
S#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI CNTRL: LSB Position */
S#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI CNTRL: LSB Mask     */
S
S#define SPI_CNTRL_TX_NUM_Pos       8                                      /*!< SPI CNTRL: TX_NUM Position */
S#define SPI_CNTRL_TX_NUM_Msk       (3ul << SPI_CNTRL_TX_NUM_Pos)          /*!< SPI CNTRL: TX_NUM Mask     */
S
S#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI CNTRL: TX_BIT_LEN Position */
S#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI CNTRL: TX_BIT_LEN Mask     */
S
S#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI CNTRL: TX_NEG Position */
S#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI CNTRL: TX_NEG Mask     */
S
S#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI CNTRL: RX_NEG Position */
S#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI CNTRL: RX_NEG Mask     */
S
S#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI CNTRL: GO_BUSY Position */
S#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI CNTRL: GO_BUSY Mask     */
S
S/* SPI_DIVIDER Bit Field Definitions */
S#define SPI_DIVIDER_DIVIDER2_Pos   16                                       /*!< SPI DIVIDER: DIVIDER2 Position */
S#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI DIVIDER: DIVIDER2 Mask */
S
S#define SPI_DIVIDER_DIVIDER_Pos    0                                        /*!< SPI DIVIDER: DIVIDER Position */
S#define SPI_DIVIDER_DIVIDER_Msk    (0xFFFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI DIVIDER: DIVIDER Mask */
S
S/* SPI_SSR Bit Field Definitions */
S#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI SSR: LTRIG_FLAG Position */
S#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI SSR: LTRIG_FLAG Mask */
S
S#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI SSR: SS_LTRIG Position */
S#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI SSR: SS_LTRIG Mask */
S
S#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI SSR: AUTOSS Position */
S#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI SSR: AUTOSS Mask */
S
S#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI SSR: SS_LVL Position */
S#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI SSR: SS_LVL Mask */
S
S#define SPI_SSR_SSR_Pos            0                                 /*!< SPI SSR: SSR Position */
S#define SPI_SSR_SSR_Msk            (1ul << SPI_SSR_SSR_Pos)          /*!< SPI SSR: SSR Mask */
S
S/* SPI_CNTRL2 Bit Field Definitions */
S#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI CNTRL2: BCn Position */
S#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI CNTRL2: BCn Mask */
S
S#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI CNTRL2: SS_INT_OPT Position */
S#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI CNTRL2: SS_INT_OPT Mask */
S
S#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI CNTRL2: DUAL_IO_EN Position */
S#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI CNTRL2: DUAL_IO_EN Mask */
S
S#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI CNTRL2: DUAL_IO_DIR Position */
S#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI CNTRL2: DUAL_IO_DIR Mask */
S
S#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI CNTRL2: SLV_START_INTSTS Position */
S#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI CNTRL2: SLV_START_INTSTS Mask */
S
S#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI CNTRL2: SSTA_INTEN Position */
S#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI CNTRL2: SSTA_INTEN Mask */
S
S#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI CNTRL2: SLV_ABORT Position */
S#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI CNTRL2: SLV_ABORT Mask */
S
S#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI CNTRL2: NOSLVSEL Position */
S#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI CNTRL2: NOSLVSEL Mask */
S
S#define SPI_CNTRL2_DIV_ONE_Pos      0                                                /*!< SPI CNTRL2: DIV_ONE Position */
S#define SPI_CNTRL2_DIV_ONE_Msk      (1ul << SPI_CNTRL2_DIV_ONE_Pos)                  /*!< SPI CNTRL2: DIV_ONE Mask */
S
S/* SPI_FIFO_CTL Bit Field Definitions */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI FIFO_CTL: TX_THRESHOLD Position */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: TX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI FIFO_CTL: RX_THRESHOLD Position */
S#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: RX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI FIFO_CTL: TIMEOUT_INTEN Position */
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI FIFO_CTL: TIMEOUT_INTEN Mask */
S
S#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI FIFO_CTL: RXOV_INTEN Position */
S#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI FIFO_CTL: RXOV_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI FIFO_CTL: TX_INTEN Position */
S#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI FIFO_CTL: TX_INTEN Mask */
S
S#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI FIFO_CTL: RX_INTEN Position */
S#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI FIFO_CTL: RX_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI FIFO_CTL: TX_CLR Position */
S#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI FIFO_CTL: TX_CLR Mask */
S
S#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI FIFO_CTL: RX_CLR Position */
S#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI FIFO_CTL: RX_CLR Mask */
S
S/* SPI_STATUS Bit Field Definitions */
S#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI STATUS: TX_FIFO_COUNT Position */
S#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI STATUS: TX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI STATUS: TX_FULL Position */
S#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI STATUS: TX_FULL Mask */
S
S#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI STATUS: TX_EMPTY Position */
S#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI STATUS: TX_EMPTY Mask */
S
S#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI STATUS: RX_FULL Position */
S#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI STATUS: RX_FULL Mask */
S
S#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI STATUS: RX_EMPTY Position */
S#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI STATUS: RX_EMPTY Mask */
S
S#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI STATUS: TIMEOUT Position */
S#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI STATUS: TIMEOUT Mask */
S
S#define SPI_STATUS_IF_Pos           16                                               /*!< SPI STATUS: IF Position */
S#define SPI_STATUS_IF_Msk           (1ul << SPI_STATUS_IF_Pos)                       /*!< SPI STATUS: IF Mask     */
S
S#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI STATUS: RX_FIFO_COUNT Position */
S#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI STATUS: RX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI STATUS: SLV_START_INTSTS Position */
S#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI STATUS: SLV_START_INTSTS Mask */
S
S#define SPI_STATUS_TX_INTSTS_Pos    4                                                /*!< SPI STATUS: TX_INTSTS Position */
S#define SPI_STATUS_TX_INTSTS_Msk    (1ul << SPI_STATUS_TX_INTSTS_Pos)                /*!< SPI STATUS: TX_INTSTS Mask */
S
S#define SPI_STATUS_RX_OVERRUN_Pos    2                                               /*!< SPI STATUS: RX_OVERRUN Position */
S#define SPI_STATUS_RX_OVERRUN_Msk    (1ul << SPI_STATUS_RX_OVERRUN_Pos)              /*!< SPI STATUS: RX_OVERRUN Mask */
S
S#define SPI_STATUS_RX_INTSTS_Pos    0                                                /*!< SPI STATUS: RX_INTSTS Position */
S#define SPI_STATUS_RX_INTSTS_Msk    (1ul << SPI_STATUS_RX_INTSTS_Pos)                /*!< SPI STATUS: RX_INTSTS Mask */
S/*@}*/ /* end of group M051_SPI */
S
S
S/*------------------------------ I2C Controller ------------------------------*/
S
S/** @addtogroup M051_I2C M051 I2C
S  Memory Mapped Structure for M051 Series I2C Serial Interface Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * I2CON
S     * ===================================================================================================
S     * Offset: 0x00  I2C Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2]     |AA        |Assert Acknowledge control bit. 
S     * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during 
S     * |        |          |the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from 
S     * |        |          |master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to 
S     * |        |          |address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge 
S     * |        |          |clock pulse on the SCL line.
S     * |[3]     |SI        |I2C Interrupt Flag. 
S     * |        |          |When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI 
S     * |        |          |(I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one 
S     * |        |          |to this bit.
S     * |[4]     |STO       |I2C STOP Flag. 
S     * |        |          |In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus 
S     * |        |          |condition if a STOP condition is detected this flag will be cleared by hardware automatically. 
S     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means 
S     * |        |          |it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
S     * |[5]     |STA       |I2C START Flag. 
S     * |        |          |Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition 
S     * |        |          |to bus when the bus is free.
S     * |[6]     |ENSI      |I2C controller is enabled/disable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function 
S     * |        |          |pin function of SDA and SCL must set to I2C function first.
S     * |[7]     |EI        |Enable interrupt. 
S     * |        |          |1 = Enable I2C interrupt.
S     * |        |          |0 = Disable I2C interrupt. 
S     */    
S    __IO uint32_t I2CON;
S
S    /**
S     * I2CADDR0
S     * ===================================================================================================
S     * Offset: 0x04  I2C Slave Address Register 0 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */    
S    __IO uint32_t I2CADDR0;
S
S    /**
S     * I2CDAT
S     * ===================================================================================================
S     * Offset: 0x08  I2C Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CDAT    |I2C Data Register
S     * |        |          |Bit[7:0] is located with the 8-bit transferred data of I2C serial port. 
S     */    
S    __IO uint32_t I2CDAT;
S
S    /**
S     * I2CSTATUS
S     * ===================================================================================================
S     * Offset: 0x0C  I2C Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CSTATUS |I2C Status Register 
S     * |        |          |The status register of I2C:
S     * |        |          |The three least significant bits are always 0. The five most significant bits contain the status code. 
S     * |        |          |There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is 
S     * |        |          |requested. All other I2STATUS values correspond to defined I2C states. When each of these 
S     * |        |          |states is entered, a status interrupt is requested (SI = 1). A valid status code is present in 
S     * |        |          |I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle 
S     * |        |          |after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error 
S     * |        |          |occurs when a START or STOP condition is present at an illegal position in the formation frame. 
S     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an 
S     * |        |          |acknowledge bit.
S     */    
S    __I  uint32_t I2CSTATUS;
S
S    /**
S     * I2CLK
S     * ===================================================================================================
S     * Offset: 0x10  I2C Clock Divided Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CLK     |I2C clock divided Register
S     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).
S     */    
S    __IO uint32_t I2CLK;
S
S    /**
S     * I2CTOC
S     * ===================================================================================================
S     * Offset: 0x14  I2C Time-Out Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TIF       |Time-Out flag. 
S     * |        |          |1 = Time-Out falg is set by H/W. It can interrupt CPU.
S     * |        |          |0 = S/W can clear the flag.
S     * |[1]     |DIV4      |Time-Out counter input clock is divider by 4 
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |When Enable, The time-Out period is prolong 4 times.
S     * |[2]     |ENTI      |Time-out counter is enabled/disable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will 
S     * |        |          |reset counter and re-start up counting after SI is cleared.
S     */    
S    __IO uint32_t I2CTOC;
S
S    /**
S     * I2CADDR1
S     * ===================================================================================================
S     * Offset: 0x18  I2C Slave Address Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */    
S    __IO uint32_t I2CADDR1;
S
S    /**
S     * I2CADDR2
S     * ===================================================================================================
S     * Offset: 0x1C  I2C Slave Address Register 2 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */    
S    __IO uint32_t I2CADDR2;
S
S    /**
S     * I2CADDR3
S     * ===================================================================================================
S     * Offset: 0x20  I2C Slave Address Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */    
S    __IO uint32_t I2CADDR3;
S
S    /**
S     * I2CADM0
S     * ===================================================================================================
S     * Offset: 0x24  I2C Slave Address Mask Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM0;
S
S    /**
S     * I2CADM1
S     * ===================================================================================================
S     * Offset: 0x28  I2C Slave Address Mask Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM1;
S
S    /**
S     * I2CADM2
S     * ===================================================================================================
S     * Offset: 0x2C  I2C Slave Address Mask Register 2 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM2;
S
S    /**
S     * I2CADM3
S     * ===================================================================================================
S     * Offset: 0x30  I2C Slave Address Mask Register 3 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM3;
S
S    /**
S     * RESERVED0
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    uint32_t RESERVED0[2];
S
S    /**
S     * I2CWKUPCON
S     * ===================================================================================================
S     * Offset: 0x3C  I2C Wake Up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t I2CWKUPCON;
S
S    /**
S     * I2CWKUPSTS
S     * ===================================================================================================
S     * Offset: 0x40  I2C Wake Up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t I2CWKUPSTS;
S
S} I2C_T;
S
S/* I2C I2CON Bit Field Definitions */
S#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C I2CON: EI Position */
S#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C I2CON: EI Mask */
S
S#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C I2CON: ENS1 Position */
S#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C I2CON: ENS1 Mask */
S
S#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C I2CON: STA Position */
S#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C I2CON: STA Mask */
S
S#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C I2CON: STO Position */
S#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C I2CON: STO Mask */
S
S#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C I2CON: SI Position */
S#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C I2CON: SI Mask */
S
S#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C I2CON: AA Position */
S#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C I2CON: AA Mask */
S
S/* I2C I2CADDR Bit Field Definitions */
S#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C I2CADDR: I2CADDR Position */
S#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C I2CADDR: I2CADDR Mask */
S
S#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C I2CADDR: GC Position */
S#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C I2CADDR: GC Mask */
S
S/* I2C I2CDAT Bit Field Definitions */
S#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C I2CDAT: I2CDAT Position */
S#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C I2CDAT: I2CDAT Mask */
S
S/* I2C I2CSTATUS Bit Field Definitions */
S#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C I2CSTATUS: I2CSTATUS Position */
S#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C I2CSTATUS: I2CSTATUS Mask */
S
S/* I2C I2CLK Bit Field Definitions */
S#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C I2CLK: I2CLK Position */
S#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C I2CLK: I2CLK Mask */
S
S/* I2C I2CTOC Bit Field Definitions */
S#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C I2CTOC: ENTI Position */
S#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C I2CTOC: ENTI Mask */
S
S#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C I2CTOC: DIV4 Position */
S#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C I2CTOC: DIV4 Mask */
S
S#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C I2CTOC: TIF Position */
S#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C I2CTOC: TIF Mask */
S
S/* I2C I2CADM Bit Field Definitions */
S#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C I2CADM: I2CADM Position */
S#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C I2CADM: I2CADM Mask */
S
S/* I2C I2CWKUPCON Bit Field Definitions */
S#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C I2CWKUPCON: WKUPEN Position */
S#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C I2CWKUPCON: WKUPEN Mask */
S
S/* I2C I2CWKUPSTS Bit Field Definitions */
S#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C I2CWKUPSTS: WKUPIF Position */
S#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C I2CWKUPSTS: WKUPIF Mask */
S
S
S/*@}*/ /* end of group M051_I2C */
S
S/*----------------------------- ADC Controller -------------------------------*/
S/** @addtogroup M051_ADC M051 ADC
S  Memory Mapped Structure for M051 Series ADC Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * ADDR
S     * ===================================================================================================
S     * Offset: 0x00-0x1C  A/D Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |RSLT      |A/D Conversion Result
S     * |        |          |This field contains 12 bits conversion result.
S     * |[16]    |OVERRUN   |Over Run Flag
S     * |        |          |1 = Data in RSLT[11:0] is overwrite.
S     * |        |          |0 = Data in RSLT[11:0] is recent conversion result.
S     * |        |          |If converted data in RSLT[11:0] has not been read before new conversion result is 
S     * |        |          |loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after 
S     * |        |          |ADDR register is read.
S     * |[17]    |VALID     |Valid Flag
S     * |        |          |1 = Data in RSLT[11:0] bits is valid.
S     * |        |          |0 = Data in RSLT[11:0] bits is not valid.
S     * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed 
S     * |        |          |and cleared by hardware after ADDR register is read.
S     */    
S    __I uint32_t ADDR[8];
S
S    /**
S     * ADCR
S     * ===================================================================================================
S     * Offset: 0x20  A/D Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADEN      |A/D Converter Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to 
S     * |        |          |disable A/D converter analog circuit for saving power consumption.
S     * |[1]     |ADIE      |A/D Interrupt Enable
S     * |        |          |1 = Enable A/D interrupt function
S     * |        |          |0 = Disable A/D interrupt function
S     * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
S     * |[3:2]   |ADMD      |A/D Converter Operation Mode
S     * |        |          |00 = Single conversion
S     * |        |          |01 = Burst conversion
S     * |        |          |10 = Single-cycle scan
S     * |        |          |11 = Continuous scan
S     * |        |          |When changing the operation mode, software should disable ADST bit firstly.
S     * |        |          |Note: In Burst Mode, the A/D result data always at Data Register 0.
S     * |[5:4]   |TRGS      |Hardware Trigger Source
S     * |        |          |00 = A/D conversion is started by external STADC pin.
S     * |        |          |Others = Reserved
S     * |        |          |Software should disable TRGE and ADST before change TRGS. 
S     * |        |          |In hardware trigger mode, the ADST bit is set by the external trigger from STADC.
S     * |[7:6]   |TRGCOND   |External Trigger Condition
S     * |        |          |These two bits decide external pin STADC trigger event is level or edge. The signal 
S     * |        |          |must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and 
S     * |        |          |low state.
S     * |        |          |00 = Low level
S     * |        |          |01 = High level
S     * |        |          |10 = Falling edge
S     * |        |          |11 = Rising edge
S     * |[8]     |TRGE      |External Trigger Enable
S     * |        |          |Enable or disable triggering of A/D conversion by external STADC pin.
S     * |        |          |1= Enable
S     * |        |          |0= Disable
S     * |[10]    |DIFFEN    |A/D Differential Input Mode Enable
S     * |        |          |1 = A/D is in differential analog input mode
S     * |        |          |0 = A/D is in single-end analog input mode
S     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus
S     * |        |          |The Vplus of differential input paired channel 0 is from ADC0 pin; Vminus is from ADC1 pin.
S     * |        |          |The Vplus of differential input paired channel 1 is from ADC2 pin; Vminus is from ADC3 pin.
S     * |        |          |The Vplus of differential input paired channel 2 is from ADC4 pin; Vminus is from ADC5 pin.
S     * |        |          |The Vplus of differential input paired channel 3 is from ADC6 pin; Vminus is from ADC7 pin.
S     * |        |          |In differential input mode, only one of the two corresponding channels needs to be 
S     * |        |          |enabled in ADCHER. The conversion result will be placed to the corresponding data 
S     * |        |          |register of the enabled channel. If both channels of a differential input paired channel 
S     * |        |          |are enabled, the ADC will convert it twice in scan mode. And then write the conversion 
S     * |        |          |result to the two corresponding data registers.
S     * |[11]    |ADST      |A/D Conversion Start
S     * |        |          |1 = Conversion start.
S     * |        |          |0 = Conversion stopped and A/D converter enter idle state.
S     * |        |          |ADST bit can be controlled by two sources: software write and external pin STADC. 
S     * |        |          |ADST is cleared to 0 by hardware automatically at the ends of single mode and single-
S     * |        |          |cycle scan mode on specified channels. In continuous scan mode, A/D conversion is 
S     * |        |          |continuously performed sequentially until this bit is cleared to 0 or chip reset.
S     */    
S    __IO uint32_t ADCR;
S
S    /**
S     * ADCHER
S     * ===================================================================================================
S     * Offset: 0x24  A/D Channel Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHEN0     |Analog Input Channel 0 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |This channel is the default enabled channel if CHEN0~7 are set as 0s.
S     * |[1]     |CHEN1     |Analog Input Channel 1 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |[2]     |CHEN2     |Analog Input Channel 2 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |[3]     |CHEN3     |Analog Input Channel 3 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |[4]     |CHEN4     |Analog Input Channel 4 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |[5]     |CHEN5     |Analog Input Channel 5 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |[6]     |CHEN6     |Analog Input Channel 6 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |[7]     |CHEN7     |Analog Input Channel 7 Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |[9:8]   |PRESEL    |Analog Input Channel 7 select
S     * |        |          |00: External analog input
S     * |        |          |01: Internal bandgap voltage
S     * |        |          |1x: Reserved
S     */    
S    __IO uint32_t ADCHER;
S
S    /**
S     * ADCMPR
S     * ===================================================================================================
S     * Offset: 0x28,0x2C  A/D Compare Register 0 & 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CMPEN     |Compare Enable
S     * |        |          |1 = Enable compare.
S     * |        |          |0 = Disable compare.
S     * |        |          |Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion 
S     * |        |          |result when converted data is loaded into ADDR register.
S     * |[1]     |CMPIE     |Compare Interrupt Enable
S     * |        |          |1 = Enable compare function interrupt.
S     * |        |          |0 = Disable compare function interrupt.
S     * |        |          |If the compare function is enabled and the compare condition matches the settings 
S     * |        |          |of CMPCOND and CMPMATCNT, CMPF0 bit will be asserted. If CMPIE is set to 
S     * |        |          |1, a compare interrupt request is generated.
S     * |[2]     |CMPCOND   |Compare Condition
S     * |        |          |1= Set the compare condition as that when a 12-bit A/D conversion result is 
S     * |        |          |greater or equal to the 12-bit CMPD(ADCMPR0[27:16]), the internal match 
S     * |        |          |counter will increase one.
S     * |        |          |0= Set the compare condition as that when a 12-bit A/D conversion result is less 
S     * |        |          |than the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will 
S     * |        |          |increase one.
S     * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT +1), the 
S     * |        |          |CMPF0 bit will be set.
S     * |[5:3]   |CMPCH     |Compare Channel Selection
S     * |        |          |000 = Channel 0 conversion result is selected to be compared.
S     * |        |          |001 = Channel 1 conversion result is selected to be compared.
S     * |        |          |010 = Channel 2 conversion result is selected to be compared.
S     * |        |          |011 = Channel 3 conversion result is selected to be compared.
S     * |        |          |100 = Channel 4 conversion result is selected to be compared.
S     * |        |          |101 = Channel 5 conversion result is selected to be compared.
S     * |        |          |110 = Channel 6 conversion result is selected to be compared.
S     * |        |          |111 = Channel 7 conversion result is selected to be compared.
S     * |[11:8]  |CMPMATCNT |Compare Match Count
S     * |        |          |When the specified A/D channel analog conversion result matches the compare 
S     * |        |          |condition defined by CMPCOND[2], the internal match counter will increase 1. 
S     * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit 
S     * |        |          |will be set.
S     * |[27:16] |CMPD      |Comparison Data
S     * |        |          |The 12 bits data is used to compare with conversion result of specified channel. 
S     * |        |          |Software can use it to monitor the external analog input pin voltage transition in 
S     * |        |          |scan mode without imposing a load on software.
S     */    
S    __IO uint32_t ADCMPR[2];
S
S    /**
S     * ADSR
S     * ===================================================================================================
S     * Offset: 0x30  ADC Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADF       |A/D Conversion End Flag
S     * |        |          |A status flag that indicates the end of A/D conversion.
S     * |        |          |ADF is set to 1 at these two conditions:
S     * |        |          |1.	When A/D conversion ends in single mode
S     * |        |          |2.	When A/D conversion ends on all specified channels in scan mode.
S     * |        |          |3.	When more than 4 samples in FIFO in Burst mode.
S     * |        |          |This bit can be cleared by writing 1 to itself.
S     * |[1]     |CMPF0     |Compare Flag
S     * |        |          |When the selected channel A/D conversion result meets the setting conditions of 
S     * |        |          |ADCMPR0 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
S     * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting
S     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting
S     * |[2]     |CMPF1     |Compare Flag
S     * |        |          |When the selected channel A/D conversion result meets the setting conditions of 
S     * |        |          |ADCMPR1 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
S     * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting
S     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting
S     * |[3]     |BUSY      |BUSY/IDLE
S     * |        |          |1 = A/D converter is busy at conversion.
S     * |        |          |0 = A/D converter is in idle state.
S     * |        |          |This bit is mirror of as ADST bit in ADCR.
S     * |        |          |It is read only.
S     * |[6:4]   |CHANNEL   |Current Conversion Channel
S     * |        |          |This filed reflects current conversion channel when BUSY=1. When BUSY=0, it 
S     * |        |          |shows the next channel will be converted.
S     * |        |          |It is read only.
S     * |[15:8]  |VALID     |Data Valid flag
S     * |        |          |It is a mirror of VALID bit in ADDRx
S     * |        |          |When ADC is in Burst Mode, and there is at least one valid conversion result in buffer, 
S     * |        |          |VALID[7:0] will all set to 1.
S     * |[23:16] |OVERRUN   |Over Run flag
S     * |        |          |It is a mirror to OVERRUN bit in ADDRx
S     * |        |          |When ADC is in Burst Mode, and the buffer is overrun, OVERRUN[7:0] will all set to 
S     * |        |          |1.
S     */    
S    __IO uint32_t ADSR;
S
S    /**
S     * ADCALR
S     * ===================================================================================================
S     * Offset: 0x34  ADC Calibration Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CALEN     |Self Calibration Enable 
S     * |        |          |1 = Enable self calibration 
S     * |        |          |0 = Disable self calibration 
S     * |        |          |Software can set this bit to 1 enables A/D converter to do self calibration function. It needs 127 
S     * |        |          |ADC clocks to complete calibration. This bit must be kept at 1 after CALDONE asserted. 
S     * |        |          |Clearing this bit will disable self calibration function.
S     * |[1]     |CALDONE   |Calibration is Done 
S     * |        |          |1 = A/D converter self calibration is done. 
S     * |        |          |0 = A/D converter has not been calibrated or calibration is in progress if CALEN bit is set. 
S     * |        |          |When 0 is written to CALEN bit, CALDONE bit is cleared by hardware immediately. It is a read 
S     * |        |          |only bit.
S     */    
S    __IO uint32_t ADCALR;
S    
S} ADC_T;
S
S
S/* ADDR Bit Field Definitions */
S#define ADC_ADDR_VALID_Pos      17                                /*!< ADC ADDR: VALID Position */
S#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC ADDR: VALID Mask */
S
S#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC ADDR: OVERRUN Position */
S#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC ADDR: OVERRUN Mask */
S
S#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC ADDR: RSLT Position */
S#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC ADDR: RSLT Mask */
S
S/* ADCR Bit Field Definitions */
S#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC ADCR: DMOF Position */
S#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC ADCR: DMOF Mask */
S
S#define ADC_ADCR_ADST_Pos       11                                /*!< ADC ADCR: ADST Position */
S#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC ADCR: ADST Mask */
S
S#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC ADCR: DIFFEN Position */
S#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC ADCR: DIFFEN Mask */
S
S#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC ADCR: TRGEN Position */
S#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC ADCR: TRGEN Mask */
S
S#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC ADCR: TRGCOND Position */
S#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC ADCR: TRGCOND Mask */
S
S#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC ADCR: TRGS Position */
S#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC ADCR: TRGS Mask */
S
S#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC ADCR: ADMD Position */
S#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC ADCR: ADMD Mask */
S
S#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC ADCR: ADIE Position */
S#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC ADCR: ADIE Mask */
S
S#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC ADCR: ADEN Position */
S#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC ADCR: ADEN Mask */
S
S/* ADCHER Bit Field Definitions */
S#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC ADCHER: PRESEL Position */
S#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC ADCHER: PRESEL Mask */
S
S#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC ADCHER: CHEN Position */
S#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC ADCHER: CHEN Mask */
S
S/* ADCMPR Bit Field Definitions */
S#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC ADCMPR: CMPD Position */
S#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC ADCMPR: CMPD Mask */
S
S#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC ADCMPR: CMPMATCNT Position */
S#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC ADCMPR: CMPMATCNT Mask */
S
S#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC ADCMPR: CMPCH Position */
S#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC ADCMPR: CMPCH Mask */
S
S#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC ADCMPR: CMPCOND Position */
S#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC ADCMPR: CMPCOND Mask */
S
S#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC ADCMPR: CMPIE Position */
S#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC ADCMPR: CMPIE Mask */
S
S#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC ADCMPR: CMPEN Position */
S#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC ADCMPR: CMPEN Mask */
S
S/* ADSR Bit Field Definitions */
S#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC ADSR: OVERRUN Position */
S#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC ADSR: OVERRUN Mask */
S
S#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC ADSR: VALID Position */
S#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC ADSR: VALID Mask */
S
S#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC ADSR: CHANNEL Position */
S#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC ADSR: CHANNEL Mask */
S
S#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC ADSR: BUSY Position */
S#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC ADSR: BUSY Mask */
S
S#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC ADSR: CMPF1 Position */
S#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC ADSR: CMPF1 Mask */
S
S#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC ADSR: CMPF0 Position */
S#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC ADSR: CMPF0 Mask */
S
S#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC ADSR: ADF Position */
S#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC ADSR: ADF Mask */
S
S/* ADCALR Bit Field Definitions */
S#define ADC_ADCALR_CALDONE_Pos     1                                     /*!< ADC ADCALR: CALDONE Position */
S#define ADC_ADCALR_CALDONE_Msk     (1ul << ADC_ADCALR_CALDONE_Pos)       /*!< ADC ADCALR: CALDONE Mask */
S
S#define ADC_ADCALR_CALEN_Pos       0                                     /*!< ADC ADCALR: CALEN Position */
S#define ADC_ADCALR_CALEN_Msk       (1ul << ADC_ADCALR_CALEN_Pos)         /*!< ADC ADCALR: CALEN Mask */
S/*@}*/ /* end of group M051_ADC */
S
S
S/*---------------------- Analog Comparator Controller -------------------------*/
S/** @addtogroup M051_ACMP M051 ACMP
S  Memory Mapped Structure for M051 Series ACMP Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * CMPCR
S     * ===================================================================================================
S     * Offset: 0x00  ACMP Comparator Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S        __IO uint32_t CMPCR[2];
S
S    /**
S     * CMPSR
S     * ===================================================================================================
S     * Offset: 0x08  ACMP Comparator Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S        __IO uint32_t CMPSR;
S
S} ACMP_T;
S
S
S/* CMPCR Bit Field Definitions */
S#define ACMP_CMPCR_CMPCN_Pos       4                                   /*!< ACMP CMPCR: CMPCN Position */
S#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)       /*!< ACMP CMPCR: CMPCN Mask */
S
S#define ACMP_CMPCR_CMP_HYSEN_Pos   2                                   /*!< ACMP CMPCR: CMP_HYSEN Position */
S#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)   /*!< ACMP CMPCR: CMP_HYSEN Mask */
S
S#define ACMP_CMPCR_CMPIE_Pos       1                                   /*!< ACMP CMPCR: CMPIE Position */
S#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)       /*!< ACMP CMPCR: CMPIE Mask */
S
S#define ACMP_CMPCR_CMPEN_Pos       0                                   /*!< ACMP CMPCR: CMPEN Position */
S#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)       /*!< ACMP CMPCR: CMPEN Mask */
S
S/* CMPSR Bit Field Definitions */
S#define ACMP_CMPSR_CO1_Pos     3                                 /*!< ACMP CMPSR: CO1 Position */
S#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)       /*!< ACMP CMPSR: CO1 Mask */
S
S#define ACMP_CMPSR_CO0_Pos     2                                 /*!< ACMP CMPSR: CO0 Position */
S#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)       /*!< ACMP CMPSR: CO0 Mask */
S
S#define ACMP_CMPSR_CMPF1_Pos   1                                 /*!< ACMP CMPSR: CMPF1 Position */
S#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)     /*!< ACMP CMPSR: CMPF1 Mask */
S
S#define ACMP_CMPSR_CMPF0_Pos   0                                 /*!< ACMP CMPSR: CMPF0 Position */
S#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)     /*!< ACMP CMPSR: CMPF0 Mask */
S/*@}*/ /* end of group M051_ACMP */
S
S
S/*---------------------------- Clock Controller ------------------------------*/
S
S/** @addtogroup M051_SYSCLK M051 System Clock Controller
S  Memory Mapped Structure for M051 Series System Clock Controller
S  @{
S */
S                                                              
Stypedef struct
S{
S    /**
S     * PWRCON
S     * ===================================================================================================
S     * Offset: 0x00  System Power Down Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field       |Descriptions
S     * | :----: | :----:     | :---- |
S     * |[0]     |XTL12M_EN   |External Crystal Oscillator Control
S     * |        |            |The bit default value is set by flash controller user configuration register config0 [26:24]. 
S     * |        |            |When the default clock source is from external crystal. The bit is auto set to "1"
S     * |        |            |1 = Crystal oscillation enable 
S     * |        |            |0 = Crystal oscillation disable 
S     * |[2]     |OSC22M_EN   |Internal 22.1184 MHz Oscillator Control
S     * |        |            |1 = 22.1184 MHz Oscillation enable 
S     * |        |            |0 = 22.1184 MHz Oscillation disable 
S     * |[3]     |OSC10K_EN   |Internal 10KHz Oscillator Control
S     * |        |            |1 = 10KHz Oscillation enable 
S     * |        |            |0 = 10KHz Oscillation disable 
S     * |[4]     |PD_WU_DLY   |Enable the wake up delay counter.
S     * |        |            |When the chip wakes up from power down mode, the clock control will delay certain clock 
S     * |        |            |cycles to wait system clock stable.
S     * |        |            |The delayed clock cycle is 4096 clock cycles when chip work at external crystal (4 ~ 
S     * |        |            |24MHz), and 256 clock cycles when chip work at 22.1184 MHz oscillator.
S     * |        |            |1 = Enable the clock cycle delay
S     * |        |            |0 = Disable the clock cycle delay
S     * |[5]     |PD_WU_INT_EN|Power down mode wake Up Interrupt Enable
S     * |        |            |0 = Disable
S     * |        |            |1 = Enable. The interrupt will occur when Power down mode (Deep Sleep Mode) wakeup.
S     * |[6]     |PD_WU_STS   |Chip power down wake up status flag
S     * |        |            |Set by "power down wake up", it indicates that resume from power down mode 
S     * |        |            |The flag is set if the GPIO(P0~P4), UART wakeup
S     * |        |            |Write 1 to clear the bit 
S     * |        |            |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1. 
S     * |[7]     |PWR_DOWN_EN |System power down enable bit
S     * |        |            |When set this bit "1", the chip power down mode is enabled and the chip power down active 
S     * |        |            |is depend on the PD_WAIT_CPU bit
S     * |        |            |(a) if the PD_WAIT_CPU is "0" then the chip power down after the PWR_DOWN_EN bit set.
S     * |        |            |(b) if the PD_WAIT_CPU is "1" then the chip keep active till the CPU sleep mode also active 
S     * |        |            |and then the chip power down
S     * |        |            |When chip wake up from power down, this bit is auto cleared, user need to set this bit again 
S     * |        |            |for next power down.
S     * |        |            |When in power down mode, external crystal (4~ 24MHz) and the 22.1184 MHz OSC will be 
S     * |        |            |disabled in this mode, but the 10 kHz OSC is not controlled by power down mode. 
S     * |        |            |When in power down mode, the PLL and system clock are disabled, and ignored the clock 
S     * |        |            |source selection. The clocks of peripheral are not controlled by power down mode, if the 
S     * |        |            |peripheral clock source is from 10 kHz oscillator.
S     * |        |            |1 = Chip enter the power down mode instant or wait CPU sleep command WFI
S     * |        |            |0 = Chip operate in normal mode or CPU in idle mode (sleep mode) because of WFI 
S     * |        |            |command
S     * |[8]     |PD_WAIT_CPU |This bit control the power down entry condition
S     * |        |            |1 = Chip entry power down mode when the both PWR_DOWN and CPU run WFI instruction.
S     * |        |            |0 = Chip entry power down mode when the PWR_DOWN bit is set to 1
S     */    
S    __IO uint32_t PWRCON;
S
S    /**
S     * AHBCLK
S     * ===================================================================================================
S     * Offset: 0x04  AHB Devices Clock Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control.
S     * |        |          |1 = To enable the Flash ISP controller clock.
S     * |        |          |0 = To disable the Flash ISP controller clock.
S     * |[3]     |EBI_EN    |EBI Controller Clock Enable Control.
S     * |        |          |1 = To enable the EBI Controller clock.
S     * |        |          |0 = To disable the EBI Controller clock.
S     */    
S    __IO uint32_t AHBCLK;
S
S    /**
S     * APBCLK
S     * ===================================================================================================
S     * Offset: 0x08  APB Devices Clock Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WDT_EN    |Watch Dog Timer Clock Enable.
S     * |        |          |This bit is the protected bit, program this need a open lock sequence, write "59h","16h","88h" to 
S     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address 
S     * |        |          |GCR_BA + 0x100
S     * |        |          |0 = Disable Watchdog Timer Clock
S     * |        |          |1 = Enable Watchdog Timer Clock
S     * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
S     * |        |          |0 = Disable Timer0 Clock
S     * |        |          |1 = Enable Timer0 Clock
S     * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
S     * |        |          |0 = Disable Timer1 Clock
S     * |        |          |1 = Enable Timer1 Clock
S     * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
S     * |        |          |0 = Disable Timer2 Clock
S     * |        |          |1 = Enable Timer2 Clock
S     * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
S     * |        |          |0 = Disable Timer3 Clock
S     * |        |          |1 = Enable Timer3 Clock
S     * |[6]     |FDIV_EN   |Clock Divider Clock Enable Control
S     * |        |          |0 = Disable FDIV Clock
S     * |        |          |1 = Enable FDIV Clock
S     * |[8]     |I2C_EN    |I2C Clock Enable Control. 
S     * |        |          |0 = Disable I2C Clock
S     * |        |          |1 = Enable I2C Clock
S     * |[12]    |SPI0_EN   |SPI0 Clock Enable Control. 
S     * |        |          |0 = Disable SPI0 Clock
S     * |        |          |1 = Enable SPI0 Clock
S     * |[13]    |SPI1_EN   |SPI1 Clock Enable Control. 
S     * |        |          |0 = Disable SPI1 Clock
S     * |        |          |1 = Enable SPI1 Clock
S     * |[16]    |UART0_EN  |UART0 Clock Enable Control.
S     * |        |          |1 = Enable UART0 clock
S     * |        |          |0 = Disable UART0 clock
S     * |[17]    |UART1_EN  |UART1 Clock Enable Control.
S     * |        |          |1 = Enable UART1 clock
S     * |        |          |0 = Disable UART1 clock
S     * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control.
S     * |        |          |1 = Enable PWM01 clock
S     * |        |          |0 = Disable PWM01 clock
S     * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control.
S     * |        |          |1 = Enable PWM23 clock
S     * |        |          |0 = Disable PWM23 clock
S     * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control.
S     * |        |          |1 = Enable PWM45 clock
S     * |        |          |0 = Disable PWM45 clock
S     * |[23]    |PWM67_EN  |PWM_67 Clock Enable Control.
S     * |        |          |1 = Enable PWM67 clock
S     * |        |          |0 = Disable PWM67 clock
S     * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control.
S     * |        |          |1 = Enable ADC clock
S     * |        |          |0 = Disable ADC clock
S     */    
S    __IO uint32_t APBCLK;
S
S    /**
S     * CLKSTATUS
S     * ===================================================================================================
S     * Offset: 0x0C  Clock Status Monitor Register 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field      |Descriptions
S     * | :----: | :----:    | :---- |
S     * |[0]     |XTL12M_STB |XTL12M clock source stable flag
S     * |        |           |1 = External Crystal clock is stable
S     * |        |           |0 = External Crystal clock is not stable or not enable
S     * |[2]     |PLL_STB    |PLL clock source stable flag
S     * |        |           |1 = PLL clock is stable
S     * |        |           |0 = PLL clock is not stable or not enable
S     * |[3]     |OSC10K_STB |OSC10K clock source stable flag
S     * |        |           |1 = OSC10K clock is stable
S     * |        |           |0 = OSC10K clock is not stable or not enable
S     * |[4]     |OSC22M_STB |OSC22M clock source stable flag
S     * |        |           |1 = OSC22M clock is stable
S     * |        |           |0 = OSC22M clock is not stable or not enable
S     * |[7]     |CLK_SW_FAIL|Clock switch fail flag
S     * |        |           |1 = Clock switch fail
S     * |        |           |0 = Clock switch success
S     * |        |           |This bit will be set when target switch clock source is not stable. Write 1 to clear this bit to zero.
S     */    
S    __IO uint32_t CLKSTATUS;
S
S    /**
S     * CLKSEL0
S     * ===================================================================================================
S     * Offset: 0x10  Clock Source Select Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |HCLK_S    |HCLK clock source select.
S     * |        |          |Note:
S     * |        |          |1.	Before clock switch the related clock sources (pre-select and new-select) must be turn on
S     * |        |          |2.	The 3-bit default value is reloaded with the value of Config0.CFOSC[26:24] in user 
S     * |        |          |configuration register in Flash controller by any reset. Therefore the default value is either 
S     * |        |          |000b or 111b.
S     * |        |          |3.	These bits are protected bit, program this need an open lock sequence, write 
S     * |        |          |"59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register 
S     * |        |          |REGWRPROT at address GCR_BA + 0x100
S     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |010 = clock source from PLL clock
S     * |        |          |011 = clock source from internal 10KHz oscillator clock
S     * |        |          |111 = clock source from internal 22.1184 MHz oscillator clock
S     * |        |          |others = Reserved
S     * |[5:3]   |STCLK_S   |MCU Cortex_M0 SysTick clock source select.
S     * |        |          |These bits are protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
S     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
S     * |        |          |+ 0x100
S     * |        |          |000 = Clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |010 = Clock source from external crystal clock (4 ~ 24MHz)/2
S     * |        |          |011 = clock source from HCLK/2
S     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock/2
S     */    
S    __IO uint32_t CLKSEL0;
S
S    /**
S     * CLKSEL1
S     * ===================================================================================================
S     * Offset: 0x14  Clock Source Select Control Register 1 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WDT_S     |Watchdog Timer clock source select.
S     * |        |          |These bits are protected bit, program this need a open lock sequence, write "59h","16h","88h" to 
S     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address 
S     * |        |          |GCR_BA + 0x100
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz).
S     * |        |          |10 = clock source from HCLK/2048 clock
S     * |        |          |11 = clock source from internal 10KHz oscillator clock
S     * |[3:2]   |ADC_S     |ADC clock source select.
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz).
S     * |        |          |01 = clock source from PLL clock
S     * |        |          |1x = clock source from internal 22.1184 MHz oscillator clock
S     * |[10:8]  |TMR0_S    |TIMER0 clock source select.
S     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |010 = clock source from HCLK
S     * |        |          |011 = clock source from external trigger
S     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
S     * |[14:12] |TMR1_S    |TIMER1 clock source select.
S     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |010 = clock source from HCLK
S     * |        |          |011 = clock source from external trigger
S     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
S     * |[18:16] |TMR2_S    |TIMER2 clock source select.
S     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |010 = clock source from HCLK
S     * |        |          |011 = clock source from external trigger
S     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
S     * |[22:20] |TMR3_S    |TIMER3 clock source select.
S     * |        |          |000 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |010 = clock source from HCLK
S     * |        |          |011 = clock source from external trigger
S     * |        |          |1xx = clock source from internal 22.1184 MHz oscillator clock
S     * |[25:24] |UART_S    |UART clock source select.
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |01 = clock source from PLL clock
S     * |        |          |1x = clock source from internal 22.1184 MHz oscillator clock
S     * |[29:28] |PWM01_S   |PWM0 and PWM1 clock source select.
S     * |        |          |PWM0 and PWM1 uses the same Engine clock source, both of them with the same pre-scalar
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |10 = clock source from HCLK
S     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
S     * |[31:30] |PWM23_S   |PWM2 and PWM3 clock source select.
S     * |        |          |PWM2 and PWM3 uses the same Engine clock source, both of them with the same pre-scalar
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |10 = clock source from HCLK
S     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
S     */    
S    __IO uint32_t CLKSEL1;
S
S    /**
S     * CLKDIV
S     * ===================================================================================================
S     * Offset: 0x18  Clock Divider Number Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |HCLK_N    |HCLK clock divide number from HCLK clock source
S     * |        |          |The HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1)
S     * |[11:8]  |UART_N    |UART clock divide number from UART clock source
S     * |        |          |The UART clock frequency = (UART clock source frequency ) / (UART_N + 1)
S     * |[23:16] |ADC_N     |ADC clock divide number from ADC clock source
S     * |        |          |The ADC clock frequency = (ADC clock source frequency ) / (ADC_N + 1)
S     */    
S    __IO uint32_t CLKDIV;
S
S    /**
S     * CLKSEL2
S     * ===================================================================================================
S     * Offset: 0x1C  Clock Source Select Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Select
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |10 = clock source from HCLK
S     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
S     * |[5:4]   |PWM45_S   |PWM4 and PWM5 clock source select. - PWM4 and PWM5 used the same Engine clock source, 
S     * |        |          |both of them with the same pre-scalar
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |10 = clock source from HCLK
S     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
S     * |[7:6]   |PWM67_S   |PWM6 and PWM7 clock source select. - PWM6 and PWM7 used the same Engine clock source, 
S     * |        |          |both of them with the same pre-scalar
S     * |        |          |00 = clock source from external crystal clock (4 ~ 24MHz)
S     * |        |          |10 = clock source from HCLK
S     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
S     */    
S    __IO uint32_t CLKSEL2;
S
S    /**
S     * PLLCON
S     * ===================================================================================================
S     * Offset: 0x20  PLL Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:0]   |FB_DV     |PLL Feedback Divider Control Pins (PLL_F[8:0])
S     * |[13:9]  |IN_DV     |PLL Input Divider Control Pins (PLL_R[4:0])
S     * |[15:14] |OUT_DV    |PLL Output Divider Control Pins (PLL_OD[1:0])
S     * |[16]    |PD        |Power Down Mode. 
S     * |        |          |If set the IDLE bit "1" in PWRCON register, the PLL will enter power down mode too
S     * |        |          |0 = PLL is in normal mode (default)
S     * |        |          |1 = PLL is in power-down mode
S     * |[17]    |BP        |PLL Bypass Control
S     * |        |          |0 = PLL is in normal mode (default)
S     * |        |          |1 = PLL clock output is same as clock input (XTALin)
S     * |[18]    |OE        |PLL OE (FOUT enable) pin Control
S     * |        |          |0 = PLL FOUT enable
S     * |        |          |1 = PLL FOUT is fixed low
S     * |[19]    |PLL_SRC   |PLL Source Clock Select
S     * |        |          |1 = PLL source clock from 22.1184 MHz oscillator
S     * |        |          |0 = PLL source clock from external crystal clock (4 ~ 24 MHz)
S     */    
S    __IO uint32_t PLLCON;
S
S    /**
S     * FRQDIV
S     * ===================================================================================================
S     * Offset: 0x24  Frequency Divider Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
S     * |        |          |The formula of output frequency is
S     * |        |          |Fout = Fin/2(N+1), 
S     * |        |          |where Fin is the input clock frequency, Fout is the frequency of divider output clock, N is the 4-bit 
S     * |        |          |value of FSEL[3:0].
S     * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
S     * |        |          |0 = Disable Frequency Divider
S     * |        |          |1 = Enable Frequency Divider
S     */    
S    __IO uint32_t FRQDIV;
S
S} SYSCLK_T;
S
S/* SYSCLK PWRCON Bit Field Definitions */
S#define SYSCLK_PWRCON_PD_WAIT_CPU_Pos           8                                       /*!< SYSCLK PWRCON: PD_WAIT_CPU Position */
S#define SYSCLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << SYSCLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< SYSCLK PWRCON: PD_WAIT_CPU Mask */
S
S#define SYSCLK_PWRCON_PWR_DOWN_EN_Pos           7                                       /*!< SYSCLK PWRCON: PWR_DOWN_EN Position */
S#define SYSCLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << SYSCLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< SYSCLK PWRCON: PWR_DOWN_EN Mask */
S
S#define SYSCLK_PWRCON_PD_WU_STS_Pos             6                                       /*!< SYSCLK PWRCON: PD_WU_STS Position */
S#define SYSCLK_PWRCON_PD_WU_STS_Msk             (1ul << SYSCLK_PWRCON_PD_WU_STS_Pos)    /*!< SYSCLK PWRCON: PD_WU_STS Mask */
S
S#define SYSCLK_PWRCON_PD_WU_INT_EN_Pos          5                                       /*!< SYSCLK PWRCON: PD_WU_INT_EN Position */
S#define SYSCLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << SYSCLK_PWRCON_PD_WU_INT_EN_Pos) /*!< SYSCLK PWRCON: PD_WU_INT_EN Mask */
S
S#define SYSCLK_PWRCON_PD_WU_DLY_Pos             4                                       /*!< SYSCLK PWRCON: PD_WU_DLY Position */
S#define SYSCLK_PWRCON_PD_WU_DLY_Msk             (1ul << SYSCLK_PWRCON_PD_WU_DLY_Pos)    /*!< SYSCLK PWRCON: PD_WU_DLY Mask */
S
S#define SYSCLK_PWRCON_OSC10K_EN_Pos             3                                       /*!< SYSCLK PWRCON: OSC10K_EN Position */
S#define SYSCLK_PWRCON_OSC10K_EN_Msk             (1ul << SYSCLK_PWRCON_OSC10K_EN_Pos)    /*!< SYSCLK PWRCON: OSC10K_EN Mask */
S#define SYSCLK_PWRCON_IRC10K_EN_Pos             3                                       /*!< SYSCLK PWRCON: OSC10K_EN Position */
S#define SYSCLK_PWRCON_IRC10K_EN_Msk             (1ul << SYSCLK_PWRCON_OSC10K_EN_Pos)    /*!< SYSCLK PWRCON: OSC10K_EN Mask */
S
S#define SYSCLK_PWRCON_OSC22M_EN_Pos             2                                       /*!< SYSCLK PWRCON: OSC22M_EN Position */
S#define SYSCLK_PWRCON_OSC22M_EN_Msk             (1ul << SYSCLK_PWRCON_OSC22M_EN_Pos)    /*!< SYSCLK PWRCON: OSC22M_EN Mask */
S#define SYSCLK_PWRCON_IRC22M_EN_Pos             2                                       /*!< SYSCLK PWRCON: OSC22M_EN Position */
S#define SYSCLK_PWRCON_IRC22M_EN_Msk             (1ul << SYSCLK_PWRCON_OSC22M_EN_Pos)    /*!< SYSCLK PWRCON: OSC22M_EN Mask */
S
S#define SYSCLK_PWRCON_XTL12M_EN_Pos             0                                       /*!< SYSCLK PWRCON: XTL12M_EN Position */
S#define SYSCLK_PWRCON_XTL12M_EN_Msk             (1ul << SYSCLK_PWRCON_XTL12M_EN_Pos)    /*!< SYSCLK PWRCON: XTL12M_EN Mask */
S
S/* SYSCLK AHBCLK Bit Field Definitions */
S#define SYSCLK_AHBCLK_EBI_EN_Pos                3                                       /*!< SYSCLK AHBCLK: EBI_EN Position */
S#define SYSCLK_AHBCLK_EBI_EN_Msk                (1ul << SYSCLK_AHBCLK_EBI_EN_Pos)       /*!< SYSCLK AHBCLK: EBI_EN Mask */
S
S#define SYSCLK_AHBCLK_ISP_EN_Pos                2                                       /*!< SYSCLK AHBCLK: ISP_EN Position */
S#define SYSCLK_AHBCLK_ISP_EN_Msk                (1ul << SYSCLK_AHBCLK_ISP_EN_Pos)       /*!< SYSCLK AHBCLK: ISP_EN Mask */
S
S/* SYSCLK APBCLK Bit Field Definitions */
S#define SYSCLK_APBCLK_ACMP1_EN_Pos              31                                      /*!< SYSCLK APBCLK: ACMP1_EN Position */
S#define SYSCLK_APBCLK_ACMP1_EN_Msk              (1ul << SYSCLK_APBCLK_ACMP1_EN_Pos)     /*!< SYSCLK APBCLK: ACMP1_EN Mask */
S
S#define SYSCLK_APBCLK_ACMP0_EN_Pos              30                                      /*!< SYSCLK APBCLK: ACMP0_EN Position */
S#define SYSCLK_APBCLK_ACMP0_EN_Msk              (1ul << SYSCLK_APBCLK_ACMP0_EN_Pos)     /*!< SYSCLK APBCLK: ACMP0_EN Mask */
S#define SYSCLK_APBCLK_ACMP_EN_Pos               30                                      /*!< SYSCLK APBCLK: ACMP_EN Position */
S#define SYSCLK_APBCLK_ACMP_EN_Msk               (1ul << SYSCLK_APBCLK_ACMP_EN_Pos)      /*!< SYSCLK APBCLK: ACMP_EN Mask */
S
S#define SYSCLK_APBCLK_ADC_EN_Pos                28                                      /*!< SYSCLK APBCLK: ADC_EN Position */
S#define SYSCLK_APBCLK_ADC_EN_Msk                (1ul << SYSCLK_APBCLK_ADC_EN_Pos)       /*!< SYSCLK APBCLK: ADC_EN Mask */
S
S#define SYSCLK_APBCLK_PWM67_EN_Pos              23                                      /*!< SYSCLK APBCLK: PWM67_EN Position */
S#define SYSCLK_APBCLK_PWM67_EN_Msk              (1ul << SYSCLK_APBCLK_PWM67_EN_Pos)     /*!< SYSCLK APBCLK: PWM67_EN Mask */
S
S#define SYSCLK_APBCLK_PWM45_EN_Pos              22                                      /*!< SYSCLK APBCLK: PWM45_EN Position */
S#define SYSCLK_APBCLK_PWM45_EN_Msk              (1ul << SYSCLK_APBCLK_PWM45_EN_Pos)     /*!< SYSCLK APBCLK: PWM45_EN Mask */
S
S#define SYSCLK_APBCLK_PWM23_EN_Pos              21                                      /*!< SYSCLK APBCLK: PWM23_EN Position */
S#define SYSCLK_APBCLK_PWM23_EN_Msk              (1ul << SYSCLK_APBCLK_PWM23_EN_Pos)     /*!< SYSCLK APBCLK: PWM23_EN Mask */
S
S#define SYSCLK_APBCLK_PWM01_EN_Pos              20                                      /*!< SYSCLK APBCLK: PWM01_EN Position */
S#define SYSCLK_APBCLK_PWM01_EN_Msk              (1ul << SYSCLK_APBCLK_PWM01_EN_Pos)     /*!< SYSCLK APBCLK: PWM01_EN Mask */
S
S#define SYSCLK_APBCLK_UART1_EN_Pos              17                                      /*!< SYSCLK APBCLK: UART1_EN Position */
S#define SYSCLK_APBCLK_UART1_EN_Msk              (1ul << SYSCLK_APBCLK_UART1_EN_Pos)     /*!< SYSCLK APBCLK: UART1_EN Mask */
S
S#define SYSCLK_APBCLK_UART0_EN_Pos              16                                      /*!< SYSCLK APBCLK: UART0_EN Position */
S#define SYSCLK_APBCLK_UART0_EN_Msk              (1ul << SYSCLK_APBCLK_UART0_EN_Pos)     /*!< SYSCLK APBCLK: UART0_EN Mask */
S
S#define SYSCLK_APBCLK_SPI1_EN_Pos               13                                      /*!< SYSCLK APBCLK: SPI1_EN Position */
S#define SYSCLK_APBCLK_SPI1_EN_Msk               (1ul << SYSCLK_APBCLK_SPI1_EN_Pos)      /*!< SYSCLK APBCLK: SPI1_EN Mask */
S
S#define SYSCLK_APBCLK_SPI0_EN_Pos               12                                      /*!< SYSCLK APBCLK: SPI0_EN Position */
S#define SYSCLK_APBCLK_SPI0_EN_Msk               (1ul << SYSCLK_APBCLK_SPI0_EN_Pos)      /*!< SYSCLK APBCLK: SPI0_EN Mask */
S
S#define SYSCLK_APBCLK_I2C1_EN_Pos               9                                       /*!< SYSCLK APBCLK: I2C1_EN Position */
S#define SYSCLK_APBCLK_I2C1_EN_Msk               (1ul << SYSCLK_APBCLK_I2C0_EN_Pos)      /*!< SYSCLK APBCLK: I2C1_EN Mask */
S
S#define SYSCLK_APBCLK_I2C0_EN_Pos               8                                       /*!< SYSCLK APBCLK: I2C0_EN Position */
S#define SYSCLK_APBCLK_I2C0_EN_Msk               (1ul << SYSCLK_APBCLK_I2C0_EN_Pos)      /*!< SYSCLK APBCLK: I2C0_EN Mask */
S#define SYSCLK_APBCLK_I2C_EN_Pos                8                                       /*!< SYSCLK APBCLK: I2C_EN Position */
S#define SYSCLK_APBCLK_I2C_EN_Msk                (1ul << SYSCLK_APBCLK_I2C_EN_Pos)       /*!< SYSCLK APBCLK: I2C_EN Mask */
S
S#define SYSCLK_APBCLK_FDIV_EN_Pos               6                                       /*!< SYSCLK APBCLK: FDIV_EN Position */
S#define SYSCLK_APBCLK_FDIV_EN_Msk               (1ul << SYSCLK_APBCLK_FDIV_EN_Pos)      /*!< SYSCLK APBCLK: FDIV_EN Mask */
S
S#define SYSCLK_APBCLK_TMR3_EN_Pos               5                                       /*!< SYSCLK APBCLK: TMR3_EN Position */
S#define SYSCLK_APBCLK_TMR3_EN_Msk               (1ul << SYSCLK_APBCLK_TMR3_EN_Pos)      /*!< SYSCLK APBCLK: TMR3_EN Mask */
S
S#define SYSCLK_APBCLK_TMR2_EN_Pos               4                                       /*!< SYSCLK APBCLK: TMR2_EN Position */
S#define SYSCLK_APBCLK_TMR2_EN_Msk               (1ul << SYSCLK_APBCLK_TMR2_EN_Pos)      /*!< SYSCLK APBCLK: TMR2_EN Mask */
S
S#define SYSCLK_APBCLK_TMR1_EN_Pos               3                                       /*!< SYSCLK APBCLK: TMR1_EN Position */
S#define SYSCLK_APBCLK_TMR1_EN_Msk               (1ul << SYSCLK_APBCLK_TMR1_EN_Pos)      /*!< SYSCLK APBCLK: TMR1_EN Mask */
S                                                
S#define SYSCLK_APBCLK_TMR0_EN_Pos               2                                       /*!< SYSCLK APBCLK: TMR0_EN Position */
S#define SYSCLK_APBCLK_TMR0_EN_Msk               (1ul << SYSCLK_APBCLK_TMR0_EN_Pos)      /*!< SYSCLK APBCLK: TMR0_EN Mask */
S
S#define SYSCLK_APBCLK_WDT_EN_Pos                0                                       /*!< SYSCLK APBCLK: WDT_EN Position */
S#define SYSCLK_APBCLK_WDT_EN_Msk                (1ul << SYSCLK_APBCLK_WDT_EN_Pos)       /*!< SYSCLK APBCLK: WDT_EN Mask */
S
S/* SYSCLK CLKSTATUS Bit Field Definitions */
S#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                           /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Position */
S#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Mask */
S
S#define SYSCLK_CLKSTATUS_OSC22M_STB_Pos         4                                       /*!< SYSCLK CLKSTATUS: OSC22M_STB Position */
S#define SYSCLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC22M_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC22M_STB Mask */
S#define SYSCLK_CLKSTATUS_IRC22M_STB_Pos         4                                       /*!< SYSCLK CLKSTATUS: OSC22M_STB Position */
S#define SYSCLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC22M_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC22M_STB Mask */
S
S#define SYSCLK_CLKSTATUS_OSC10K_STB_Pos         3                                       /*!< SYSCLK CLKSTATUS: OSC10K_STB Position */
S#define SYSCLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC10K_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC10K_STB Mask */
S#define SYSCLK_CLKSTATUS_IRC10K_STB_Pos         3                                       /*!< SYSCLK CLKSTATUS: OSC10K_STB Position */
S#define SYSCLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC10K_STB_Pos)/*!< SYSCLK CLKSTATUS: OSC10K_STB Mask */
S
S#define SYSCLK_CLKSTATUS_PLL_STB_Pos            2                                       /*!< SYSCLK CLKSTATUS: PLL_STB Position */
S#define SYSCLK_CLKSTATUS_PLL_STB_Msk            (1ul << SYSCLK_CLKSTATUS_PLL_STB_Pos)   /*!< SYSCLK CLKSTATUS: PLL_STB Mask */
S
S#define SYSCLK_CLKSTATUS_XTL12M_STB_Pos         0                                       /*!< SYSCLK CLKSTATUS: XTL12M_STB Position */
S#define SYSCLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL12M_STB_Pos)/*!< SYSCLK CLKSTATUS: XTL12M_STB Mask */
S
S/* SYSCLK CLKSEL0 Bit Field Definitions */
S#define SYSCLK_CLKSEL0_STCLK_S_Pos              3                                       /*!< SYSCLK CLKSEL0: STCLK_S Position */
S#define SYSCLK_CLKSEL0_STCLK_S_Msk              (7ul << SYSCLK_CLKSEL0_STCLK_S_Pos)     /*!< SYSCLK CLKSEL0: STCLK_S Mask */
S
S#define SYSCLK_CLKSEL0_HCLK_S_Pos               0                                       /*!< SYSCLK CLKSEL0: HCLK_S Position */
S#define SYSCLK_CLKSEL0_HCLK_S_Msk               (7ul << SYSCLK_CLKSEL0_HCLK_S_Pos)      /*!< SYSCLK CLKSEL0: HCLK_S Mask */
S
S/* SYSCLK CLKSEL1 Bit Field Definitions */
S#define SYSCLK_CLKSEL1_PWM23_S_Pos              30                                      /*!< SYSCLK CLKSEL1: PWM23_S Position */
S#define SYSCLK_CLKSEL1_PWM23_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM23_S_Pos)     /*!< SYSCLK CLKSEL1: PWM23_S Mask */
S
S#define SYSCLK_CLKSEL1_PWM01_S_Pos              28                                      /*!< SYSCLK CLKSEL1: PWM01_S Position */
S#define SYSCLK_CLKSEL1_PWM01_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM01_S_Pos)     /*!< SYSCLK CLKSEL1: PWM01_S Mask */
S
S#define SYSCLK_CLKSEL1_UART_S_Pos               24                                      /*!< SYSCLK CLKSEL1: UART_S Position */
S#define SYSCLK_CLKSEL1_UART_S_Msk               (3ul << SYSCLK_CLKSEL1_UART_S_Pos)      /*!< SYSCLK CLKSEL1: UART_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR3_S_Pos               20                                      /*!< SYSCLK CLKSEL1: TMR3_S Position */
S#define SYSCLK_CLKSEL1_TMR3_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR3_S_Pos)      /*!< SYSCLK CLKSEL1: TMR3_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR2_S_Pos               16                                      /*!< SYSCLK CLKSEL1: TMR2_S Position */
S#define SYSCLK_CLKSEL1_TMR2_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR2_S_Pos)      /*!< SYSCLK CLKSEL1: TMR2_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR1_S_Pos               12                                      /*!< SYSCLK CLKSEL1: TMR1_S Position */
S#define SYSCLK_CLKSEL1_TMR1_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR1_S_Pos)      /*!< SYSCLK CLKSEL1: TMR1_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR0_S_Pos               8                                       /*!< SYSCLK CLKSEL1: TMR0_S Position */
S#define SYSCLK_CLKSEL1_TMR0_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR0_S_Pos)      /*!< SYSCLK CLKSEL1: TMR0_S Mask */
S
S#define SYSCLK_CLKSEL1_SPI1_S_Pos               5                                       /*!< SYSCLK CLKSEL1: SPI1_S Position */
S#define SYSCLK_CLKSEL1_SPI1_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI1_S_Pos)      /*!< SYSCLK CLKSEL1: SPI1_S Mask */
S
S#define SYSCLK_CLKSEL1_SPI0_S_Pos               4                                       /*!< SYSCLK CLKSEL1: SPI0_S Position */
S#define SYSCLK_CLKSEL1_SPI0_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI0_S_Pos)      /*!< SYSCLK CLKSEL1: SPI0_S Mask */
S
S#define SYSCLK_CLKSEL1_ADC_S_Pos                2                                       /*!< SYSCLK CLKSEL1: ADC_S Position */
S#define SYSCLK_CLKSEL1_ADC_S_Msk                (3ul << SYSCLK_CLKSEL1_ADC_S_Pos)       /*!< SYSCLK CLKSEL1: ADC_S Mask */
S
S#define SYSCLK_CLKSEL1_WDT_S_Pos                0                                       /*!< SYSCLK CLKSEL1: WDT_S Position */
S#define SYSCLK_CLKSEL1_WDT_S_Msk                (3ul << SYSCLK_CLKSEL1_WDT_S_Pos)       /*!< SYSCLK CLKSEL1: WDT_S Mask */
S
S/* SYSCLK CLKSEL2 Bit Field Definitions */
S#define SYSCLK_CLKSEL2_WWDT_S_Pos               16                                      /*!< SYSCLK CLKSEL2: WWDT_S Position */
S#define SYSCLK_CLKSEL2_WWDT_S_Msk               (3ul << SYSCLK_CLKSEL2_WWDT_S_Pos)      /*!< SYSCLK CLKSEL2: WWDT_S Mask */
S
S#define SYSCLK_CLKSEL2_PWM67_S_Pos              6                                       /*!< SYSCLK CLKSEL2: PWM67_S Position */
S#define SYSCLK_CLKSEL2_PWM67_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM67_S_Pos)     /*!< SYSCLK CLKSEL2: PWM67_S Mask */
S
S#define SYSCLK_CLKSEL2_PWM45_S_Pos              4                                       /*!< SYSCLK CLKSEL2: PWM45_S Position */
S#define SYSCLK_CLKSEL2_PWM45_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM45_S_Pos)     /*!< SYSCLK CLKSEL2: PWM45_S Mask */
S
S#define SYSCLK_CLKSEL2_FRQDIV_S_Pos             2                                       /*!< SYSCLK CLKSEL2: FRQDIV_S Position */
S#define SYSCLK_CLKSEL2_FRQDIV_S_Msk             (3ul << SYSCLK_CLKSEL2_FRQDIV_S_Pos)    /*!< SYSCLK CLKSEL2: FRQDIV_S Mask */
S
S/* SYSCLK CLKDIV Bit Field Definitions */
S#define SYSCLK_CLKDIV_ADC_N_Pos                 16                                      /*!< SYSCLK CLKDIV: ADC_N Position */
S#define SYSCLK_CLKDIV_ADC_N_Msk                 (0xFFul << SYSCLK_CLKDIV_ADC_N_Pos)     /*!< SYSCLK CLKDIV: ADC_N Mask */
S
S#define SYSCLK_CLKDIV_UART_N_Pos                8                                       /*!< SYSCLK CLKDIV: UART_N Position */
S#define SYSCLK_CLKDIV_UART_N_Msk                (0xFul << SYSCLK_CLKDIV_UART_N_Pos)     /*!< SYSCLK CLKDIV: UART_N Mask */
S
S#define SYSCLK_CLKDIV_HCLK_N_Pos                0                                       /*!< SYSCLK CLKDIV: HCLK_N Position */
S#define SYSCLK_CLKDIV_HCLK_N_Msk                (0xFul << SYSCLK_CLKDIV_HCLK_N_Pos)     /*!< SYSCLK CLKDIV: HCLK_N Mask */
S
S/* SYSCLK PLLCON Bit Field Definitions */
S#define SYSCLK_PLLCON_PLL_SRC_Pos               19                                      /*!< SYSCLK PLLCON: PLL_SRC Position */
S#define SYSCLK_PLLCON_PLL_SRC_Msk               (1ul << SYSCLK_PLLCON_PLL_SRC_Pos)      /*!< SYSCLK PLLCON: PLL_SRC Mask */
S
S#define SYSCLK_PLLCON_OE_Pos                    18                                      /*!< SYSCLK PLLCON: OE Position */
S#define SYSCLK_PLLCON_OE_Msk                    (1ul << SYSCLK_PLLCON_OE_Pos)           /*!< SYSCLK PLLCON: OE Mask */
S
S#define SYSCLK_PLLCON_BP_Pos                    17                                      /*!< SYSCLK PLLCON: BP Position */
S#define SYSCLK_PLLCON_BP_Msk                    (1ul << SYSCLK_PLLCON_BP_Pos)           /*!< SYSCLK PLLCON: BP Mask */
S
S#define SYSCLK_PLLCON_PD_Pos                    16                                      /*!< SYSCLK PLLCON: PD Position */
S#define SYSCLK_PLLCON_PD_Msk                    (1ul << SYSCLK_PLLCON_PD_Pos)           /*!< SYSCLK PLLCON: PD Mask */
S
S#define SYSCLK_PLLCON_OUT_DV_Pos                14                                      /*!< SYSCLK PLLCON: OUT_DV Position */
S#define SYSCLK_PLLCON_OUT_DV_Msk                (3ul << SYSCLK_PLLCON_OUT_DV_Pos)       /*!< SYSCLK PLLCON: OUT_DV Mask */
S
S#define SYSCLK_PLLCON_IN_DV_Pos                 9                                       /*!< SYSCLK PLLCON: IN_DV Position */
S#define SYSCLK_PLLCON_IN_DV_Msk                 (0x1Ful << SYSCLK_PLLCON_IN_DV_Pos)     /*!< SYSCLK PLLCON: IN_DV Mask */
S
S#define SYSCLK_PLLCON_FB_DV_Pos                 0                                       /*!< SYSCLK PLLCON: FB_DV Position */
S#define SYSCLK_PLLCON_FB_DV_Msk                 (0x1FFul << SYSCLK_PLLCON_FB_DV_Pos)    /*!< SYSCLK PLLCON: FB_DV Mask */
S
S/* SYSCLK FRQDIV Bit Field Definitions */
S#define SYSCLK_FRQDIV_DIVIDER_EN_Pos            4                                       /*!< SYSCLK FRQDIV: DIVIDER_EN Position */
S#define SYSCLK_FRQDIV_DIVIDER_EN_Msk            (1ul << SYSCLK_FRQDIV_DIVIDER_EN_Pos)   /*!< SYSCLK FRQDIV: DIVIDER_EN Mask */
S
S#define SYSCLK_FRQDIV_FSEL_Pos                  0                                       /*!< SYSCLK FRQDIV: FSEL Position */
S#define SYSCLK_FRQDIV_FSEL_Msk                  (0xFul << SYSCLK_FRQDIV_FSEL_Pos)       /*!< SYSCLK FRQDIV: FSEL Mask */
S/*@}*/ /* end of group M051_SYSCLK */
S
S/*---------------------------- Global Controller -----------------------------*/
S
S/** @addtogroup M051_GCR M051 GCR
S  Memory Mapped Structure for M051 Series System Global Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * PDID
S     * ===================================================================================================
S     * Offset: 0x00  Part Device Identification Number Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |PDID      |This register reflects device part number code. S/W can read this register to identify which device is 
S     * |        |          |used.
S     */
S    __I  uint32_t PDID;                 
S    
S    /**
S     * RSTSRC
S     * ===================================================================================================
S     * Offset: 0x04  System Reset Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:8]  |Reserved  |Reserved
S     * |[7]     |RSTS_CPU  |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).
S     * |        |          |1 = The Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST to 1.
S     * |        |          |0 = No reset from CPU
S     * |        |          |Software can write 1 to clear this bit to zero.
S     * |[6]     |Reserved  |Reserved
S     * |[5]     |RSTS_MCU  |The RSTS_MCU flag is set by the "reset signal" from the MCU Cortex_M0 kernel to indicate the previous reset source.
S     * |        |          |1= The MCU Cortex_M0 had issued the reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.
S     * |        |          |0= No reset from MCU
S     * |        |          |This bit is cleared by writing 1 to itself.
S     * |[4]     |RSTS_BOD  |The RSTS_BOD flag is set by the "reset signal" from the Brown-Out Detector to indicate the previous reset source.
S     * |        |          |1= The Brown-Out Detector module had issued the reset signal to reset the system.
S     * |        |          |0= No reset from BOD
S     * |        |          |Software can write 1 to clear this bit to zero.
S     * |[3]     |RSTS_LVR  |The RSTS_LVR flag is set by the "reset signal" from the Low-Voltage-Reset controller to indicate the previous reset source.
S     * |        |          |1= The LVR module had issued the reset signal to reset the system.
S     * |        |          |0= No reset from LVR
S     * |        |          |Software can write 1 to clear this bit to zero.
S     * |[2]     |RSTS_WDT  |The RSTS_WDT flag is set by the "reset signal" from the Watchdog timer to indicate the previous reset source.
S     * |        |          |1= The Watchdog timer had issued the reset signal to reset the system.
S     * |        |          |0= No reset from Watchdog timer
S     * |        |          |Software can write 1 to clear this bit to zero.
S     * |[1]     |RSTS_RESET|The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.
S     * |        |          |1= The Pin /RESET had issued the reset signal to reset the system.
S     * |        |          |0= No reset from Pin /RESET
S     * |        |          |Software can write 1 to clear this bit to zero.
S     * |[0]     |RSTS_POR  |The RSTS_POR flag is set by the "reset signal", which is from the Power-On Reset (POR) module or bit CHIP_RST (IPRSTC1[0]) is set, to indicate the previous reset source.
S     * |        |          |1= The Power-On-Reset (POR) or CHIP_RST had issued the reset signal to reset the system.
S     * |        |          |0= No reset from POR or CHIP_RST
S     * |        |          |Software can write 1 to clear this bit to zero.
S     */    
S    __IO uint32_t RSTSRC;
S
S    /**
S     * IPRSTC1
S     * ===================================================================================================
S     * Offset: 0x08  Peripheral Reset Control Resister 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHIP_RST  |CHIP one shot reset.
S     * |        |          |Set this bit will reset the CHIP, including CPU kernel and all peripherals, and this bit will 
S     * |        |          |automatically return to "0" after the 2 clock cycles.
S     * |        |          |The CHIP_RST is same as the POR reset , all the chip module is reset and the chip setting from 
S     * |        |          |flash are also reload
S     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
S     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
S     * |        |          |+ 0x100
S     * |        |          |0= Normal
S     * |        |          |1= Reset CHIP
S     * |[1]     |CPU_RST   |CPU kernel one shot reset.
S     * |        |          |Set this bit will reset the Cortex-M0 CPU kernel and Flash memory controller (FMC). This bit will 
S     * |        |          |automatically return to "0" after the 2 clock cycles
S     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
S     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
S     * |        |          |+ 0x100
S     * |        |          |0= Normal
S     * |        |          |1= Reset CPU
S     * |[3]     |EBI_RST   |EBI Controller Reset
S     * |        |          |Set these bit "1" will generate a reset signal to the EBI. User need to set this bit to "0" to release 
S     * |        |          |from the reset state
S     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
S     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
S     * |        |          |+ 0x100
S     * |        |          |0= Normal operation
S     * |        |          |1= EBI IP reset
S     */    
S    __IO uint32_t IPRSTC1;
S
S    /**
S     * IPRSTC2
S     * ===================================================================================================
S     * Offset: 0x0C  Peripheral Reset Control Resister 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |GPIO_RST  |GPIO (P0~P4) controller Reset
S     * |        |          |0= GPIO controller normal operation
S     * |        |          |1= GPIO controller reset
S     * |[2]     |TMR0_RST  |Timer0 controller Reset
S     * |        |          |0= Timer0 controller normal operation
S     * |        |          |1= Timer0 controller reset
S     * |[3]     |TMR1_RST  |Timer1 controller Reset
S     * |        |          |0= Timer1 controller normal operation
S     * |        |          |1= Timer1 controller reset
S     * |[4]     |TMR2_RST  |Timer2 controller Reset
S     * |        |          |0= Timer2 controller normal operation
S     * |        |          |1= Timer2 controller reset
S     * |[5]     |TMR3_RST  |Timer3 controller Reset
S     * |        |          |0= Timer3 controller normal operation
S     * |        |          |1= Timer3 controller reset
S     * |[8]     |I2C_RST   |I2C controller Reset
S     * |        |          |0= I2C controller normal operation
S     * |        |          |1= I2C controller reset
S     * |[12]    |SPI0_RST  |SPI0 controller Reset
S     * |        |          |0= SPI0 controller normal operation
S     * |        |          |1= SPI0 controller reset
S     * |[13]    |SPI1_RST  |SPI1 controller Reset
S     * |        |          |0= SPI1 controller normal operation
S     * |        |          |1= SPI1 controller reset
S     * |[16]    |UART0_RST |UART0 controller Reset
S     * |        |          |0= UART0 controller Normal operation
S     * |        |          |1= UART0 controller reset
S     * |[17]    |UART1_RST |UART1 controller Reset
S     * |        |          |0 = UART1 controller normal operation
S     * |        |          |1 = UART1 controller reset
S     * |[20]    |PWM03_RST |PWM0~3 controller Reset
S     * |        |          |0= PWM0~3 controller normal operation
S     * |        |          |1= PWM0~3 controller reset
S     * |[21]    |PWM47_RST |PWM4~7 controller Reset
S     * |        |          |0= PWM4~7 controller normal operation
S     * |        |          |1= PWM4~7 controller reset
S     * |[28]    |ADC_RST   |ADC Controller Reset
S     * |        |          |0= ADC controller normal operation
S     * |        |          |1= ADC controller reset
S     */    
S    __IO uint32_t IPRSTC2;
S
S    /**
S     * RESERVED0
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    uint32_t RESERVED0[2];
S
S    /**
S     * BODCR
S     * ===================================================================================================
S     * Offset: 0x18  Brown-Out Detector Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BOD_EN    |Brown Out Detector Enable (initiated & write-protected bit)
S     * |        |          |The default value is set by flash controller user configuration register config0 bit[23]
S     * |        |          |1= Brown Out Detector function is enabled
S     * |        |          |0= Brown Out Detector function is disabled
S     * |[2:1]   |BOD_VL    |Brown Out Detector Threshold Voltage Selection (initiated & write-protected bit)
S     * |        |          |The default value is set by flash controller user configuration register config0 bit[22:21]
S     * |        |          |BOV_VL[1]
S     * |        |          |BOV_VL[0]
S     * |        |          |Brown out voltage
S     * |        |          |11 = 4.5V
S     * |        |          |10 = 3.8V
S     * |        |          |01 = 2.7V
S     * |        |          |00 = 2.2V
S     * |[3]     |BOD_RSTEN |Brown Out Reset Enable (initiated & write-protected bit)
S     * |        |          |1= Enable the Brown Out "RESET" function, when the Brown Out Detector function is enable 
S     * |        |          |and the detected voltage is lower than the threshold then assert a signal to reset the chip
S     * |        |          |The default value is set by flash controller user configuration register config0 bit[20]
S     * |        |          |0= Enable the Brown Out "INTERRUPT" function, when the Brown Out Detector function is 
S     * |        |          |enable and the detected voltage is lower than the threshold then assert a signal to interrupt 
S     * |        |          |the MCU Cortex-M0
S     * |        |          |When the BOD_EN is enabled and the interrupt is assert, the interrupt will keep till to the 
S     * |        |          |BOD_EN set to "0". The interrupt for CPU can be blocked by disable the NVIC in CPU for BOD 
S     * |        |          |interrupt or disable the interrupt source by disable the BOD_EN and then re-enable the BOD_EN 
S     * |        |          |function if the BOD function is required
S     * |[4]     |BOD_INTF  |Brown Out Detector Interrupt Flag
S     * |        |          |1= When Brown Out Detector detects the VDD is dropped through the voltage of BOD_VL setting 
S     * |        |          |or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to "1" and the 
S     * |        |          |brown out interrupt is requested if brown out interrupt is enabled.
S     * |        |          |0= Brown Out Detector does not detect any voltage draft at VDD down through or up through the 
S     * |        |          |voltage of BOD_VL setting.
S     * |[5]     |BOD_LPM   |Brown Out Detector Low power Mode (write-protected bit)
S     * |        |          |1= Enable the BOD low power mode
S     * |        |          |0= BOD operate in normal mode (default)
S     * |        |          |The BOD consumes about 100uA in normal mode, the low power mode can reduce the current 
S     * |        |          |to about 1/10 but slow the BOD response.
S     * |[6]     |BOD_OUT   |The status for Brown Out Detector output state
S     * |        |          |1= Brown Out Detector status output is 1, the detected voltage is lower than BOD_VL setting. If 
S     * |        |          |the BOD_EN is "0"(disabled), this bit always response "0"
S     * |        |          |0= Brown Out Detector status output is 0, the detected voltage is higher than BOD_VL setting
S     * |[7]     |LVR_EN    |Low Voltage Reset Enable (write-protected bit)
S     * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting. 
S     * |        |          |LVR function is enabled in default.
S     * |        |          |1= Enabled Low Voltage Reset function - After enable the bit, the LVR function will active with 
S     * |        |          |100uS delay for LVR output stable.(default).
S     * |        |          |0= Disabled Low Voltage Reset function
S     */    
S    __IO uint32_t BODCR;
S
S    /**
S     * TEMPCR
S     * ===================================================================================================
S     * Offset: 0x1C  Temperature Sensor Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TEMPCR;
S
S    /**
S     * RESERVED1
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    uint32_t RESERVED1;
S
S    /**
S     * PORCR
S     * ===================================================================================================
S     * Offset: 0x24  Power-On-Reset Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field       |Descriptions
S     * | :----: | :----:     | :---- |
S     * |[15:0]  |POR_DIS_CODE|The register is used for the Power-On-Reset enable control. 
S     * |        |            |When power on, the POR circuit generates a reset signal to reset the whole chip function, 
S     * |        |            |but noise on the power may cause the POR active again. If set the POR_DIS_CODE equal 
S     * |        |            |to 0x5AA5, the POR reset function will be disabled and the POR function will re-active till 
S     * |        |            |the power voltage is lower to set the POR_DIS_CODE to another value or reset by chip 
S     * |        |            |other reset function. Include:
S     * |        |            |PIN reset, Watch dog, LVR reset BOD reset, ICE reset command and the software-chip 
S     * |        |            |reset function
S     * |        |            |This register is the protected register, program this need an open lock sequence, write 
S     * |        |            |"59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register 
S     * |        |            |REGWRPROT at address GCR_BA + 0x100
S     */    
S    __IO uint32_t PORCR;
S
S    /**
S     * RESERVED2
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    uint32_t RESERVED2[2];
S
S    /**
S     * P0_MFP
S     * ===================================================================================================
S     * Offset: 0x30  P0 Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |P0_MFP    |P0 multiple function Selection
S     * |        |          |The pin function of P0 is depending on P0_MFP and P0_ALT.
S     * |        |          |Refer to P0_ALT descriptions in detail.
S     * |[8]     |P0_ALT0   |P0.0 alternate function Selection
S     * |        |          |The pin function of P0.0 is depend on P0_MFP[0] and P0_ALT[0].
S     * |        |          |P0_ALT[0]P0_MFP[0] = P0.0 Function
S     * |        |          |00 = P0.0
S     * |        |          |01 = AD0(EBI)
S     * |        |          |10 = CTS1(UART1)
S     * |        |          |11 = Reserved
S     * |[9]     |P0_ALT1   |P0.1 alternate function Selection
S     * |        |          |The pin function of P0.1 is depend on P0_MFP[1] and P0_ALT[1].
S     * |        |          |P0_ALT[1] P0_MFP[1] = P0.1 Function
S     * |        |          |00 = P0.1
S     * |        |          |01 = AD1(EBI)
S     * |        |          |10 = RTS1(UART1)
S     * |        |          |11 = Reserved
S     * |[10]    |P0_ALT2   |P0.2 alternate function Selection
S     * |        |          |The pin function of P0.2 is depend on P0_MFP[2] and P0_ALT[2].
S     * |        |          |P0_ALT[2] P0_MFP[2] = P0.2 Function
S     * |        |          |00 = P0.2
S     * |        |          |01 = AD2(EBI)
S     * |        |          |10 = CTS0(UART0)
S     * |        |          |11 = Reserved
S     * |[11]    |P0_ALT3   |P0.3 alternate function Selection
S     * |        |          |The pin function of P0.3 is depend on P0_MFP[3] and P0_ALT[3].
S     * |        |          |P0_ALT[3] P0_MFP[3] = P0.3 Function
S     * |        |          |00 = P0.3
S     * |        |          |01 = AD3(EBI)
S     * |        |          |10 = RTS0(UART0)
S     * |        |          |11 = Reserved
S     * |[12]    |P0_ALT4   |P0.4 alternate function Selection
S     * |        |          |The pin function of P0.4 is depend on P0_MFP[4] and P0_ALT[4].
S     * |        |          |P0_ALT[4] P0_MFP[4] = P0.4 Function
S     * |        |          |00 = P0.4
S     * |        |          |01 = AD4(EBI)
S     * |        |          |10 = SPISS1(SPI1)
S     * |        |          |11 = Reserved
S     * |[13]    |P0_ALT5   |P0.5 alternate function Selection
S     * |        |          |The pin function of P0.5 is depend on P0_MFP[5] and P0_ALT[5].
S     * |        |          |P0_ALT[5] P0_MFP[5] = P0.5 Function
S     * |        |          |00 = P0.5
S     * |        |          |01 = AD5(EBI)
S     * |        |          |10 = MOSI_1(SPI1)
S     * |        |          |11 = Reserved
S     * |[14]    |P0_ALT6   |P0.6 alternate function Selection
S     * |        |          |The pin function of P0.6 is depend on P0_MFP[6] and P0_ALT[6].
S     * |        |          |P0_ALT[6] P0_MFP[6] = P0.6 Function
S     * |        |          |00 = P0.6
S     * |        |          |01 = AD6(EBI)
S     * |        |          |10 = MISO_1(SPI1)
S     * |        |          |11 = Reserved
S     * |[15]    |P0_ALT7   |P0.7 alternate function Selection
S     * |        |          |The pin function of P0.7 is depend on P0_MFP[7] and P0_ALT[7].
S     * |        |          |P0_ALT[7] P0_MFP[7] = P0.7 Function
S     * |        |          |00 = P0.7
S     * |        |          |01 = AD7(EBI)
S     * |        |          |10 = SPICLK1(SPI1)
S     * |        |          |11 = Reserved
S     * |[23:16] |P0_TYPEn  |P0[7:0] input Schmitt Trigger function Enable
S     * |        |          |1= P0[7:0] I/O input Schmitt Trigger function enable
S     * |        |          |0= P0[7:0] I/O input Schmitt Trigger function disable 
S     */    
S    __IO uint32_t P0_MFP;
S
S    /**
S     * P1_MFP
S     * ===================================================================================================
S     * Offset: 0x34  P1 Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |P1_MFP    |P1 multiple function Selection
S     * |        |          |The pin function of P1 is depending on P1_MFP and P1_ALT.
S     * |        |          |Refer to P1_ALT descriptions in detail.
S     * |[8]     |P1_ALT0   |P1.0 alternate function Selection
S     * |        |          |The pin function of P1.0 is depend on P1_MFP[0] and P1_ALT[0].
S     * |        |          |P1_ALT[0] P1_MFP[0] = P1.0 Function
S     * |        |          |00 = P1.0
S     * |        |          |01 = AIN0(ADC)
S     * |        |          |10 = T2(Timer2)
S     * |        |          |11 = Reserved
S     * |[9]     |P1_ALT1   |P1.1 alternate function Selection
S     * |        |          |The pin function of P1.1 is depend on P1_MFP[1] and P1_ALT[1].
S     * |        |          |P1_ALT[1] P1_MFP[1] = P1.1 Function
S     * |        |          |00 = P1.1
S     * |        |          |01 = AIN1(ADC)
S     * |        |          |10 = T3(Timer3)
S     * |        |          |11 = Reserved
S     * |[10]    |P1_ALT2   |P1.2 alternate function Selection
S     * |        |          |The pin function of P1.2 is depend on P1_MFP[2] and P1_ALT[2].
S     * |        |          |P1_ALT[2] P1_MFP[2] = P1.2 Function
S     * |        |          |00 = P1.2
S     * |        |          |01 = AIN2(ADC)
S     * |        |          |10 = RXD1(UART1)
S     * |        |          |11 = Reserved
S     * |[11]    |P1_ALT3   |P1.3 alternate function Selection
S     * |        |          |The pin function of P1.3 is depend on P1_MFP[3] and P1_ALT[3].
S     * |        |          |P1_ALT[3] P1_MFP[3] = P1.3 Function
S     * |        |          |00 = P1.3
S     * |        |          |01 = AIN3(ADC)
S     * |        |          |10 = TXD1(UART1)
S     * |        |          |11 = Reserved
S     * |[12]    |P1_ALT4   |P1.4 alternate function Selection
S     * |        |          |The pin function of P1.4 is depend on P1_MFP[4] and P1_ALT[4].
S     * |        |          |P1_ALT[4] P1_MFP[4] = P1.4 Function
S     * |        |          |00 = P1.4
S     * |        |          |01 = AIN4(ADC)
S     * |        |          |10 = SPISS0(SPI0)
S     * |        |          |11 = Reserved
S     * |[13]    |P1_ALT5   |P1.5 alternate function Selection
S     * |        |          |The pin function of P1.5 is depend on P1_MFP[5] and P1_ALT[5].
S     * |        |          |P1_ALT[5] P1_MFP[5] = P1.5 Function
S     * |        |          |00 = P1.5
S     * |        |          |01 = AIN5(ADC)
S     * |        |          |10 = MOSI_0(SPI0)
S     * |        |          |11 = Reserved
S     * |[14]    |P1_ALT6   |P1.6 alternate function Selection
S     * |        |          |The pin function of P1.6 is depend on P1_MFP[6] and P1_ALT[6].
S     * |        |          |P1_ALT[6] P1_MFP[6] = P1.6 Function
S     * |        |          |00 = P1.6
S     * |        |          |01 = AIN6(ADC)
S     * |        |          |10 = MISO_0(SPI0)
S     * |        |          |11 = Reserved
S     * |[15]    |P1_ALT7   |P1.7 alternate function Selection
S     * |        |          |The pin function of P1.7 is depend on P1_MFP[7] and P1_ALT[7].
S     * |        |          |P1_ALT[7] P1_MFP[7] = P1.7 Function
S     * |        |          |00 = P1.7
S     * |        |          |01 = AIN7(ADC)
S     * |        |          |10 = SPICLK0(SPI0)
S     * |        |          |11 = Reserved
S     * |[23:16] |P1_TYPEn  |P1[7:0] input Schmitt Trigger function Enable
S     * |        |          |1= P1[7:0] I/O input Schmitt Trigger function enable
S     * |        |          |0= P1[7:0] I/O input Schmitt Trigger function disable 
S     */    
S    __IO uint32_t P1_MFP;
S
S    /**
S     * P2_MFP
S     * ===================================================================================================
S     * Offset: 0x38  P2 Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |P2_MFP    |P2 multiple function Selection
S     * |        |          |The pin function of P2 is depending on P2_MFP and P2_ALT.
S     * |        |          |Refer to P2_ALT descriptions in detail.
S     * |[8]     |P2_ALT0   |P2.0 alternate function Selection
S     * |        |          |The pin function of P2.0 is depend on P2_MFP[0] and P2_ALT[0].
S     * |        |          |P2_ALT[0] P2_MFP[0] = P2.0 Function
S     * |        |          |00 = P2.0
S     * |        |          |01 = AD8(EBI)
S     * |        |          |10 = PWM0(PWM generator 0)
S     * |        |          |11 = Reserved
S     * |[9]     |P2_ALT1   |P2.1 alternate function Selection
S     * |        |          |The pin function of P2.1 is depend on P2_MFP[1] and P2_ALT[1].
S     * |        |          |P2_ALT[1] P2_MFP[1] = P2.1 Function
S     * |        |          |00 = P2.1
S     * |        |          |01 = AD9(EBI)
S     * |        |          |10 = PWM1(PWM generator 0)
S     * |        |          |11 = Reserved
S     * |[10]    |P2_ALT2   |P2.2 alternate function Selection
S     * |        |          |The pin function of P2.2 is depend on P2_MFP[2] and P2_ALT[2].
S     * |        |          |P2_ALT[2] P2_MFP[2] = P2.2 Function
S     * |        |          |00 = P2.2
S     * |        |          |01 = AD10(EBI)
S     * |        |          |10 = PWM2(PWM generator 2)
S     * |        |          |11 = Reserved
S     * |[11]    |P2_ALT3   |P2.3 alternate function Selection
S     * |        |          |The pin function of P2.3 is depend on P2_MFP[3] and P2_ALT[3].
S     * |        |          |P2_ALT[3] P2_MFP[3] = P2.3 Function
S     * |        |          |00 = P2.3
S     * |        |          |01 = AD11(EBI)
S     * |        |          |10 = PWM3(PWM generator 2)
S     * |        |          |11 = Reserved
S     * |[12]    |P2_ALT4   |P2.4 alternate function Selection
S     * |        |          |The pin function of P2.4 is depend on P2_MFP[4] and P2_ALT[4].
S     * |        |          |P2_ALT[4] P2_MFP[4] = P0.4 Function
S     * |        |          |00 = P0.4
S     * |        |          |01 = AD12(EBI)
S     * |        |          |10 = PWM4(PWM generator 4)
S     * |        |          |11 = Reserved
S     * |[13]    |P2_ALT5   |P2.5 alternate function Selection
S     * |        |          |The pin function of P2.5 is depend on P2_MFP[5] and P2_ALT[5].
S     * |        |          |P2_ALT[5] P2_MFP[5] = P2.5 Function
S     * |        |          |00 = P2.5
S     * |        |          |01 = AD13(EBI)
S     * |        |          |10 = PWM5(PWM generator 4)
S     * |        |          |11 = Reserved
S     * |[14]    |P2_ALT6   |P2.6 alternate function Selection
S     * |        |          |The pin function of P2.6 is depend on P2_MFP[6] and P2_ALT[6].
S     * |        |          |P2_ALT[6] P2_MFP[6] = P2.6 Function
S     * |        |          |00 = P2.6
S     * |        |          |01 = AD14(EBI)
S     * |        |          |10 = PWM6(PWM generator 6)
S     * |        |          |11 = Reserved
S     * |[15]    |P2_ALT7   |P2.7 alternate function Selection
S     * |        |          |The pin function of P2.7 is depend on P2_MFP[7] and P2_ALT[7].
S     * |        |          |P2_ALT[7] P2_MFP[7] = P2.7 Function
S     * |        |          |00 = P2.7
S     * |        |          |01 = AD15(EBI)
S     * |        |          |10 = PWM7(PWM generator 6)
S     * |        |          |11 = Reserved
S     * |[23:16] |P2_TYPEn  |P2[7:0] input Schmitt Trigger function Enable
S     * |        |          |1= P2[7:0] I/O input Schmitt Trigger function enable
S     * |        |          |0= P2[7:0] I/O input Schmitt Trigger function disable 
S     */    
S    __IO uint32_t P2_MFP;
S
S    /**
S     * P3_MFP
S     * ===================================================================================================
S     * Offset: 0x3C  P3 Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |P3_MFP    |P3 multiple function Selection
S     * |        |          |The pin function of P3 is depending on P3_MFP and P3_ALT.
S     * |        |          |Refer to P3_ALT descriptions in detail.
S     * |[8]     |P3_ALT0   |P3.0 alternate function Selection
S     * |        |          |The pin function of P3.0 is depend on P3_MFP[0] and P3_ALT[0].
S     * |        |          |P3_ALT[0] P3_MFP[0] = P3.0 Function
S     * |        |          |00 = P3.0
S     * |        |          |01 = RXD(UART0)
S     * |        |          |1x = Reserved
S     * |[9]     |P3_ALT1   |P3.1 alternate function Selection
S     * |        |          |The pin function of P3.1 is depend on P3_MFP[1] and P3_ALT[1].
S     * |        |          |P3_ALT[1] P3_MFP[1] = P3.1 Function
S     * |        |          |00 = P3.1
S     * |        |          |01 = TXD(UART0)
S     * |        |          |1x = Reserved
S     * |[10]    |P3_ALT2   |P3.2 alternate function Selection
S     * |        |          |The pin function of P3.2 is depend on P3_MFP[2] and P3_ALT[2].
S     * |        |          |P3_ALT[2] P3_MFP[2] = P3.2 Function
S     * |        |          |00 = P3.2
S     * |        |          |01 = /INT0
S     * |        |          |11 = Reserved
S     * |[11]    |P3_ALT3   |P3.3 alternate function Selection
S     * |        |          |The pin function of P3.3 is depend on P3_MFP[3] and P3_ALT[3].
S     * |        |          |P3_ALT[3] P3_MFP[3] = P3.3 Function
S     * |        |          |00 = P3.3
S     * |        |          |01 = /INT1
S     * |        |          |10 = MCLK(EBI)
S     * |        |          |1x = Reserved
S     * |[12]    |P3_ALT4   |P3.4 alternate function Selection
S     * |        |          |The pin function of P3.4 is depend on P3_MFP[4] and P3_ALT[4].
S     * |        |          |P3_ALT[4] P3_MFP[4] = P3.4 Function
S     * |        |          |00 = P3.4
S     * |        |          |01 = T0(Timer0)
S     * |        |          |10 = SDA(I2C)
S     * |        |          |11 = Reserved
S     * |[13]    |P3_ALT5   |P3.5 alternate function Selection
S     * |        |          |The pin function of P3.5 is depend on P3_MFP[5] and P3_ALT[5].
S     * |        |          |P3_ALT[5] P3_MFP[5] = P3.5 Function
S     * |        |          |00 = P3.5
S     * |        |          |01 = T1(Timer1)
S     * |        |          |10 = SCL(I2C)
S     * |        |          |11 = Reserved
S     * |[14]    |P3_ALT6   |P3.6 alternate function Selection
S     * |        |          |The pin function of P3.6 is depend on P3_MFP[6] and P3_ALT[6].
S     * |        |          |P3_ALT[6] P3_MFP[6] = P3.6 Function
S     * |        |          |00 = P3.6
S     * |        |          |01 = WR(EBI)
S     * |        |          |10 = CKO(Clock Driver output)
S     * |        |          |11 = Reserved
S     * |[15]    |P3_ALT7   |P3.7 alternate function Selection
S     * |        |          |The pin function of P3.7 is depend on P3_MFP[7] and P3_ALT[7].
S     * |        |          |P3_ALT[7] P3_MFP[7] = P3.7 Function
S     * |        |          |00 = P3.7
S     * |        |          |01 = RD(EBI)
S     * |        |          |1x = Reserved
S     * |[23:16] |P3_TYPEn  |P3[7:0] input Schmitt Trigger function Enable
S     * |        |          |1= P3[7:0] I/O input Schmitt Trigger function enable
S     * |        |          |0= P3[7:0] I/O input Schmitt Trigger function disable 
S     */    
S    __IO uint32_t P3_MFP;
S
S    /**
S     * P4_MFP
S     * ===================================================================================================
S     * Offset: 0x40  P4 Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |P4_MFP    |P4 multiple function Selection
S     * |        |          |The pin function of P4 is depending on P4_MFP and P4_ALT.
S     * |        |          |Refer to P4_ALT descriptions in detail.
S     * |[8]     |P4_ALT0   |P4.0 alternate function Selection
S     * |        |          |The pin function of P4.0 is depend on P4_MFP[0] and P4_ALT[0].
S     * |        |          |P4_ALT[0] P4_MFP[0] = P4.0 Function
S     * |        |          |00 = P4.0
S     * |        |          |01 = PWM0(PWM generator 0)
S     * |        |          |1x = Reserved
S     * |[9]     |P4_ALT1   |P4.1 alternate function Selection
S     * |        |          |The pin function of P4.1 is depend on P4_MFP[1] and P4_ALT[1].
S     * |        |          |P4_ALT[1] P4_MFP[1] = P4.1 Function
S     * |        |          |00 = P4.1
S     * |        |          |01 = PWM1(PWM generator 0)
S     * |        |          |1x = Reserved
S     * |[10]    |P4_ALT2   |P4.2 alternate function Selection
S     * |        |          |The pin function of P4.2 is depend on P4_MFP[2] and P4_ALT[2].
S     * |        |          |P4_ALT[2] P4_MFP[2] = P4.2 Function
S     * |        |          |00 = P4.2
S     * |        |          |01 = PWM2(PWM generator 2)
S     * |        |          |1x = Reserved
S     * |[11]    |P4_ALT3   |P4.3 alternate function Selection
S     * |        |          |The pin function of P4.3 is depend on P4_MFP[3] and P4_ALT[3].
S     * |        |          |P4_ALT[3] P4_MFP[3] = P4.3 Function
S     * |        |          |00 = P4.3
S     * |        |          |01 = PWM3(PWM generator 2)
S     * |        |          |1x = Reserved
S     * |[12]    |P4_ALT4   |P4.4 alternate function Selection
S     * |        |          |The pin function of P4.4 is depend on P4_MFP[4] and P4_ALT[4].
S     * |        |          |P4_ALT[4] P4_MFP[4] = P4.4 Function
S     * |        |          |00 = P4.4
S     * |        |          |01 = /CS(EBI)
S     * |        |          |1x = Reserved
S     * |[13]    |P4_ALT5   |P4.5 alternate function Selection
S     * |        |          |The pin function of P4.5 is depend on P4_MFP[5] and P4_ALT[5].
S     * |        |          |P4_ALT[5] P4_MFP[5] = P4.5 Function
S     * |        |          |00 = P4.5
S     * |        |          |01 = ALE(EBI)
S     * |        |          |1x = Reserved
S     * |[14]    |P4_ALT6   |P4.6 alternate function Selection
S     * |        |          |The pin function of P4.6 is depend on P4_MFP[6] and P4_ALT[6].
S     * |        |          |P4_ALT[6] P4_MFP[6] = P4.6 Function
S     * |        |          |00 = P4.6
S     * |        |          |01 = ICE_CLK(ICE)
S     * |        |          |1x = Reserved
S     * |[15]    |P4_ALT7   |P4.7 alternate function Selection
S     * |        |          |The pin function of P4.7 is depend on P4_MFP[7] and P4_ALT[7].
S     * |        |          |P4_ALT[7] P4_MFP[7] = P4.7 Function
S     * |        |          |00 = P4.7
S     * |        |          |01 = ICE_DAT(ICE)
S     * |        |          |1x = Reserved
S     * |[23:16] |P4_TYPEn  |P4[7:0] input Schmitt Trigger function Enable
S     * |        |          |1= P4[7:0] I/O input Schmitt Trigger function enable
S     * |        |          |0= P4[7:0] I/O input Schmitt Trigger function disable 
S     */    
S    __IO uint32_t P4_MFP;
S
S    /**
S     * RESERVED3
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    uint32_t RESERVED3[47];
S
S    /**
S     * REGWRPROT
S     * ===================================================================================================
S     * Offset: 0x100 Register Write-Protection Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |REGWRPROT |Register Write-Protected Code (Write Only)
S     * |        |          |Some write-protected registers have to be disabled the protected function by writing the 
S     * |        |          |sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the 
S     * |        |          |REGPROTDIS bit will be set to 1 and write-protected registers can be normal write.
S     * |[0]     |REGPROTDIS|Register Write-Protected Disable index (Read only)
S     * |        |          |1 = Protection is disabled for writing protected registers
S     * |        |          |0 = Protection is enabled for writing protected registers. Any write to the protected register is 
S     * |        |          |ignored.
S     * |        |          |The Write-Protected registers list are below table:
S     * |        |          |Registers Address Note
S     * |        |          |IPRSTC1 0x5000_0008 None
S     * |        |          |BODCR 0x5000_0018 None
S     * |        |          |PORCR 0x5000_001C None
S     * |        |          |PWRCON 0x5000_0200 bit[6] is not protected for power, wake-up interrupt clear
S     * |        |          |APBCLK bit[0] 0x5000_0208 bit[0] is watch dog clock enable
S     * |        |          |CLKSEL0 0x5000_0210 HCLK and CPU STCLK clock source select
S     * |        |          |CLK_SEL1 bit[1:0] 0x5000_0214 Watch dog clock source select
S     * |        |          |ISPCON 0x5000_C000 Flash ISP Control register
S     * |        |          |WTCR 0x4000_4000 None
S     * |        |          |FATCON 0x5000_C018 None
S     */    
S    __IO uint32_t REGWRPROT;
S
S} GCR_T;
S
S/* GCR RSTSRC Bit Field Definitions */
S#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                       /*!< GCR RSTSRC: RSTS_CPU Position */
S#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)        /*!< GCR RSTSRC: RSTS_CPU Mask */
S
S#define SYS_RSTSRC_RSTS_MCU_Pos                 5                                       /*!< GCR RSTSRC: RSTS_MCU Position */
S#define SYS_RSTSRC_RSTS_MCU_Msk                 (1ul << SYS_RSTSRC_RSTS_MCU_Pos)        /*!< GCR RSTSRC: RSTS_MCU Mask */
S
S#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                       /*!< GCR RSTSRC: RSTS_BOD Position */
S#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)        /*!< GCR RSTSRC: RSTS_BOD Mask */
S
S#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                       /*!< GCR RSTSRC: RSTS_LVR Position */
S#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)        /*!< GCR RSTSRC: RSTS_LVR Mask */
S
S#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                       /*!< GCR RSTSRC: RSTS_WDT Position */
S#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)        /*!< GCR RSTSRC: RSTS_WDT Mask */
S
S#define SYS_RSTSRC_RSTS_RESET_Pos               1                                       /*!< GCR RSTSRC: RSTS_RESET Position */
S#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)      /*!< GCR RSTSRC: RSTS_RESET Mask */
S
S#define SYS_RSTSRC_RSTS_POR_Pos                 0                                       /*!< GCR RSTSRC: RSTS_POR Position */
S#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)        /*!< GCR RSTSRC: RSTS_POR Mask */
S
S/* GCR IPRSTC1 Bit Field Definitions */
S#define SYS_IPRSTC1_EBI_RST_Pos                 3                                       /*!< GCR IPRSTC1: EBI_RST Position */
S#define SYS_IPRSTC1_EBI_RST_Msk                 (1ul << SYS_IPRSTC1_EBI_RST_Pos)        /*!< GCR IPRSTC1: EBI_RST Mask */
S
S#define SYS_IPRSTC1_CPU_RST_Pos                 1                                       /*!< GCR IPRSTC1: CPU_RST Position */
S#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)        /*!< GCR IPRSTC1: CPU_RST Mask */
S
S#define SYS_IPRSTC1_CHIP_RST_Pos                0                                       /*!< GCR IPRSTC1: CHIP_RST Position */
S#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)       /*!< GCR IPRSTC1: CHIP_RST Mask */
S
S/* GCR IPRSTC2 Bit Field Definitions */
S#define SYS_IPRSTC2_ADC_RST_Pos                 28                                      /*!< GCR IPRSTC2: ADC_RST Position */
S#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)        /*!< GCR IPRSTC2: ADC_RST Mask */
S
S#define SYS_IPRSTC2_ACMP1_RST_Pos               23                                      /*!< GCR IPRSTC2: ACMP1_RST Position */
S#define SYS_IPRSTC2_ACMP1_RST_Msk               (1ul << SYS_IPRSTC2_ACMP1_RST_Pos)      /*!< GCR IPRSTC2: ACMP1_RST Mask */
S
S#define SYS_IPRSTC2_ACMP0_RST_Pos               22                                      /*!< GCR IPRSTC2: ACMP0_RST Position */
S#define SYS_IPRSTC2_ACMP0_RST_Msk               (1ul << SYS_IPRSTC2_ACMP0_RST_Pos)      /*!< GCR IPRSTC2: ACMP0_RST Mask */
S#define SYS_IPRSTC2_ACMP_RST_Pos                22                                      /*!< GCR IPRSTC2: ACMP_RST Position */
S#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)       /*!< GCR IPRSTC2: ACMP_RST Mask */
S
S#define SYS_IPRSTC2_PWM47_RST_Pos               21                                      /*!< GCR IPRSTC2: PWM47_RST Position */
S#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)      /*!< GCR IPRSTC2: PWM47_RST Mask */
S
S#define SYS_IPRSTC2_PWM03_RST_Pos               20                                      /*!< GCR IPRSTC2: PWM03_RST Position */
S#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)      /*!< GCR IPRSTC2: PWM03_RST Mask */
S
S#define SYS_IPRSTC2_UART1_RST_Pos               17                                      /*!< GCR IPRSTC2: UART1_RST Position */
S#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)      /*!< GCR IPRSTC2: UART1_RST Mask */
S
S#define SYS_IPRSTC2_UART0_RST_Pos               16                                      /*!< GCR IPRSTC2: UART0_RST Position */
S#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)      /*!< GCR IPRSTC2: UART0_RST Mask */
S
S#define SYS_IPRSTC2_SPI1_RST_Pos                13                                      /*!< GCR IPRSTC2: SPI1_RST Position */
S#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)       /*!< GCR IPRSTC2: SPI1_RST Mask */
S
S#define SYS_IPRSTC2_SPI0_RST_Pos                12                                      /*!< GCR IPRSTC2: SPI0_RST Position */
S#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)       /*!< GCR IPRSTC2: SPI0_RST Mask */
S
S#define SYS_IPRSTC2_I2C1_RST_Pos                9                                       /*!< GCR IPRSTC2: I2C1_RST Position */
S#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)       /*!< GCR IPRSTC2: I2C1_RST Mask */
S
S#define SYS_IPRSTC2_I2C0_RST_Pos                8                                       /*!< GCR IPRSTC2: I2C0_RST Position */
S#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)       /*!< GCR IPRSTC2: I2C0_RST Mask */
S#define SYS_IPRSTC2_I2C_RST_Pos                 8                                       /*!< GCR IPRSTC2: I2C_RST Position */
S#define SYS_IPRSTC2_I2C_RST_Msk                 (1ul << SYS_IPRSTC2_I2C_RST_Pos)        /*!< GCR IPRSTC2: I2C_RST Mask */
S
S#define SYS_IPRSTC2_TMR3_RST_Pos                5                                       /*!< GCR IPRSTC2: TMR3_RST Position */
S#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)       /*!< GCR IPRSTC2: TMR3_RST Mask */
S
S#define SYS_IPRSTC2_TMR2_RST_Pos                4                                       /*!< GCR IPRSTC2: TMR2_RST Position */
S#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)       /*!< GCR IPRSTC2: TMR2_RST Mask */
S
S#define SYS_IPRSTC2_TMR1_RST_Pos                3                                       /*!< GCR IPRSTC2: TMR1_RST Position */
S#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)       /*!< GCR IPRSTC2: TMR1_RST Mask */
S
S#define SYS_IPRSTC2_TMR0_RST_Pos                2                                       /*!< GCR IPRSTC2: TMR0_RST Position */
S#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)       /*!< GCR IPRSTC2: TMR0_RST Mask */
S
S#define SYS_IPRSTC2_GPIO_RST_Pos                1                                       /*!< GCR IPRSTC2: GPIO_RST Position */
S#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)       /*!< GCR IPRSTC2: GPIO_RST Mask */
S
S/* GCR BODCR Bit Field Definitions */
S#define SYS_BODCR_LVR_EN_Pos                    7                                       /*!< GCR BODCR: LVR_EN Position */
S#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)           /*!< GCR BODCR: LVR_EN Mask */
S
S#define SYS_BODCR_BOD_OUT_Pos                   6                                       /*!< GCR BODCR: BOD_OUT Position */
S#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)          /*!< GCR BODCR: BOD_OUT Mask */
S
S#define SYS_BODCR_BOD_LPM_Pos                   5                                       /*!< GCR BODCR: BOD_LPM Position */
S#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)          /*!< GCR BODCR: BOD_LPM Mask */
S
S#define SYS_BODCR_BOD_INTF_Pos                  4                                       /*!< GCR BODCR: BOD_INTF Position */
S#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)         /*!< GCR BODCR: BOD_INTF Mask */
S
S#define SYS_BODCR_BOD_RSTEN_Pos                 3                                       /*!< GCR BODCR: BOD_RSTEN Position */
S#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)        /*!< GCR BODCR: BOD_RSTEN Mask */
S
S#define SYS_BODCR_BOD_VL_Pos                    1                                       /*!< GCR BODCR: BOD_VL Position */
S#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)           /*!< GCR BODCR: BOD_VL Mask */
S
S#define SYS_BODCR_BOD_EN_Pos                    0                                       /*!< GCR BODCR: BOD_EN Position */
S#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)           /*!< GCR BODCR: BOD_EN Mask */
S
S/* GCR TEMPCR Bit Field Definitions */
S#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                       /*!< GCR TEMPCR: VTEMP_EN Position */
S#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)        /*!< GCR TEMPCR: VTEMP_EN Mask */
S
S/* GCR PORCR Bit Field Definitions */
S#define SYS_PORCR_POR_DIS_CODE_Pos              0                                       /*!< GCR PORCR: POR_DIS_CODE Position */
S#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)/*!< GCR PORCR: POR_DIS_CODE Mask */
S
S/* GCR P0_MFP Bit Field Definitions */
S#define SYS_P0_MFP_P0_ALT1_Pos                  24                                      /*!< GCR P0_MFP: P0_ALT1 Position */
S#define SYS_P0_MFP_P0_ALT1_Msk                  (3ul << SYS_P0_MFP_P0_ALT1_Pos)         /*!< GCR P0_MFP: P0_ALT1 Mask */
S
S#define SYS_P0_MFP_P0_TYPE_Pos                  16                                      /*!< GCR P0_MFP: P0_TYPE Position */
S#define SYS_P0_MFP_P0_TYPE_Msk                  (0xFFul << SYS_P0_MFP_P0_TYPE_Pos)      /*!< GCR P0_MFP: P0_TYPE Mask */
S
S#define SYS_P0_MFP_P0_ALT_Pos                   8                                       /*!< GCR P0_MFP: P0_ALT Position */
S#define SYS_P0_MFP_P0_ALT_Msk                   (0xFFul << SYS_P0_MFP_P0_ALT_Pos)       /*!< GCR P0_MFP: P0_ALT Mask */
S
S#define SYS_P0_MFP_P0_MFP_Pos                   0                                       /*!< GCR P0_MFP: P0_MFP Position */
S#define SYS_P0_MFP_P0_MFP_Msk                   (0xFFul << SYS_P0_MFP_P0_MFP_Pos)       /*!< GCR P0_MFP: P0_MFP Mask */
S
S/* GCR P1_MFP Bit Field Definitions */
S#define SYS_P1_MFP_P1_TYPE_Pos                  16                                      /*!< GCR P1_MFP: P1_TYPE Position */
S#define SYS_P1_MFP_P1_TYPE_Msk                  (0xFFul << SYS_P1_MFP_P1_TYPE_Pos)      /*!< GCR P1_MFP: P1_TYPE Mask */
S
S#define SYS_P1_MFP_P1_ALT_Pos                   8                                       /*!< GCR P1_MFP: P1_ALT Position */
S#define SYS_P1_MFP_P1_ALT_Msk                   (0xFFul << SYS_P1_MFP_P1_ALT_Pos)       /*!< GCR P1_MFP: P1_ALT Mask */
S
S#define SYS_P1_MFP_P1_MFP_Pos                   0                                       /*!< GCR P1_MFP: P1_MFP Position */
S#define SYS_P1_MFP_P1_MFP_Msk                   (0xFFul << SYS_P1_MFP_P1_MFP_Pos)       /*!< GCR P1_MFP: P1_MFP Mask */
S
S/* GCR P2_MFP Bit Field Definitions */
S#define SYS_P2_MFP_P2_TYPE_Pos                  16                                      /*!< GCR P2_MFP: P2_TYPE Position */
S#define SYS_P2_MFP_P2_TYPE_Msk                  (0xFFul << SYS_P2_MFP_P2_TYPE_Pos)      /*!< GCR P2_MFP: P2_TYPE Mask */
S
S#define SYS_P2_MFP_P2_ALT_Pos                   8                                       /*!< GCR P2_MFP: P2_ALT Position */
S#define SYS_P2_MFP_P2_ALT_Msk                   (0xFFul << SYS_P2_MFP_P2_ALT_Pos)       /*!< GCR P2_MFP: P2_ALT Mask */
S
S#define SYS_P2_MFP_P2_MFP_Pos                   0                                       /*!< GCR P2_MFP: P2_MFP Position */
S#define SYS_P2_MFP_P2_MFP_Msk                   (0xFFul << SYS_P2_MFP_P2_MFP_Pos)       /*!< GCR P2_MFP: P2_MFP Mask */
S
S/* GCR P3_MFP Bit Field Definitions */
S#define SYS_P3_MFP_P3_TYPE_Pos                  16                                      /*!< GCR P3_MFP: P3_TYPE Position */
S#define SYS_P3_MFP_P3_TYPE_Msk                  (0xFFul << SYS_P3_MFP_P3_TYPE_Pos)      /*!< GCR P3_MFP: P3_TYPE Mask */
S
S#define SYS_P3_MFP_P3_ALT_Pos                   8                                       /*!< GCR P3_MFP: P3_ALT Position */
S#define SYS_P3_MFP_P3_ALT_Msk                   (0xFFul << SYS_P3_MFP_P3_ALT_Pos)       /*!< GCR P3_MFP: P3_ALT Mask */
S
S#define SYS_P3_MFP_P3_MFP_Pos                   0                                       /*!< GCR P3_MFP: P3_MFP Position */
S#define SYS_P3_MFP_P3_MFP_Msk                   (0xFFul << SYS_P3_MFP_P3_MFP_Pos)       /*!< GCR P3_MFP: P3_MFP Mask */
S
S/* GCR P4_MFP Bit Field Definitions */
S#define SYS_P4_MFP_P4_TYPE_Pos                  16                                      /*!< GCR P4_MFP: P4_TYPE Position */
S#define SYS_P4_MFP_P4_TYPE_Msk                  (0xFFul << SYS_P4_MFP_P4_TYPE_Pos)      /*!< GCR P4_MFP: P4_TYPE Mask */
S
S#define SYS_P4_MFP_P4_ALT_Pos                   8                                       /*!< GCR P4_MFP: P4_ALT Position */
S#define SYS_P4_MFP_P4_ALT_Msk                   (0xFFul << SYS_P4_MFP_P4_ALT_Pos)       /*!< GCR P4_MFP: P4_ALT Mask */
S
S#define SYS_P4_MFP_P4_MFP_Pos                   0                                       /*!< GCR P4_MFP: P4_MFP Position */
S#define SYS_P4_MFP_P4_MFP_Msk                   (0xFFul << SYS_P4_MFP_P4_MFP_Pos)       /*!< GCR P4_MFP: P4_MFP Mask */
S
S/* GCR REGWRPROT Bit Field Definitions */
S#define SYS_REGWRPROT_REGWRPROT_Pos             0                                       /*!< GCR REGWRPROT: REGWRPROT Position */
S#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos) /*!< GCR REGWRPROT: REGWRPROT Mask */
S
S#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                       /*!< GCR REGWRPROT: REGPROTDIS Position */
S#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)   /*!< GCR REGWRPROT: REGPROTDIS Mask */
S
S/*@}*/ /* end of group M051_GCR */
S
S
S/** @addtogroup M051_INT M051 INT
S  Memory Mapped Structure for M051 Series Interrupt Source Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * IRQSRC
S     * ===================================================================================================
S     * Offset: 0x00-0x7C MCU IRQn(n=0~31) Interrupt Source Identity Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t IRQSRC[32];
S
S    /**
S     * NMISEL
S     * ===================================================================================================
S     * Offset: 0x80 NMI Interrupt Source Select Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t NMISEL;
S
S    /**
S     * MCUIRQ
S     * ===================================================================================================
S     * Offset: 0x84      MCU Interrupt Request Source Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t MCUIRQ;
S
S} GCR_INT_T;
S
S/* INT NMI_SEL Bit Field Definitions */
S#define INT_NMI_SEL_NMI_EN_Pos                  8                                       /*!< INT NMI_SEL: NMI_EN Position */
S#define INT_NMI_SEL_NMI_EN_Msk                  (1ul << INT_NMI_SEL_NMI_EN_Pos)         /*!< INT NMI_SEL: NMI_EN Mask */
S
S#define INT_NMI_SEL_NMI_SEL_Pos                 0                                       /*!< INT NMI_SEL: NMI_SEL Position */
S#define INT_NMI_SEL_NMI_SEL_Msk                 (0x1Ful << INT_NMI_SEL_NMI_SEL_Pos)     /*!< INT NMI_SEL: NMI_SEL Mask */
S/*@}*/ /* end of group M051_INT */
S
S/*-------------------------- FLASH Memory Controller -------------------------*/
S
S/** @addtogroup M051_FMC M051 FMC
S  Memory Mapped Structure for M051 Series Flash Memory Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * ISPCON
S     * ===================================================================================================
S     * Offset: 0x00  ISP Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPEN     |ISP Enable
S     * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
S     * |        |          |1 = Enable ISP function
S     * |        |          |0 = Disable ISP function
S     * |[1]     |BS        |Boot Select 
S     * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM, 
S     * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where 
S     * |        |          |MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-
S     * |        |          |on reset; It keeps the same value at other reset.
S     * |        |          |1 = boot from LDROM
S     * |        |          |0 = boot from APROM
S     * |[4]     |CFGUEN    |Config Update Enable
S     * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program 
S     * |        |          |code is running in APROM or LDROM.
S     * |        |          |1 = Config update enable 
S     * |        |          |0 = Config update disable
S     * |[5]     |LDUEN     |LDROM Update Enable
S     * |        |          |LDROM update enable bit. 
S     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
S     * |        |          |0 = LDROM cannot be updated
S     * |[6]     |ISPFF     |ISP Fail Flag
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |(1) APROM writes to itself.
S     * |        |          |(2) LDROM writes to itself. 
S     * |        |          |(3) Destination address is illegal, such as over an available range.
S     * |        |          |Write 1 to clear.
S     * |[7]     |SWRST     |Software Reset
S     * |        |          |Writing 1 to this bit to start software reset. 
S     * |        |          |It is cleared by hardware after reset is finished.
S     * |[10:8]  |PT        |Flash Program Time
S     * |        |          |000 = 40 us
S     * |        |          |001 = 45 us
S     * |        |          |010 = 50 us
S     * |        |          |011 = 55 us
S     * |        |          |100 = 20 us
S     * |        |          |101 = 25 us
S     * |        |          |110 = 30 us
S     * |        |          |111 = 35 us
S     * |[14:12] |ET        |Flash Erase Time
S     * |        |          |000 = 20 ms (default)
S     * |        |          |001 = 25 ms 
S     * |        |          |010 = 30 ms 
S     * |        |          |011 = 35 ms 
S     * |        |          |100 = 3  ms 
S     * |        |          |101 = 5  ms 
S     * |        |          |110 = 10 ms 
S     * |        |          |111 = 15 ms 
S     */    
S    __IO uint32_t ISPCON;
S
S    /**
S     * ISPADR
S     * ===================================================================================================
S     * Offset: 0x04  ISP Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPADR    |ISP Address 
S     * |        |          |NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program 
S     * |        |          |only. ISPARD[1:0] must be kept 2'b00 for ISP operation. 
S     */    
S    __IO uint32_t ISPADR;
S
S    /**
S     * ISPDAT
S     * ===================================================================================================
S     * Offset: 0x08  ISP Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT    |ISP Data 
S     * |        |          |Write data to this register before ISP program operation
S     * |        |          |Read data from this register after ISP read operation
S     */    
S    __IO uint32_t ISPDAT;
S
S    /**
S     * ISPCMD
S     * ===================================================================================================
S     * Offset: 0x0C  ISP Command Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command 
S     * |        |          |ISP command table is shown below:
S     * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
S     * |        |          |Read          ,    0,    0, 0000
S     * |        |          |Program       ,    1,    0, 0001
S     * |        |          |Page Erase    ,    1,    0, 0010
S     */    
S    __IO uint32_t ISPCMD;
S
S    /**
S     * ISPTRG
S     * ===================================================================================================
S     * Offset: 0x10  IISP Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPGO     |ISP start trigger
S     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP 
S     * |        |          |operation is finish. 
S     * |        |          |1 = ISP is on going 
S     * |        |          |0 = ISP done
S     */    
S    __IO uint32_t ISPTRG;
S
S    /**
S     * DFBADR
S     * ===================================================================================================
S     * Offset: 0x14  Data Flash Base Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |DFBA      |Data Flash Base Address
S     * |        |          |This register indicates data flash start address. 
S     * |        |          | 
S     * |        |          |It is a read only register. 
S     * |        |          | 
S     * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at 
S     * |        |          |0x01F000 by hardware internally.
S     */    
S    __I  uint32_t DFBADR;
S
S    /**
S     * FATCON
S     * ===================================================================================================
S     * Offset: 0x18  Flash Access Time Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FPSEN     |Flash Power Save Enable
S     * |        |          |If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
S     * |        |          |1 = Enable flash power saving
S     * |        |          |0 = Disable flash power saving
S     * |[3:1]   |FATS      |Flash Access Time Window Select
S     * |        |          |These bits are used to decide flash sense amplifier active duration.
S     * |        |          |000 = 40 ns
S     * |        |          |001 = 50 ns
S     * |        |          |010 = 60 ns
S     * |        |          |011 = 70 ns
S     * |        |          |100 = 80 ns
S     * |        |          |101 = 90 ns
S     * |        |          |110 = 100 ns
S     * |        |          |111 = Reserved
S     * |[4]     |L_SPEED   |Flash Low Speed Mode Enable
S     * |        |          |1 = Flash access always no wait state (zero wait state)
S     * |        |          |0 = Insert wait state while Flash access discontinued address. 
S     * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong 
S     * |        |          |code and cause fail result.
S     */    
S    __IO uint32_t FATCON;
S
S} FMC_T;
S
S/* FMC ISPCON Bit Field Definitions */
S#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC ISPCON: ISPFF Position */
S#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC ISPCON: ISPFF Mask */
S
S#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC ISPCON: LDUEN Position */
S#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC ISPCON: LDUEN Mask */
S
S#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC ISPCON: CFGUEN Position */
S#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC ISPCON: CFGUEN Mask */
S
S#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC ISPCON: APUEN Position */
S#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC ISPCON: APUEN Mask */
S
S#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC ISPCON: BS Position */
S#define FMC_ISPCON_BS_Msk                       (1ul << FMC_ISPCON_BS_Pos)              /*!< FMC ISPCON: BS Mask */
S                                                                                        
S#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC ISPCON: ISPEN Position */
S#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC ISPCON: ISPEN Mask */
S
S/* FMC ISPCMD Bit Field Definitions */
S#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC ISPCMD: FOEN Position */
S#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC ISPCMD: FOEN Mask */
S
S#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC ISPCMD: FCEN Position */
S#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC ISPCMD: FCEN Mask */
S
S#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC ISPCMD: FCTRL Position */
S#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC ISPCMD: FCTRL Mask */
S
S/* FMC ISPTRG Bit Field Definitions */
S#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC ISPTRG: ISPGO Position */
S#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC ISPTRG: ISPGO Mask */
S
S/* FMC FATCON Bit Field Definitions */
S#define FMC_FATCON_LFOM_Pos                     4                                       /*!< FMC FATCON: LFOM Position */
S#define FMC_FATCON_LFOM_Msk                     (1ul << FMC_FATCON_LFOM_Pos)            /*!< FMC FATCON: LFOM Mask */
S
S#define FMC_FATCON_FATS_Pos                     1                                       /*!< FMC FATCON: FATS Position */
S#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)            /*!< FMC FATCON: FATS Mask */
S
S#define FMC_FATCON_FPSEN_Pos                    0                                       /*!< FMC FATCON: FPSEN Position */
S#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)           /*!< FMC FATCON: FPSEN Mask */
S/*@}*/ /* end of group M051_FMC */
S
S/*----------------------------- PWM Controller -------------------------------*/
S
S/** @addtogroup M051_PWM M051 PWM
S  Memory Mapped Structure for M051 Series PWM Generator and Capture Timer
S  @{
S */
Stypedef struct
S{
S    /**
S     * PPR
S     * ===================================================================================================
S     * Offset: 0x00  PWM Pre-Scale Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |CP01      |Clock pre-scalar 0(PWM counter 0 & 1 for group A and PWM counter 4 & 5 for group B)
S     * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
S     * |        |          |If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM 
S     * |        |          |counter will be stopped also.
S     * |[15:8]  |CP23      |Clock pre-scalar 2(PWM counter 2 & 3 for group A and PWM counter 6 & 7 for group B)
S     * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
S     * |        |          |If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM 
S     * |        |          |counter will be stopped also.
S     * |[23:16] |DZI01     |Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair 
S     * |        |          |for PWM group A, PWM4 and PWM5 pair for PWM group B)
S     * |        |          |These 8 bits determine dead zone length.
S     * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
S     * |[31:24] |DZI23     |Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair 
S     * |        |          |for PWM group A, PWM6 and PWM7 pair for PWM group B)
S     * |        |          |These 8 bits determine dead zone length.
S     * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
S     */    
S    __IO uint32_t PPR;
S
S    /**
S     * CSR
S     * ===================================================================================================
S     * Offset: 0x04  PWM Clock Source Divider Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |(Table is the same as CSR3)
S     * |[6:4]   |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |(Table is the same as CSR3)
S     * |[10:8]  |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |(Table is the same as CSR3)
S     * |[14:12] |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |CSRx[2:0] = Input clock divider
S     * |        |          |100 = 1
S     * |        |          |011 = 16
S     * |        |          |010 = 8
S     * |        |          |001 = 4
S     * |        |          |000 = 2
S     */    
S    __IO uint32_t CSR;
S
S    /**
S     * PCR
S     * ===================================================================================================
S     * Offset: 0x08  PWM Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CH0EN     |PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.
S     * |[4]     |DZEN01    |Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A, 
S     * |        |          |PWM4 and PWM5 pair for PWM group B)
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a 
S     * |        |          |complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a 
S     * |        |          |complementary pair for PWM group B.
S     * |[5]     |DZEN23    |Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A, 
S     * |        |          |PWM6 and PWM7 pair for PWM group B)
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a 
S     * |        |          |complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a 
S     * |        |          |complementary pair for PWM group B.
S     * |[8]     |CH1EN     |PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[10]    |CH1INV    |PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[11]    |CH1MOD    |PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.
S     * |[16]    |CH2EN     |PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[18]    |CH2INV    |PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[19]    |CH2MOD    |PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.
S     * |[24]    |CH3EN     |PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[26]    |CH3INV    |PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[27]    |CH3MOD    |PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.
S     */    
S    __IO uint32_t PCR;
S
S    /**
S     * CNR0
S     * ===================================================================================================
S     * Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR0;
S
S    /**
S     * CMR0
S     * ===================================================================================================
S     * Offset: 0x10  PWM Comparator 0 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR0;
S
S    /**
S     * PDR0
S     * ===================================================================================================
S     * Offset: 0x14  PWM Data 0 Register(current counter 0 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR0;
S
S    /**
S     * CNR1
S     * ===================================================================================================
S     * Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR1;
S
S    /**
S     * CMR1
S     * ===================================================================================================
S     * Offset: 0x1C  PWM Comparator 1 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR1;
S
S    /**
S     * PDR1
S     * ===================================================================================================
S     * Offset: 0x20  PWM Data 1 Register(current counter 1 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR1;
S
S    /**
S     * CNR2
S     * ===================================================================================================
S     * Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR2;
S
S    /**
S     * CMR2
S     * ===================================================================================================
S     * Offset: 0x28  PWM Comparator 2 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR2;
S
S    /**
S     * PDR2
S     * ===================================================================================================
S     * Offset: 0x2C  PWM Data 2 Register(current counter 2 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR2;
S
S    /**
S     * CNR3
S     * ===================================================================================================
S     * Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR3;
S
S    /**
S     * CMR3
S     * ===================================================================================================
S     * Offset: 0x34  PWM Comparator 3 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR3;
S
S    /**
S     * PDR3
S     * ===================================================================================================
S     * Offset: 0x38  PWM Data 3 Register(current counter 3 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR3;
S
S    /**
S     * RESERVE0
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I uint32_t RESERVE0;
S
S    /**
S     * PIER
S     * ===================================================================================================
S     * Offset: 0x40  PWM Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PWMIE0    |PWM channel 0 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     * |[1]     |PWMIE1    |PWM channel 1 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     * |[2]     |PWMIE2    |PWM channel 2 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     * |[3]     |PWMIE3    |PWM channel 3 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     */    
S    __IO uint32_t PIER;
S
S    /**
S     * PIIR
S     * ===================================================================================================
S     * Offset: 0x44  PWM Interrupt Indication Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PWMIF0    |PWM channel 0 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM0 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     * |[1]     |PWMIF1    |PWM channel 1 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM1 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     * |[2]     |PWMIF2    |PWM channel 2 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM2 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     * |[3]     |PWMIF3    |PWM channel 3 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM3 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     */    
S    __IO uint32_t PIIR;
S
S    /**
S     * RESERVE1
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I uint32_t    RESERVE1[2];
S
S    /**
S     * CCR0
S     * ===================================================================================================
S     * Offset: 0x50  Capture 0/1 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INV0      | 
S     * |        |          |PWM Group Channel 0 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[1]     |CRL_IE0   |PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 0 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[2]     |CFL_IE0   |PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 0 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[3]     |CAPCH0EN  |Capture Channel 0 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 0.
S     * |        |          |0 = Disable capture function on PWM group channel 0
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 0 Interrupt.
S     * |[4]     |CAPIF0    | 
S     * |        |          |Capture0 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs 
S     * |        |          |at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[6]     |CRLRI0    | 
S     * |        |          |CRLR0 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[7]     |CFLRI0    | 
S     * |        |          |CFLR0 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[16]    |INV1      | 
S     * |        |          |PWM Group Channel 1 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[17]    |CRL_IE1   |PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 1 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[18]    |CFL_IE1   |PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 1 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[19]    |CAPCH1EN  |Capture Channel 1 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 1.
S     * |        |          |0 = Disable capture function on PWM group channel 1
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 1 Interrupt.
S     * |[20]    |CAPIF1    | 
S     * |        |          |Capture1 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs 
S     * |        |          |at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[22]    |CRLRI1    | 
S     * |        |          |CRLR1 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[23]    |CFLRI1    | 
S     * |        |          |CFLR1 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     */    
S    __IO uint32_t CCR0;
S
S    /**
S     * CCR2
S     * ===================================================================================================
S     * Offset: 0x54  Capture 2/3 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INV2      | 
S     * |        |          |PWM Group Channel 2 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[1]     |CRL_IE2   |PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 2 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[2]     |CFL_IE2   |PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 2 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[3]     |CAPCH2EN  |Capture Channel 2 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 2.
S     * |        |          |0 = Disable capture function on PWM group channel 2
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 2 Interrupt.
S     * |[4]     |CAPIF2    | 
S     * |        |          |Capture2 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs 
S     * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[6]     |CRLRI2    | 
S     * |        |          |CRLR2 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[7]     |CFLRI2    | 
S     * |        |          |CFLR2 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[16]    |INV3      | 
S     * |        |          |PWM Group Channel 3 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[17]    |CRL_IE3   |PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 3 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[18]    |CFL_IE3   |PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 3 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[19]    |CAPCH3EN  |Capture Channel 3 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 3.
S     * |        |          |0 = Disable capture function on PWM group channel 3
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 3 Interrupt.
S     * |[20]    |CAPIF3    | 
S     * |        |          |Capture3 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs 
S     * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[22]    |CRLRI3    | 
S     * |        |          |CRLR3 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[23]    |CFLRI3    | 
S     * |        |          |CFLR3 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     */    
S    __IO uint32_t CCR2;
S
S    /**
S     * CRLR0
S     * ===================================================================================================
S     * Offset: 0x58  Capture 0 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR0;
S
S    /**
S     * CFLR0
S     * ===================================================================================================
S     * Offset: 0x5C  Capture 0 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR0;
S
S    /**
S     * CRLR1
S     * ===================================================================================================
S     * Offset: 0x60  Capture 1 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR1;
S
S    /**
S     * CFLR1
S     * ===================================================================================================
S     * Offset: 0x64  Capture 1 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR1;
S
S    /**
S     * CRLR2
S     * ===================================================================================================
S     * Offset: 0x68  Capture 2 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR2;
S
S    /**
S     * CFLR2
S     * ===================================================================================================
S     * Offset: 0x6C  Capture 2 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR2;
S
S    /**
S     * CRLR3
S     * ===================================================================================================
S     * Offset: 0x70  Capture 3 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR3;
S
S    /**
S     * CFLR3
S     * ===================================================================================================
S     * Offset: 0x74  Capture 3 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR3;
S
S    /**
S     * CAPENR
S     * ===================================================================================================
S     * Offset: 0x78  Capture Input Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |CAPENR    |Capture Input Enable Register
S     * |        |          |There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or 
S     * |        |          |OFF. 
S     * |        |          |0 = OFF (PWMx multi-function pin input does not affect input capture function.)
S     * |        |          |1 = (PWMx multi-function pin input will affect its input capture function.)
S     * |        |          |CAPENR
S     * |        |          |Bit 3210 for PWM group A
S     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [0] 
S     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [1] 
S     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [2]
S     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [3]
S     * |        |          |Bit 3210 for PWM group B
S     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [4] 
S     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [5] 
S     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [6]
S     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [7]
S     */    
S    __IO uint32_t CAPENR;
S
S    /**
S     * POE
S     * ===================================================================================================
S     * Offset: 0x7C  PWM Output Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PWM0      |PWM Channel 0 Output Enable Register
S     * |        |          |1 = Enable PWM channel 0 output to pin.
S     * |        |          |0 = Disable PWM channel 0 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     * |[1]     |PWM1      |PWM Channel 1 Output Enable Register
S     * |        |          |1 = Enable PWM channel 1 output to pin.
S     * |        |          |0 = Disable PWM channel 1 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     * |[2]     |PWM2      |PWM Channel 2 Output Enable Register
S     * |        |          |1 = Enable PWM channel 2 output to pin.
S     * |        |          |0 = Disable PWM channel 2 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     * |[3]     |PWM3      |PWM Channel 3 Output Enable Register
S     * |        |          |1 = Enable PWM channel 3 output to pin.
S     * |        |          |0 = Disable PWM channel 3 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     */    
S    __IO uint32_t POE;
S
S    /**
S     * TCON
S     * ===================================================================================================
S     * Offset: 0x80  PWM Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TCON;
S
S    /**
S     * TSTATUS
S     * ===================================================================================================
S     * Offset: 0x84  PWM Trigger Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TSTATUS;
S
S    /**
S     * RESERVE2
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  RESERVE2[4];
S
S    /**
S     * PSCR
S     * ===================================================================================================
S     * Offset: 0x98  PWM Synchronous Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t PSCR;
S        
S} PWM_T;
S
S/* PWM PPR Bit Field Definitions */
S#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM PPR: DZI23 Position */
S#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM PPR: DZI23 Mask */
S
S#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM PPR: DZI01 Position */
S#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM PPR: DZI01 Mask */
S
S#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM PPR: CP23 Position */
S#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM PPR: CP23 Mask */
S
S#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM PPR: CP01 Position */
S#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM PPR: CP01 Mask */
S
S/* PWM CSR Bit Field Definitions */
S#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM CSR: CSR3 Position */
S#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM CSR: CSR3 Mask */
S
S#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM CSR: CSR2 Position */
S#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM CSR: CSR2 Mask */
S
S#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM CSR: CSR1 Position */
S#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM CSR: CSR1 Mask */
S
S#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM CSR: CSR0 Position */
S#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM CSR: CSR0 Mask */
S
S/* PWM PCR Bit Field Definitions */
S#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM PCR: PWM23TYPE Position */
S#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM PCR: PWM23TYPE Mask */
S
S#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM PCR: PWM01TYPE Position */
S#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM PCR: PWM01TYPE Mask */
S
S#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM PCR: CH3MOD Position */
S#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM PCR: CH3MOD Mask */
S
S#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM PCR: CH3INV Position */
S#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM PCR: CH3INV Mask */
S
S#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM PCR: CH3PINV Position */
S#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM PCR: CH3PINV Mask */
S
S#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM PCR: CH3EN Position */
S#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM PCR: CH3EN Mask */
S
S#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM PCR: CH2MOD Position */
S#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM PCR: CH2MOD Mask */
S
S#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM PCR: CH2INV Position */
S#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM PCR: CH2INV Mask */
S
S#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM PCR: CH2PINV Position */
S#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM PCR: CH2PINV Mask */
S
S#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM PCR: CH2EN Position */
S#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM PCR: CH2EN Mask */
S
S#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM PCR: CH1MOD Position */
S#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM PCR: CH1MOD Mask */
S
S#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM PCR: CH1INV Position */
S#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM PCR: CH1INV Mask */
S
S#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM PCR: CH1PINV Position */
S#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM PCR: CH1PINV Mask */
S
S#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM PCR: CH1EN Position */
S#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM PCR: CH1EN Mask */
S
S#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM PCR: DZEN23 Position */
S#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM PCR: DZEN23 Mask */
S
S#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM PCR: DZEN01 Position */
S#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM PCR: DZEN01 Mask */
S
S#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM PCR: CH0MOD Position */
S#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM PCR: CH0MOD Mask */
S
S#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM PCR: CH0INV Position */
S#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM PCR: CH0INV Mask */
S
S#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM PCR: CH0PINV Position */
S#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM PCR: CH0PINV Mask */
S
S#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM PCR: CH0EN Position */
S#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM PCR: CH0EN Mask */
S
S/* PWM CNR Bit Field Definitions */
S#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM CNR: CNR Position */
S#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM CNR: CNR Mask */
S
S/* PWM CMR Bit Field Definitions */
S#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM CMR: CMR Position */
S#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM CMR: CMR Mask */
S
S/* PWM PDR Bit Field Definitions */
S#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM PDR: PDR Position */
S#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM PDR: PDR Mask */
S
S
S/* PWM PIER Bit Field Definitions */
S#define PWM_PIER_INT23DTYPE_Pos                 25                                  /*!< PWM PIER: INT23DTYPE Position */
S#define PWM_PIER_INT23DTYPE_Msk                    (1ul << PWM_PIER_INT23DTYPE_Pos) /*!< PWM PIER: INT23DTYPE Mask */
S
S#define PWM_PIER_INT01DTYPE_Pos                 24                                  /*!< PWM PIER: INT01DTYPE Position */
S#define PWM_PIER_INT01DTYPE_Msk                     (1ul << PWM_PIER_INT01DTYPE_Pos)/*!< PWM PIER: INT01DTYPE Mask */
S
S#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM PIER: INT23TYPE Position */
S#define PWM_PIER_INT23TYPE_Msk                     (1ul << PWM_PIER_INT23TYPE_Pos)  /*!< PWM PIER: INT23TYPE Mask */
S
S#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM PIER: INT01TYPE Position */
S#define PWM_PIER_INT01TYPE_Msk                     (1ul << PWM_PIER_INT01TYPE_Pos)  /*!< PWM PIER: INT01TYPE Mask */
S
S#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM PIER: PWMDIE3 Position */
S#define PWM_PIER_PWMDIE3_Msk                     (1ul << PWM_PIER_PWMDIE3_Pos)      /*!< PWM PIER: PWMDIE3 Mask */
S
S#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM PIER: PWMDIE2 Position */
S#define PWM_PIER_PWMDIE2_Msk                     (1ul << PWM_PIER_PWMDIE2_Pos)      /*!< PWM PIER: PWMDIE2 Mask */
S
S#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM PIER: PWMDIE1 Position */
S#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM PIER: PWMDIE1 Mask */
S
S#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM PIER: PWMDIE0 Position */
S#define PWM_PIER_PWMDIE0_Msk                     (1ul << PWM_PIER_PWMDIE0_Pos)      /*!< PWM PIER: PWMDIE0 Mask */
S
S#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM PIER: PWMIE3 Position */
S#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM PIER: PWMIE3 Mask */
S
S#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM PIER: PWMIE2 Position */
S#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM PIER: PWMIE2 Mask */
S
S#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM PIER: PWMIE1 Position */
S#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM PIER: PWMIE1 Mask */
S
S#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM PIER: PWMIE0 Position */
S#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM PIER: PWMIE0 Mask */
S
S/* PWM PIIR Bit Field Definitions */
S#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM PIIR: PWMDIF3 Position */
S#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM PIIR: PWMDIF3 Mask */
S
S#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM PIIR: PWMDIF2 Position */
S#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM PIIR: PWMDIF2 Mask */
S
S#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM PIIR: PWMDIF1 Position */
S#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM PIIR: PWMDIF1 Mask */
S
S#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM PIIR: PWMDIF0 Position */
S#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM PIIR: PWMDIF0 Mask */
S
S#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM PIIR: PWMIF3 Position */
S#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM PIIR: PWMIF3 Mask */
S
S#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM PIIR: PWMIF2 Position */
S#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM PIIR: PWMIF2 Mask */
S
S#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM PIIR: PWMIF1 Position */
S#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM PIIR: PWMIF1 Mask */
S
S#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM PIIR: PWMIF0 Position */
S#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM PIIR: PWMIF0 Mask */
S
S/* PWM CCR0 Bit Field Definitions */
S#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM CCR0: CFLRI1 Position */
S#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM CCR0: CFLRI1 Mask */
S
S#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM CCR0: CRLRI1 Position */
S#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM CCR0: CRLRI1 Mask */
S
S#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM CCR0: CAPIF1 Position */
S#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM CCR0: CAPIF1 Mask */
S
S#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM CCR0: CAPCH1EN Position */
S#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM CCR0: CAPCH1EN Mask */
S
S#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM CCR0: CFL_IE1 Position */
S#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM CCR0: CFL_IE1 Mask */
S
S#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM CCR0: CRL_IE1 Position */
S#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM CCR0: CRL_IE1 Mask */
S
S#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM CCR0: INV1 Position */
S#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM CCR0: INV1 Mask */
S
S#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM CCR0: CFLRI0 Position */
S#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM CCR0: CFLRI0 Mask */
S
S#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM CCR0: CRLRI0 Position */
S#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM CCR0: CRLRI0 Mask */
S
S#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM CCR0: CAPIF0 Position */
S#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM CCR0: CAPIF0 Mask */
S
S#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM CCR0: CAPCH0EN Position */
S#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM CCR0: CAPCH0EN Mask */
S
S#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM CCR0: CFL_IE0 Position */
S#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM CCR0: CFL_IE0 Mask */
S
S#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM CCR0: CRL_IE0 Position */
S#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM CCR0: CRL_IE0 Mask */
S
S#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM CCR0: INV0 Position */
S#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM CCR0: INV0 Mask */
S
S/* PWM CCR2 Bit Field Definitions */
S#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM CCR2: CFLRI3 Position */
S#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM CCR2: CFLRI3 Mask */
S
S#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM CCR2: CRLRI3 Position */
S#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM CCR2: CRLRI3 Mask */
S
S#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM CCR2: CAPIF3 Position */
S#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM CCR2: CAPIF3 Mask */
S
S#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM CCR2: CAPCH3EN Position */
S#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM CCR2: CAPCH3EN Mask */
S
S#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM CCR2: CFL_IE3 Position */
S#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM CCR2: CFL_IE3 Mask */
S
S#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM CCR2: CRL_IE3 Position */
S#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM CCR2: CRL_IE3 Mask */
S
S#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM CCR2: INV3 Position */
S#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM CCR2: INV3 Mask */
S
S#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM CCR2: CFLRI2 Position */
S#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM CCR2: CFLRI2 Mask */
S
S#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM CCR2: CRLRI2 Position */
S#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM CCR2: CRLRI2 Mask */
S
S#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM CCR2: CAPIF2 Position */
S#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM CCR2: CAPIF2 Mask */
S
S#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM CCR2: CAPCH2EN Position */
S#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM CCR2: CAPCH2EN Mask */
S
S#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM CCR2: CFL_IE2 Position */
S#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM CCR2: CFL_IE2 Mask */
S
S#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM CCR2: CRL_IE2 Position */
S#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM CCR2: CRL_IE2 Mask */
S
S#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM CCR2: INV2 Position */
S#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM CCR2: INV2 Mask */
S
S/* PWM CRLR Bit Field Definitions */
S#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM CRLR: CRLR Position */
S#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM CRLR: CRLR Mask */
S
S/* PWM CFLR Bit Field Definitions */
S#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM CFLR: CFLR Position */
S#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM CFLR: CFLR Mask */
S
S/* PWM CAPENR Bit Field Definitions */
S#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM CAPENR: CINEN3 Position */
S#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM CAPENR: CINEN3 Mask */   
S
S#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM CAPENR: CINEN2 Position */
S#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM CAPENR: CINEN2 Mask */  
S
S#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM CAPENR: CINEN1 Position */
S#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM CAPENR: CINEN1 Mask */  
S
S#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM CAPENR: CINEN0 Position */
S#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM CAPENR: CINEN0 Mask */ 
S
S/* PWM POE Bit Field Definitions */
S#define PWM_POE_PWM3_Pos                        3                                   /*!< PWM POE: POE3 Position */
S#define PWM_POE_PWM3_Msk                        (1ul << PWM_POE_PWM3_Pos)           /*!< PWM POE: POE3 Mask */   
S
S#define PWM_POE_PWM2_Pos                        2                                   /*!< PWM POE: POE2 Position */
S#define PWM_POE_PWM2_Msk                        (1ul << PWM_POE_PWM2_Pos)           /*!< PWM POE: POE2 Mask */  
S
S#define PWM_POE_PWM1_Pos                        1                                   /*!< PWM POE: POE1 Position */
S#define PWM_POE_PWM1_Msk                        (1ul << PWM_POE_PWM1_Pos)           /*!< PWM POE: POE1 Mask */  
S
S#define PWM_POE_PWM0_Pos                        0                                   /*!< PWM POE: POE0 Position */
S#define PWM_POE_PWM0_Msk                        (1ul << PWM_POE_PWM0_Pos)           /*!< PWM POE: POE0 Mask */  
S
S/* PWM TCON Bit Field Definitions */
S#define PWM_TCON_PWM3DTEN_Pos                   11                                  /*!< PWM TCON: PWM3DTEN Position */
S#define PWM_TCON_PWM3DTEN_Msk                   (1ul << PWM_TCON_PWM3DTEN_Pos)      /*!< PWM TCON: PWM3DTEN Mask */   
S
S#define PWM_TCON_PWM2DTEN_Pos                   10                                  /*!< PWM TCON: PWM2DTEN Position */
S#define PWM_TCON_PWM2DTEN_Msk                   (1ul << PWM_TCON_PWM2DTEN_Pos)      /*!< PWM TCON: PWM2DTEN Mask */ 
S
S#define PWM_TCON_PWM1DTEN_Pos                   9                                   /*!< PWM TCON: PWM1DTEN Position */
S#define PWM_TCON_PWM1DTEN_Msk                   (1ul << PWM_TCON_PWM1DTEN_Pos)      /*!< PWM TCON: PWM1DTEN Mask */ 
S
S#define PWM_TCON_PWM0DTEN_Pos                   8                                   /*!< PWM TCON: PWM0DTEN Position */
S#define PWM_TCON_PWM0DTEN_Msk                   (1ul << PWM_TCON_PWM0DTEN_Pos)      /*!< PWM TCON: PWM0DTEN Mask */ 
S
S#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM TCON: PWM3TEN Position */
S#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM TCON: PWM3TEN Mask */ 
S
S#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM TCON: PWM2TEN Position */
S#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM TCON: PWM2TEN Mask */ 
S
S#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM TCON: PWM1TEN Position */
S#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM TCON: PWM1TEN Mask */ 
S
S#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM TCON: PWM0TEN Position */
S#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM TCON: PWM0TEN Mask */ 
S
S#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM TSTATUS: PWM3TF Position */
S#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM TSTATUS: PWM3TF Mask */ 
S
S#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM TSTATUS: PWM2TF Position */
S#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM TSTATUS: PWM2TF Mask */ 
S
S#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM TSTATUS: PWM1TF Position */
S#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM TSTATUS: PWM1TF Mask */ 
S
S#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM TSTATUS: PWM0TF Position */
S#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM TSTATUS: PWM0TF Mask */ 
S
S#define PWM_PSCR_PSSEN3_Pos                     24                                  /*!< PWM PSCR: PSSEN3 Position */
S#define PWM_PSCR_PSSEN3_Msk                     (1ul << PWM_PSCR_PSSEN3_Pos)        /*!< PWM PSCR: PSSEN3 Mask */ 
S
S#define PWM_PSCR_PSSEN2_Pos                     16                                  /*!< PWM PSCR: PSSEN2 Position */
S#define PWM_PSCR_PSSEN2_Msk                     (1ul << PWM_PSCR_PSSEN2_Pos)        /*!< PWM PSCR: PSSEN2 Mask */ 
S
S#define PWM_PSCR_PSSEN1_Pos                     8                                   /*!< PWM PSCR: PSSEN1 Position */
S#define PWM_PSCR_PSSEN1_Msk                     (1ul << PWM_PSCR_PSSEN1_Pos)        /*!< PWM PSCR: PSSEN1 Mask */ 
S
S#define PWM_PSCR_PSSEN0_Pos                     0                                   /*!< PWM PSCR: PSSEN0 Position */
S#define PWM_PSCR_PSSEN0_Msk                     (1ul << PWM_PSCR_PSSEN0_Pos)        /*!< PWM PSCR: PSSEN0 Mask */ 
S/*@}*/ /* end of group M051_PWM */
S
S
S/*----------------------- External Bus Interface Controller ------------------*/
S/** @addtogroup M051_EBI M051 External Bus Interface
S  Memory Mapped Structure for M051 Series External Bus Interface Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * EBICON
S     * ===================================================================================================
S     * Offset: 0x00  EBI Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ExtEN     |EBI Enable 
S     * |        |          |This bit is the functional enable bit for EBI. 
S     * |        |          |0 = EBI function is disabled 
S     * |        |          |1 = EBI function is enabled
S     * |[1]     |ExtBW16   |EBI data width 16 bit 
S     * |        |          |This bit defines if the data bus is 8-bit or 16-bit. 
S     * |        |          |0 = EBI data width is 8 bit 
S     * |        |          |1 = EBI data width is 16 bit
S     * |[10:8]  |MCLKDIV   |External Output Clock Divider 
S     * |        |          |The frequency of EBI output clock is controlled by MCLKDIV.
S     * |        |          |000 = HCLK/1
S     * |        |          |001 = HCLK/2
S     * |        |          |010 = HCLK/4
S     * |        |          |011 = HCLK/8
S     * |        |          |100 = HCLK/16
S     * |        |          |101 = HCKL/32
S     * |        |          |11X = default
S     * |        |          | 
S     * |        |          |Notice: Default value of output clock is HCLK/1
S     * |[18:16] |ExttALE   |Expand Time of ALE 
S     * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE. 
S     * |        |          |tALE = (ExttALE + 1) * MCLK
S     */    
S    __IO uint32_t EBICON;
S
S    /**
S     * EXTIME
S     * ===================================================================================================
S     * Offset: 0x04  EBI Timing Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:3]   |ExttACC   |EBI Data Accesss Time 
S     * |        |          |ExttACC define data access time (tACC). 
S     * |        |          |tACC = (ExttACC + 1) * MCLK
S     * |[10:8]  |ExttAHD   |EBI Data Access Hold Time 
S     * |        |          |ExttAHD define data access hold time (tAHD). 
S     * |        |          |tAHD = (ExttAHD + 1) * MCLK
S     * |[15:12] |ExtIW2X   |Idle State Cycle After Write 
S     * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero. 
S     * |        |          |Idle state cycle = (ExtIW2X * MCLK)
S     * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read 
S     * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS return 
S     * |        |          |to high if ExtIR2R is not zero. 
S     * |        |          |Idle state cycle = (ExtIR2R * MCLK)
S     */    
S    __IO uint32_t EXTIME;
S
S} EBI_T;
S
S/* EBI EBICON Bit Field Definitions */
S#define EBI_EBICON_ExttALE_Pos      16                                          /*!< EBI EBICON: ExttALE Position */
S#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)           /*!< EBI EBICON: ExttALE Mask */
S
S#define EBI_EBICON_MCLKDIV_Pos      8                                           /*!< EBI EBICON: MCLKDIV Position */
S#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)           /*!< EBI EBICON: MCLKDIV Mask */
S
S#define EBI_EBICON_ExtBW16_Pos      1                                           /*!< EBI EBICON: ExtBW16 Position */
S#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)             /*!< EBI EBICON: ExtBW16 Mask */
S
S#define EBI_EBICON_ExtEN_Pos        0                                           /*!< EBI EBICON: ExtEN Position */
S#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)               /*!< EBI EBICON: ExtEN Mask */
S
S/* EBI EXTIME Bit Field Definitions */
S#define EBI_EXTIME_ExtIR2R_Pos      24                                          /*!< EBI EXTIME: ExtIR2R Position */
S#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)           /*!< EBI EXTIME: ExtIR2R Mask */
S
S#define EBI_EXTIME_ExtIW2X_Pos      12                                          /*!< EBI EXTIME: ExtIW2X Position */
S#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)           /*!< EBI EXTIME: ExtIW2X Mask */
S
S#define EBI_EXTIME_ExttAHD_Pos      8                                           /*!< EBI EXTIME: ExttAHD Position */
S#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)           /*!< EBI EXTIME: ExttAHD Mask */
S
S#define EBI_EXTIME_ExttACC_Pos      3                                           /*!< EBI EXTIME: ExttACC Position */
S#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)          /*!< EBI EXTIME: ExttACC Mask */
S/*@}*/ /* end of group M051_EBI */
S
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup M051_PERIPHERAL_MEM_MAP M051 Peripheral Memory Map
S  Memory Mapped Structure for M051 Series Peripheral
S  @{
S */
S/* Peripheral and SRAM base address */
S#define FLASH_BASE          ((     uint32_t)0x00000000)
S#define SRAM_BASE           ((     uint32_t)0x20000000)
S#define AHB_BASE            ((     uint32_t)0x50000000)
S#define APB1_BASE           ((     uint32_t)0x40000000)
S#define APB2_BASE           ((     uint32_t)0x40100000)
S
S/* Peripheral memory map */
S#define GPIO_BASE           (AHB_BASE       + 0x4000)                   /*!< GPIO Base Address                                   */
S#define P0_BASE             (GPIO_BASE              )                   /*!< GPIO P0 Base Address                                */  
S#define P1_BASE             (GPIO_BASE      + 0x0040)                   /*!< GPIO P1 Base Address                                */
S#define P2_BASE             (GPIO_BASE      + 0x0080)                   /*!< GPIO P2 Base Address                                */
S#define P3_BASE             (GPIO_BASE      + 0x00C0)                   /*!< GPIO P3 Base Address                                */
S#define P4_BASE             (GPIO_BASE      + 0x0100)                   /*!< GPIO P4 Base Address                                */
S#define GPIO_DBNCECON_BASE  (GPIO_BASE      + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
S#define GPIO_PIN_DATA_BASE  (GPIO_BASE      + 0x200)                    /*!< GPIO Pin Data Input/Output Control Base Address     */
S
S#define UART0_BASE           (APB1_BASE      + 0x50000)                 /*!< UART0 Base Address                               */
S#define UART1_BASE           (APB2_BASE      + 0x50000)                 /*!< UART1 Base Address                               */
S
S#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
S#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
S#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
S#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
S
S#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watch Dog Timer Base Address                     */
S
S#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watch Dog Timer Base Address              */
S
S#define SPI0_BASE            (APB1_BASE      + 0x30000)                 /*!< SPI0 Base Address                                */
S#define SPI1_BASE            (APB1_BASE      + 0x34000)                 /*!< SPI1 Base Address                                */
S
S#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
S#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
S
S#define RTC_BASE             (APB1_BASE      + 0x08000)                 /*!< RTC Base Address                                 */
S
S#define ADC_BASE             (APB1_BASE      + 0xE0000)                 /*!< ADC Base Address                                 */
S
S#define ACMP0_BASE           (APB1_BASE      + 0xD0000)                 /*!< ACMP0 Base Address                               */
S#define ACMP1_BASE           (APB2_BASE      + 0xD0000)                 /*!< ACMP1 Base Address                               */
S
S#define SYSCLK_BASE          (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
S
S#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
S
S#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
S
S#define FMC_BASE             (AHB_BASE       + 0x0C000)                 /*!< Flash Memory Controller Base Address             */
S
S#define PWMA_BASE            (APB1_BASE      + 0x40000)                 /*!< PWMA Base Address                                */
S#define PWMB_BASE            (APB2_BASE      + 0x40000)                 /*!< PWMB Base Address                                */
S
S#define EBI_BASE             (AHB_BASE       + 0x10000)                 /*!< EBI Base Address                                 */
S
S/*@}*/ /* end of group M051_PERIPHERAL_MEM_MAP */
S
S/******************************************************************************/
S/*                         Peripheral declaration                             */
S/******************************************************************************/ 
S
S/** @addtogroup M051_PERIPHERAL_DECLARATION M051 Peripheral Declaration
S  The Declaration of M051 Series Peripheral
S  @{
S */
S#define P0                  ((GPIO_T *) P0_BASE)                        /*!< GPIO PORT0 Configuration Struct                        */
S#define P1                  ((GPIO_T *) P1_BASE)                        /*!< GPIO PORT1 Configuration Struct                        */
S#define P2                  ((GPIO_T *) P2_BASE)                        /*!< GPIO PORT2 Configuration Struct                        */
S#define P3                  ((GPIO_T *) P3_BASE)                        /*!< GPIO PORT3 Configuration Struct                        */
S#define P4                  ((GPIO_T *) P4_BASE)                        /*!< GPIO PORT4 Configuration Struct                        */
S#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */ 
S
S#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
S#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
S
S#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< TIMER0 Configuration Struct                      */
S#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< TIMER1 Configuration Struct                      */
S#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< TIMER2 Configuration Struct                      */
S#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< TIMER3 Configuration Struct                      */
S
S#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watch Dog Timer Configuration Struct             */
S
S#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watch Dog Timer Configuration Struct      */
S
S#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
S#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
S
S#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
S#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
S
S#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
S
S#define ACMP0               ((ACMP_T *) ACMP0_BASE)                     /*!< ACMP0 Configuration Struct                       */
S#define ACMP1               ((ACMP_T *) ACMP1_BASE)                     /*!< ACMP1 Configuration Struct                       */
S
S#define SYSCLK              ((SYSCLK_T *) SYSCLK_BASE)                  /*!< System Clock Controller Configuration Struct     */
S
S#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
S
S#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
S
S#define FMC                 ((FMC_T *) FMC_BASE)                        /*!< Flash Memory Controller Configuration Struct     */
S
S#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
S#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
S
S#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
S
S/*@}*/ /* end of group M051_PERIPHERAL_DECLARATION */
S
S/*@}*/ /* end of group M051_SERIES_REG */
S
S
S//=============================================================================
Stypedef volatile unsigned char  vu8;
Stypedef volatile unsigned long  vu32;
Stypedef volatile unsigned short vu16;
S#define M8(adr)  (*((vu8  *) (adr)))
S#define M16(adr) (*((vu16 *) (adr)))
S#define M32(adr) (*((vu32 *) (adr)))
S
S#define outpw(port,value)   (*((volatile unsigned int *)(port))=value)
S#define inpw(port)          ((*((volatile unsigned int *)(port))))
S#define outpb(port,value)   (*((volatile unsigned char *)(port))=value)
S#define inpb(port)          ((*((volatile unsigned char *)(port))))
S#define outps(port,value)   (*((volatile unsigned short *)(port))=value)
S#define inps(port)          ((*((volatile unsigned short *)(port))))
S
S#define outp32(port,value)  (*((volatile unsigned int *)(port))=value)
S#define inp32(port)         ((*((volatile unsigned int *)(port))))
S#define outp8(port,value)   (*((volatile unsigned char *)(port))=value)
S#define inp8(port)          ((*((volatile unsigned char *)(port))))
S#define outp16(port,value)  (*((volatile unsigned short *)(port))=value)
S#define inp16(port)         ((*((volatile unsigned short *)(port))))
S
S
S#define E_SUCCESS   0
S#ifndef NULL
S#define NULL        0
S#endif
S
S#define TRUE        1
S#define FALSE       0
S
S#define ENABLE      1
S#define DISABLE     0
S
S/* Bit Mask Definitions */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S
S/******************************************************************************/
S/*                         Peripheral header files                            */
S/******************************************************************************/ 
S#include "SYS.h"
S#include "ADC.h"
S#include "EBI.h"
S#include "FMC.h"
S#include "GPIO.h"
S#include "I2C.h"
S#include "PWM.h"
S#include "SPI.h"
S#include "TIMER.h"
S#include "UART.h"
S#include "ram.h"
S#include "uart_ad.h"
S#include "rambuf.h"
N#endif
N                                                                                                 
N
L 16 "..\..\LibM051Series\StdDriver\inc\SYS.h" 2
N
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup SYS_FUNC SYS Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCON constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_PLLCON_FIN_IRC22M   0x00080000UL        /*!< For PLL clock source is internal RC clock. 4MHz < FIN < 24MHz */ 
N#define SYSCLK_PLLCON_FIN_XTAL     0x00000000UL        /*!< For PLL clock source is external cristal.  4MHz < FIN < 24MHz */
N
N#define SYSCLK_PLLCON_NR(x)        (((x)-2)<<9)        /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 15MHz */
N#define SYSCLK_PLLCON_NF(x)         ((x)-2)            /*!< x must be constant and 2 <= x <= 513. 100MHz < FIN*NF/NR < 200MHz. (120MHz < FIN*NF/NR < 200MHz is preferred.) */ 
N 
N#define SYSCLK_PLLCON_NO_1         0x0000UL            /*!< For output divider is 1 */
N#define SYSCLK_PLLCON_NO_2         0x4000UL            /*!< For output divider is 2 */
N#define SYSCLK_PLLCON_NO_4         0xC000UL            /*!< For output divider is 4 */
N
N#if (__XTAL == 12000000)
X#if ((12000000UL) == 12000000)
N#define SYSCLK_PLLCON_50MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(3) | SYSCLK_PLLCON_NF( 25) | SYSCLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_48MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(7) | SYSCLK_PLLCON_NF(112) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_36MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(7) | SYSCLK_PLLCON_NF( 84) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 36MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_32MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(6) | SYSCLK_PLLCON_NF( 64) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 32MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_24MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(2) | SYSCLK_PLLCON_NF( 16) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 24MHz PLL output with 12MHz X'tal */
N#else
S# error "The PLL pre-definitions are only valid when external crystal is 12MHz"
N#endif
N
N#define SYSCLK_PLLCON_50MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR(13) | SYSCLK_PLLCON_NF( 59) | SYSCLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50.1918MHz PLL output with 22.1184MHz IRC */
N#define SYSCLK_PLLCON_48MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR(13) | SYSCLK_PLLCON_NF(113) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48.064985MHz PLL output with 22.1184MHz IRC*/
N#define SYSCLK_PLLCON_36MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR(12) | SYSCLK_PLLCON_NF( 78) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 35.9424MHz PLL output with 22.1184MHz IRC */
N#define SYSCLK_PLLCON_32MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR( 9) | SYSCLK_PLLCON_NF( 52) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 31.9488MHz PLL output with 22.1184MHz IRC*/
N#define SYSCLK_PLLCON_24MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR( 3) | SYSCLK_PLLCON_NF( 13) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 23.9616MHz PLL output with 22.1184MHz IRC*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKSEL0_HCLK_XTAL          0x00UL /*!< Setting clock source as external X'tal */ 
N#define SYSCLK_CLKSEL0_HCLK_PLL           0x02UL /*!< Setting clock source as PLL output */
N#define SYSCLK_CLKSEL0_HCLK_IRC10K        0x03UL /*!< Setting clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL0_HCLK_IRC22M        0x07UL /*!< Setting clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL0_STCLK_XTAL         0x00UL /*!< Setting clock source as external X'tal */ 
N#define SYSCLK_CLKSEL0_STCLK_XTAL_DIV2    0x10UL /*!< Setting clock source as external X'tal/2 */
N#define SYSCLK_CLKSEL0_STCLK_HCLK_DIV2    0x18UL /*!< Setting clock source as HCLK/2 */
N#define SYSCLK_CLKSEL0_STCLK_IRC22M_DIV2  0x38UL /*!< Setting clock source as internal 22.1184MHz RC clock/2 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKSEL1_WDT_XTAL          0x00000000UL /*!< Setting WDT clock source as external X'tal */ 
N#define SYSCLK_CLKSEL1_WDT_HCLK_DIV2048  0x00000002UL /*!< Setting WDT clock source as HCLK/2048 */
N#define SYSCLK_CLKSEL1_WDT_IRC10K        0x00000003UL /*!< Setting WDT clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL1_ADC_XTAL          0x00000000UL /*!< Setting ADC clock source as external X'tal */
N#define SYSCLK_CLKSEL1_ADC_PLL           0x00000004UL /*!< Setting ADC clock source as PLL */ 
N#define SYSCLK_CLKSEL1_ADC_HCLK          0x00000008UL /*!< Setting ADC clock source as HCLK */
N#define SYSCLK_CLKSEL1_ADC_IRC22M        0x0000000CUL /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_TMR0_XTAL         0x00000000UL /*!< Setting Timer 0 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR0_HCLK         0x00000200UL /*!< Setting Timer 0 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR0_IRC22M       0x00000700UL /*!< Setting Timer 0 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_TMR1_XTAL         0x00000000UL /*!< Setting Timer 1 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR1_HCLK         0x00002000UL /*!< Setting Timer 1 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR1_IRC22M       0x00007000UL /*!< Setting Timer 1 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_TMR2_XTAL         0x00000000UL /*!< Setting Timer 2 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR2_HCLK         0x00020000UL /*!< Setting Timer 2 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR2_IRC22M       0x00070000UL /*!< Setting Timer 2 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_TMR3_XTAL         0x00000000UL /*!< Setting Timer 3 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR3_HCLK         0x00200000UL /*!< Setting Timer 3 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR3_IRC22M       0x00700000UL /*!< Setting Timer 3 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_UART_XTAL         0x00000000UL /*!< Setting UART clock source as external X'tal */
N#define SYSCLK_CLKSEL1_UART_PLL          0x01000000UL /*!< Setting UART clock source as external PLL */
N#define SYSCLK_CLKSEL1_UART_IRC22M       0x03000000UL /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_PWM01_XTAL        0x00000000UL /*!< Setting PWM01 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_PWM01_HCLK        0x20000000UL /*!< Setting PWM01 clock source as external HCLK */
N#define SYSCLK_CLKSEL1_PWM01_IRC22M      0x30000000UL /*!< Setting PWM01 clock source as external internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_PWM23_XTAL        0x00000000UL /*!< Setting PWM23 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_PWM23_HCLK        0x80000000UL /*!< Setting PWM23 clock source as external HCLK */
N#define SYSCLK_CLKSEL1_PWM23_IRC22M      0xC0000000UL /*!< Setting PWM23 clock source as external internal 22.1184MHz RC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKSEL2_FRQDIV_XTAL        0x00000000UL /*!< Setting FRQDIV clock source as external X'tal */ 
N#define SYSCLK_CLKSEL2_FRQDIV_HCLK        0x00000008UL /*!< Setting FRQDIV clock source as HCLK */
N#define SYSCLK_CLKSEL2_FRQDIV_IRC22M      0x0000000CUL /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL2_PWM45_XTAL         0x00000000UL /*!< Setting PWM45 clock source as external X'tal */ 
N#define SYSCLK_CLKSEL2_PWM45_HCLK         0x00000020UL /*!< Setting PWM45 clock source as HCLK */
N#define SYSCLK_CLKSEL2_PWM45_IRC22M       0x00000030UL /*!< Setting PWM45 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL2_PWM67_XTAL         0x00000000UL /*!< Setting PWM67 clock source as external X'tal */ 
N#define SYSCLK_CLKSEL2_PWM67_HCLK         0x00000080UL /*!< Setting PWM67 clock source as HCLK */
N#define SYSCLK_CLKSEL2_PWM67_IRC22M       0x000000C0UL /*!< Setting PWM67 clock source as internal 22.1184MHz RC clock */
N
N       
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKDIV_ADC(x)  (((x)-1) << 16) /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */ 
N#define SYSCLK_CLKDIV_UART(x) (((x)-1) <<  8) /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */ 
N#define SYSCLK_CLKDIV_HCLK(x)  ((x)-1)        /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */ 
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_MFP_TYPE_Msk(bit)       (1UL << ((bit) +16))
N#define SYS_MFP_ALT_Msk(bit)        (1UL << ((bit) + 8))
N#define SYS_MFP_MFP_Msk(bit)        (1UL << ((bit)    ))
N
N#define SYS_MFP_P00_GPIO    0x00000000UL /*!< P0_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P00_AD0     0x00000001UL /*!< P0_MFP pin 0 setting for AD0  */      
N#define SYS_MFP_P00_CTS1    0x00000100UL /*!< P0_MFP pin 0 setting for CTS1 */      
N#define SYS_MFP_P00_TXD1    0x00000101UL /*!< P0_MFP pin 0 setting for TXD1 */      
N#define SYS_MFP_P00_Msk     0x01000101UL /*!< P0_MFP pin 0 mask             */      
N        
N#define SYS_MFP_P01_GPIO    0x00000000UL /*!< P0_MFP pin 1 setting for GPIO */      
N#define SYS_MFP_P01_AD1     0x00000002UL /*!< P0_MFP pin 1 setting for AD1  */      
N#define SYS_MFP_P01_RTS1    0x00000200UL /*!< P0_MFP pin 1 setting for RTS1 */      
N#define SYS_MFP_P01_RXD1    0x00000202UL /*!< P0_MFP pin 1 setting for RXD1 */      
N#define SYS_MFP_P01_Msk     0x02000202UL /*!< P0_MFP pin 1 mask             */      
N        
N#define SYS_MFP_P02_GPIO    0x00000000UL /*!< P0_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P02_AD2     0x00000004UL /*!< P0_MFP pin 2 setting for AD2  */
N#define SYS_MFP_P02_CTS0    0x00000400UL /*!< P0_MFP pin 2 setting for CTS0 */
N#define SYS_MFP_P02_TXD0    0x00000404UL /*!< P0_MFP pin 2 setting for TXD0 */
N#define SYS_MFP_P02_Msk     0x00000404UL /*!< P0_MFP pin 2 mask             */      
N        
N#define SYS_MFP_P03_GPIO    0x00000000UL /*!< P0_MFP pin 3 setting for GPIO */      
N#define SYS_MFP_P03_AD3     0x00000008UL /*!< P0_MFP pin 3 setting for AD3  */      
N#define SYS_MFP_P03_RTS0    0x00000800UL /*!< P0_MFP pin 3 setting for RTS0 */      
N#define SYS_MFP_P03_RXD0    0x00000808UL /*!< P0_MFP pin 3 setting for RXD0 */      
N#define SYS_MFP_P03_Msk     0x00000808UL /*!< P0_MFP pin 3 mask             */      
N        
N#define SYS_MFP_P04_GPIO    0x00000000UL /*!< P0_MFP pin 4 setting for GPIO   */      
N#define SYS_MFP_P04_AD4     0x00000010UL /*!< P0_MFP pin 4 setting for AD4    */      
N#define SYS_MFP_P04_SPISS1  0x00001000UL /*!< P0_MFP pin 4 setting for SPISS1 */      
N#define SYS_MFP_P04_Msk     0x00001010UL /*!< P0_MFP pin 4 mask               */      
N        
N#define SYS_MFP_P05_GPIO    0x00000000UL /*!< P0_MFP pin 5 setting for GPIO   */      
N#define SYS_MFP_P05_AD5     0x00000020UL /*!< P0_MFP pin 5 setting for AD5    */      
N#define SYS_MFP_P05_MOSI_1  0x00002000UL /*!< P0_MFP pin 5 setting for MOSI_1 */      
N#define SYS_MFP_P05_Msk     0x00002020UL /*!< P0_MFP pin 5 mask               */      
N        
N#define SYS_MFP_P06_GPIO    0x00000000UL /*!< P0_MFP pin 6 setting for GPIO   */      
N#define SYS_MFP_P06_AD6     0x00000040UL /*!< P0_MFP pin 6 setting for AD6    */      
N#define SYS_MFP_P06_MISO_1  0x00004000UL /*!< P0_MFP pin 6 setting for MISO_1 */      
N#define SYS_MFP_P06_Msk     0x00004040UL /*!< P0_MFP pin 6 mask               */      
N        
N#define SYS_MFP_P07_GPIO    0x00000000UL /*!< P0_MFP pin 7 setting for GPIO    */      
N#define SYS_MFP_P07_AD7     0x00000080UL /*!< P0_MFP pin 7 setting for AD7     */      
N#define SYS_MFP_P07_SPICLK1 0x00008000UL /*!< P0_MFP pin 7 setting for SPICLK1 */      
N#define SYS_MFP_P07_Msk     0x00008080UL /*!< P0_MFP pin 7 mask                */      
N        
N#define SYS_MFP_P10_GPIO    0x00000000UL /*!< P1_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P10_AIN0    0x00000001UL /*!< P1_MFP pin 0 setting for AIN0 */      
N#define SYS_MFP_P10_T2      0x00000100UL /*!< P1_MFP pin 0 setting for T2   */      
N#define SYS_MFP_P10_nWRL    0x00000101UL /*!< P1_MFP pin 0 setting for nWRL */      
N#define SYS_MFP_P10_Msk     0x00000101UL /*!< P1_MFP pin 0 mask             */      
N        
N#define SYS_MFP_P11_GPIO    0x00000000UL /*!< P1_MFP pin 1 setting for GPIO */  
N#define SYS_MFP_P11_AIN1    0x00000002UL /*!< P1_MFP pin 1 setting for AIN1 */      
N#define SYS_MFP_P11_T3      0x00000200UL /*!< P1_MFP pin 1 setting for T3   */      
N#define SYS_MFP_P11_nWRH    0x00000202UL /*!< P1_MFP pin 1 setting for nWRH */      
N#define SYS_MFP_P11_Msk     0x00000202UL /*!< P1_MFP pin 1 mask             */      
N        
N#define SYS_MFP_P12_GPIO    0x00000000UL /*!< P1_MFP pin 2 setting for GPIO */      
N#define SYS_MFP_P12_AIN2    0x00000004UL /*!< P1_MFP pin 2 setting for AIN2 */      
N#define SYS_MFP_P12_RXD1    0x00000400UL /*!< P1_MFP pin 2 setting for RXD1 */      
N#define SYS_MFP_P12_Msk     0x00000404UL /*!< P1_MFP pin 2 mask             */      
N        
N#define SYS_MFP_P13_GPIO    0x00000000UL /*!< P1_MFP pin 3 setting for GPIO */      
N#define SYS_MFP_P13_AIN3    0x00000008UL /*!< P1_MFP pin 3 setting for AIN3 */      
N#define SYS_MFP_P13_TXD1    0x00000800UL /*!< P1_MFP pin 3 setting for TXD1 */      
N#define SYS_MFP_P13_Msk     0x00000808UL /*!< P1_MFP pin 3 mask             */      
N        
N#define SYS_MFP_P14_GPIO    0x00000000UL /*!< P1_MFP pin 4 setting for GPIO   */      
N#define SYS_MFP_P14_AIN4    0x00000010UL /*!< P1_MFP pin 4 setting for AIN4   */      
N#define SYS_MFP_P14_SPISS0  0x00001000UL /*!< P1_MFP pin 4 setting for SPISS0 */      
N#define SYS_MFP_P14_CPN0    0x00001010UL /*!< P1_MFP pin 4 setting for CPN0   */      
N#define SYS_MFP_P14_Msk     0x00001010UL /*!< P1_MFP pin 4 mask               */      
N        
N#define SYS_MFP_P15_GPIO    0x00000000UL /*!< P1_MFP pin 5 setting for GPIO   */      
N#define SYS_MFP_P15_AIN5    0x00000020UL /*!< P1_MFP pin 5 setting for AIN5   */      
N#define SYS_MFP_P15_MOSI_0  0x00002000UL /*!< P1_MFP pin 5 setting for MOSI_0 */      
N#define SYS_MFP_P15_CPP0    0x00002020UL /*!< P1_MFP pin 5 setting for CPP0   */      
N#define SYS_MFP_P15_Msk     0x00002020UL /*!< P1_MFP pin 5 mask               */      
N        
N#define SYS_MFP_P16_GPIO    0x00000000UL /*!< P1_MFP pin 6 setting for GPIO   */
N#define SYS_MFP_P16_AIN6    0x00000040UL /*!< P1_MFP pin 6 setting for AIN6   */      
N#define SYS_MFP_P16_MISO_0  0x00004000UL /*!< P1_MFP pin 6 setting for MISO_0 */      
N#define SYS_MFP_P16_Msk     0x00004040UL /*!< P1_MFP pin 6 mask               */      
N        
N#define SYS_MFP_P17_GPIO    0x00000000UL /*!< P1_MFP pin 7 setting for GPIO    */      
N#define SYS_MFP_P17_AIN7    0x00000080UL /*!< P1_MFP pin 7 setting for AIN7    */      
N#define SYS_MFP_P17_SPICLK0 0x00008000UL /*!< P1_MFP pin 7 setting for SPICLK0 */      
N#define SYS_MFP_P17_Msk     0x00008080UL /*!< P1_MFP pin 7 mask                */      
N        
N#define SYS_MFP_P20_GPIO    0x00000000UL /*!< P2_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P20_AD8     0x00000001UL /*!< P2_MFP pin 0 setting for AD8  */      
N#define SYS_MFP_P20_PWM0    0x00000100UL /*!< P2_MFP pin 0 setting for PWM0 */      
N#define SYS_MFP_P20_Msk     0x00000101UL /*!< P2_MFP pin 0 mask             */      
N        
N#define SYS_MFP_P21_GPIO    0x00000000UL /*!< P2_MFP pin 1 setting for GPIO */      
N#define SYS_MFP_P21_AD9     0x00000002UL /*!< P2_MFP pin 1 setting for AD9  */      
N#define SYS_MFP_P21_PWM1    0x00000200UL /*!< P2_MFP pin 1 setting for PWM1 */      
N#define SYS_MFP_P21_Msk     0x00000202UL /*!< P2_MFP pin 1 mask             */      
N        
N#define SYS_MFP_P22_GPIO    0x00000000UL /*!< P2_MFP pin 2 setting for GPIO */      
N#define SYS_MFP_P22_AD10    0x00000004UL /*!< P2_MFP pin 2 setting for AD10 */      
N#define SYS_MFP_P22_PWM2    0x00000400UL /*!< P2_MFP pin 2 setting for PWM2 */      
N#define SYS_MFP_P22_Msk     0x00000404UL /*!< P2_MFP pin 2 mask             */      
N        
N#define SYS_MFP_P23_GPIO    0x00000000UL /*!< P2_MFP pin 3 setting for GPIO */      
N#define SYS_MFP_P23_AD11    0x00000008UL /*!< P2_MFP pin 3 setting for AD11 */      
N#define SYS_MFP_P23_PWM3    0x00000800UL /*!< P2_MFP pin 3 setting for PWM3 */      
N#define SYS_MFP_P23_Msk     0x00000808UL /*!< P2_MFP pin 3 mask             */      
N        
N#define SYS_MFP_P24_GPIO    0x00000000UL /*!< P2_MFP pin 4 setting for GPIO */      
N#define SYS_MFP_P24_AD12    0x00000010UL /*!< P2_MFP pin 4 setting for AD12 */      
N#define SYS_MFP_P24_PWM4    0x00001000UL /*!< P2_MFP pin 4 setting for PWM4 */      
N#define SYS_MFP_P24_Msk     0x00001010UL /*!< P2_MFP pin 4 mask             */      
N        
N#define SYS_MFP_P25_GPIO    0x00000000UL /*!< P2_MFP pin 5 setting for GPIO */      
N#define SYS_MFP_P25_AD13    0x00000020UL /*!< P2_MFP pin 5 setting for AD13 */      
N#define SYS_MFP_P25_PWM5    0x00002000UL /*!< P2_MFP pin 5 setting for PWM5 */      
N#define SYS_MFP_P25_Msk     0x00002020UL /*!< P2_MFP pin 5 mask             */      
N        
N#define SYS_MFP_P26_GPIO    0x00000000UL /*!< P2_MFP pin 6 setting for GPIO */      
N#define SYS_MFP_P26_AD14    0x00000040UL /*!< P2_MFP pin 6 setting for AD14 */      
N#define SYS_MFP_P26_PWM6    0x00004000UL /*!< P2_MFP pin 6 setting for PWM6 */      
N#define SYS_MFP_P26_CPO1    0x00004040UL /*!< P2_MFP pin 6 setting for CPO1 */      
N#define SYS_MFP_P26_Msk     0x00004040UL /*!< P2_MFP pin 6 mask             */      
N        
N#define SYS_MFP_P27_GPIO    0x00000000UL /*!< P2_MFP pin 7 setting for GPIO */      
N#define SYS_MFP_P27_AD15    0x00000080UL /*!< P2_MFP pin 7 setting for AD15 */      
N#define SYS_MFP_P27_PWM7    0x00008000UL /*!< P2_MFP pin 7 setting for PWM7 */      
N#define SYS_MFP_P27_Msk     0x00008080UL /*!< P2_MFP pin 7 mask             */      
N
N#define SYS_MFP_P30_GPIO    0x00000000UL /*!< P3_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P30_RXD0    0x00000001UL /*!< P3_MFP pin 0 setting for RXD0 */      
N#define SYS_MFP_P30_CPN1    0x00000100UL /*!< P3_MFP pin 0 setting for CPN1 */      
N#define SYS_MFP_P30_Msk     0x00000101UL /*!< P3_MFP pin 0 mask             */      
N
N#define SYS_MFP_P31_GPIO    0x00000000UL /*!< P3_MFP pin 1 setting for GPIO */      
N#define SYS_MFP_P31_TXD0    0x00000002UL /*!< P3_MFP pin 1 setting for TXD0 */      
N#define SYS_MFP_P31_CPP1    0x00000200UL /*!< P3_MFP pin 1 setting for CPP1 */      
N#define SYS_MFP_P31_Msk     0x00000202UL /*!< P3_MFP pin 1 mask             */      
N
N#define SYS_MFP_P32_GPIO    0x00000000UL /*!< P3_MFP pin 2 setting for GPIO  */
N#define SYS_MFP_P32_INT0    0x00000004UL /*!< P3_MFP pin 2 setting for /INT0 */            
N#define SYS_MFP_P32_T0EX    0x00000400UL /*!< P3_MFP pin 2 setting for T0EX  */      
N#define SYS_MFP_P32_Msk     0x00000404UL /*!< P3_MFP pin 2 mask              */      
N
N#define SYS_MFP_P33_GPIO    0x00000000UL /*!< P3_MFP pin 3 setting for GPIO  */
N#define SYS_MFP_P33_INT1    0x00000008UL /*!< P3_MFP pin 3 setting for /INT1 */
N#define SYS_MFP_P33_MCLK    0x00000800UL /*!< P3_MFP pin 3 setting for MCLK  */
N#define SYS_MFP_P33_T1EX    0x00000808UL /*!< P3_MFP pin 3 setting for T1EX  */
N#define SYS_MFP_P33_Msk     0x00000808UL /*!< P3_MFP pin 3 mask              */
N
N#define SYS_MFP_P34_GPIO    0x00000000UL /*!< P3_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P34_T0      0x00000010UL /*!< P3_MFP pin 4 setting for T0   */
N#define SYS_MFP_P34_SDA0    0x00001000UL /*!< P3_MFP pin 4 setting for SDA0 */
N#define SYS_MFP_P34_Msk     0x00001010UL /*!< P3_MFP pin 4 mask             */
N
N#define SYS_MFP_P35_GPIO    0x00000000UL /*!< P3_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P35_T1      0x00000020UL /*!< P3_MFP pin 5 setting for T1   */
N#define SYS_MFP_P35_SCL0    0x00002000UL /*!< P3_MFP pin 5 setting for SCL0 */
N#define SYS_MFP_P35_Msk     0x00002020UL /*!< P3_MFP pin 5 mask             */
N
N#define SYS_MFP_P36_GPIO    0x00000000UL /*!< P3_MFP pin 6 setting for GPIO */
N#define SYS_MFP_P36_nWR     0x00000040UL /*!< P3_MFP pin 6 setting for nWR  */
N#define SYS_MFP_P36_CKO     0x00004000UL /*!< P3_MFP pin 6 setting for CKO  */
N#define SYS_MFP_P36_CPO0    0x00004040UL /*!< P3_MFP pin 6 setting for CPO0 */
N#define SYS_MFP_P36_Msk     0x00004040UL /*!< P3_MFP pin 6 mask             */
N
N#define SYS_MFP_P37_GPIO    0x00000000UL /*!< P3_MFP pin 7 setting for GPIO */
N#define SYS_MFP_P37_nRD     0x00000080UL /*!< P3_MFP pin 7 setting for nWR  */
N#define SYS_MFP_P37_Msk     0x00008080UL /*!< P3_MFP pin 7 mask             */
N
N#define SYS_MFP_P40_GPIO    0x00000000UL /*!< P4_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P40_PWM0    0x00000001UL /*!< P4_MFP pin 0 setting for PWM0 */
N#define SYS_MFP_P40_T2EX    0x00000100UL /*!< P4_MFP pin 0 setting for T2EX */
N#define SYS_MFP_P40_Msk     0x00000101UL /*!< P4_MFP pin 0 mask             */
N
N#define SYS_MFP_P41_GPIO    0x00000000UL /*!< P4_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P41_PWM1    0x00000002UL /*!< P4_MFP pin 1 setting for PWM1 */
N#define SYS_MFP_P41_T3EX    0x00000200UL /*!< P4_MFP pin 1 setting for T3EX */
N#define SYS_MFP_P41_Msk     0x00000202UL /*!< P4_MFP pin 1 mask             */
N
N#define SYS_MFP_P42_GPIO    0x00000000UL /*!< P4_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P42_PWM2    0x00000004UL /*!< P4_MFP pin 2 setting for PWM2 */
N#define SYS_MFP_P42_Msk     0x00000404UL /*!< P4_MFP pin 2 mask             */
N
N#define SYS_MFP_P43_GPIO    0x00000000UL /*!< P4_MFP pin 3 setting for GPIO */
N#define SYS_MFP_P43_PWM3    0x00000008UL /*!< P4_MFP pin 3 setting for PWM3 */
N#define SYS_MFP_P43_Msk     0x00000808UL /*!< P4_MFP pin 3 mask             */
N
N#define SYS_MFP_P44_GPIO    0x00000000UL /*!< P4_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P44_nCS     0x00000010UL /*!< P4_MFP pin 4 setting for nCS  */
N#define SYS_MFP_P44_Msk     0x00001010UL /*!< P4_MFP pin 4 mask             */
N
N#define SYS_MFP_P45_GPIO    0x00000000UL /*!< P4_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P45_ALE     0x00000020UL /*!< P4_MFP pin 5 setting for ALE  */
N#define SYS_MFP_P45_Msk     0x00002020UL /*!< P4_MFP pin 5 mask             */
N
N#define SYS_MFP_P46_GPIO    0x00000000UL /*!< P4_MFP pin 6 setting for GPIO    */
N#define SYS_MFP_P46_ICE_CLK 0x00000040UL /*!< P4_MFP pin 6 setting for ICE_CLK */
N#define SYS_MFP_P46_Msk     0x00004040UL /*!< P4_MFP pin 6 mask                */
N        
N#define SYS_MFP_P47_GPIO    0x00000000UL /*!< P4_MFP pin 7 setting for GPIO    */
N#define SYS_MFP_P47_ICE_DAT 0x00000080UL /*!< P4_MFP pin 7 setting for ICE_DAT */
N#define SYS_MFP_P47_Msk     0x00008080UL /*!< P4_MFP pin 7 mask                */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_VL_4_5V     0x06UL       /*!< Setting Brown Out Detector Threshold Voltage as 4.5V */
N#define SYS_BODCR_BOD_VL_3_8V     0x04UL       /*!< Setting Brown Out Detector Threshold Voltage as 3.8V */ 
N#define SYS_BODCR_BOD_VL_2_7V     0x02UL       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V     0x00UL       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macro                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define _SYS_RESET_CPU()   (SYS->IPRSTC1 |= SYS_IPRSTC1_CPU_RST_Msk) /*!< Reset CPU by setting CPU_RST bit from IPRSTC1 Register         */
N#define _SYS_RESET_CHIP()  (SYS->IPRSTC1 = SYS_IPRSTC1_CHIP_RST_Msk) /*!< Reset Whole Chip by setting CHIP_RST bit from IPRSTC1 Register */
N#define _SYS_P00_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P00_Msk)) | (x))
N#define _SYS_P01_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P01_Msk)) | (x))
N#define _SYS_P02_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P02_Msk)) | (x))
N#define _SYS_P03_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P03_Msk)) | (x))
N#define _SYS_P04_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P04_Msk)) | (x))
N#define _SYS_P05_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P05_Msk)) | (x))
N#define _SYS_P06_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P06_Msk)) | (x))
N#define _SYS_P07_MFP(x)    (SYS->P0_MFP = (SYS->P0_MFP & (~SYS_MFP_P07_Msk)) | (x))
N
N#define _SYS_P10_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P10_Msk)) | (x))
N#define _SYS_P11_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P11_Msk)) | (x))
N#define _SYS_P12_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P12_Msk)) | (x))
N#define _SYS_P13_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P13_Msk)) | (x))
N#define _SYS_P14_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P14_Msk)) | (x))
N#define _SYS_P15_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P15_Msk)) | (x))
N#define _SYS_P16_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P16_Msk)) | (x))
N#define _SYS_P17_MFP(x)    (SYS->P1_MFP = (SYS->P1_MFP & (~SYS_MFP_P17_Msk)) | (x))
N
N#define _SYS_P20_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P20_Msk)) | (x))
N#define _SYS_P21_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P21_Msk)) | (x))
N#define _SYS_P22_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P22_Msk)) | (x))
N#define _SYS_P23_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P23_Msk)) | (x))
N#define _SYS_P24_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P24_Msk)) | (x))
N#define _SYS_P25_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P25_Msk)) | (x))
N#define _SYS_P26_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P26_Msk)) | (x))
N#define _SYS_P27_MFP(x)    (SYS->P2_MFP = (SYS->P2_MFP & (~SYS_MFP_P27_Msk)) | (x))
N
N#define _SYS_P30_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P30_Msk)) | (x))
N#define _SYS_P31_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P31_Msk)) | (x))
N#define _SYS_P32_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P32_Msk)) | (x))
N#define _SYS_P33_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P33_Msk)) | (x))
N#define _SYS_P34_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P34_Msk)) | (x))
N#define _SYS_P35_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P35_Msk)) | (x))
N#define _SYS_P36_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P36_Msk)) | (x))
N#define _SYS_P37_MFP(x)    (SYS->P3_MFP = (SYS->P3_MFP & (~SYS_MFP_P37_Msk)) | (x))
N
N#define _SYS_P40_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P40_Msk)) | (x))
N#define _SYS_P41_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P41_Msk)) | (x))
N#define _SYS_P42_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P42_Msk)) | (x))
N#define _SYS_P43_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P43_Msk)) | (x))
N#define _SYS_P44_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P44_Msk)) | (x))
N#define _SYS_P45_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P45_Msk)) | (x))
N#define _SYS_P46_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P46_Msk)) | (x))
N#define _SYS_P47_MFP(x)    (SYS->P4_MFP = (SYS->P4_MFP & (~SYS_MFP_P47_Msk)) | (x))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief    Get PLL Clock Output Frequency  
N *
N * @param    None
N *
N * @return   PLL clock output frequency 
N *
N * @details  To get actual PLL clock output frequency. The clock uint is in Hz.
N */
Nstatic __INLINE uint32_t DrvSYS_GetPLLClockFreq(void)
Xstatic __inline uint32_t DrvSYS_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUT_DV :DEF: {1, 2, 2, 4} */
N    uint32_t u32Reg;
N
N    u32PllFreq = 0;
N    u32Reg = SYSCLK->PLLCON;
X    u32Reg = ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON;
N    if((u32Reg & (SYSCLK_PLLCON_PD_Msk | SYSCLK_PLLCON_OE_Msk)) == 0)
X    if((u32Reg & ((1ul << 16) | (1ul << 18))) == 0)
N    {    
N        /* PLL is enabled and output enabled */
N
N        u32FIN = (u32Reg & SYSCLK_PLLCON_PLL_SRC_Msk)?__IRC22M:__XTAL;
X        u32FIN = (u32Reg & (1ul << 19))?(22118400UL):(12000000UL);
N        if(u32Reg & SYSCLK_PLLCON_BP_Msk)
X        if(u32Reg & (1ul << 17))
N        {
N            /* PLL is in bypass mode */
N            u32PllFreq = u32FIN;
N        }
N        else 
N        {
N            /* PLL is in normal work mode */
N            u32NO = au8NoTbl[((u32Reg & SYSCLK_PLLCON_OUT_DV_Msk) >> SYSCLK_PLLCON_OUT_DV_Pos)];
X            u32NO = au8NoTbl[((u32Reg & (3ul << 14)) >> 14)];
N            u32NF  = ((u32Reg & SYSCLK_PLLCON_FB_DV_Msk) >> SYSCLK_PLLCON_FB_DV_Pos) + 2;
X            u32NF  = ((u32Reg & (0x1FFul << 0)) >> 0) + 2;
N            u32NR  = ((u32Reg & SYSCLK_PLLCON_IN_DV_Msk) >> SYSCLK_PLLCON_IN_DV_Pos) + 2;
X            u32NR  = ((u32Reg & (0x1Ful << 9)) >> 9) + 2;
N            /* u32FIN is shifted 2 bits to avoid overflow */
N            u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2); 
N        }
N    }
N
N    return u32PllFreq;
N}
N
N
N/**
N * @brief    Waiting for clock stable
N *
N * @param    Mask bits of CLKSTATUS register. Including:
N *           SYSCLK_CLKSTATUS_CLK_SW_FAIL_Msk
N *           SYSCLK_CLKSTATUS_IRC22M_STB_Msk
N *           SYSCLK_CLKSTATUS_IRC10K_STB_Msk
N *           SYSCLK_CLKSTATUS_PLL_STB_Msk
N *           SYSCLK_CLKSTATUS_XTL12M_STB_Msk
N *
N * @return   None
N *
N * @details  To wait for clock ready by specified CLKSTATUS bit or timeout (~5ms)
N */
Nstatic __INLINE void SYS_WaitingForClockReady(uint32_t u32Mask)
Xstatic __inline void SYS_WaitingForClockReady(uint32_t u32Mask)
N{
N    int32_t i32TimeOutCnt;
N
N    i32TimeOutCnt = __HSI / 200; /* About 5ms */
X    i32TimeOutCnt = (50000000UL) / 200;  
N    
N    while((SYSCLK->CLKSTATUS & u32Mask) != u32Mask)
X    while((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSTATUS & u32Mask) != u32Mask)
N    {
N        if(i32TimeOutCnt-- <= 0)
N            break;    
N    }
N}
N
N/**
N * @brief      Generate the Delay Time by Systick
N *
N * @param[in]  us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N *                             50MHz => 335544us, 48MHz => 349525us, 28MHz => 699050us ...
N *
N * @return     None
N *
N * @details    Use the SysTick to generate the delay time and the UNIT is in us. 
N *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N */
Nstatic __INLINE void SYS_SysTickDelay(uint32_t us)
Xstatic __inline void SYS_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD = us * CyclesPerUs;
N    SysTick->VAL  =  (0x00);
X    ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL  =  (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL = (1ul << 2) | (1ul << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL & (1ul << 16)) == 0);
N}
N
N
N/**
N * @brief      Enable CKO clock
N *
N * @param[in]  u32ClkSrc  Select the source clock for CKO. It could be 
N *                        SYSCLK_CLKSEL2_FRQDIV_XTAL, SYSCLK_CLKSEL2_FRQDIV_HCLK or SYSCLK_CLKSEL2_FRQDIV_IRC22M.
N * @param[in]  u32ClkDiv  Set the clock divider to CKO. 0 <= u32ClkDiv <= 15
N *
N * @return     None
N *
N * @details    Ouput selected clock to CKO. The output clock frequency is divided by u32ClkDiv. 
N *             The formula is:
N *                 CKO frequency = (Clock source frequency) / 2^(u32ClkDiv + 1)
N *             This function is just used to set CKO clock.
N *             User must enable I/O for CKO clock output pin by themselves.
N */
Nstatic __INLINE void SYS_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
Xstatic __inline void SYS_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
N{
N    /* CKO = clock source / 2^(u32ClkDiv + 1) */
N    SYSCLK->FRQDIV = SYSCLK_FRQDIV_DIVIDER_EN_Msk | u32ClkDiv;
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->FRQDIV = (1ul << 4) | u32ClkDiv;
N
N    /* Enable CKO clock source */
N    SYSCLK->APBCLK |= SYSCLK_APBCLK_FDIV_EN_Msk;
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->APBCLK |= (1ul << 6);
N
N    /* Select CKO clock source */
N    SYSCLK->CLKSEL2 = (SYSCLK->CLKSEL2 & (~SYSCLK_CLKSEL2_FRQDIV_S_Msk)) | u32ClkSrc;
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL2 = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL2 & (~(3ul << 2))) | u32ClkSrc;
N}
N
N
N/**
N * @brief      Disable CKO clock
N *
N * @return     None
N *
N * @details    Disable CKO clock 
N *
N */
Nstatic __INLINE void SYS_DisableCKO(void)
Xstatic __inline void SYS_DisableCKO(void)
N{
N    /* Disable CKO clock source */
N    SYSCLK->APBCLK &= (~SYSCLK_APBCLK_FDIV_EN_Msk);
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->APBCLK &= (~(1ul << 6));
N}
N
N/**
N * @brief      Initialization for power down (Deep sleep)
N *
N * @details    To inital the power down control registers
N *
N * @note   
N *             User must call SYS_UnlockReg() to unlock protected registers before calling this function 
N */
Nstatic __INLINE void SYS_PowerDownInit(void)
Xstatic __inline void SYS_PowerDownInit(void)
N{   
N    SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SCR = (1ul << 2);
N    SYSCLK->PWRCON |= (SYSCLK_PWRCON_PD_WAIT_CPU_Msk | SYSCLK_PWRCON_PWR_DOWN_EN_Msk | SYSCLK_PWRCON_PD_WU_STS_Msk);
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PWRCON |= ((1ul << 8) | (1ul << 7) | (1ul << 6));
N}
N
N
N/**
N * @brief      Unlock the protected registers
N *
N * @details    To unlock the protected register to allow write access
N *
N */
Nstatic __INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{   
N    SYS->REGWRPROT = 0x59;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x59;
N    SYS->REGWRPROT = 0x16;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x16;
N    SYS->REGWRPROT = 0x88;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x88;
N}
N
N/**
N * @brief      Lock the protected registers
N *
N * @details    To lock the protected register to forbid write access
N *
N */
Nstatic __INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{   
N    SYS->REGWRPROT = 0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0;
N}
N/**
N  * @} End of SYS Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif
N
L 6183 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "ADC.h"
L 1 "..\..\LibM051Series\StdDriver\inc\ADC.h" 1
N/**************************************************************************//**
N * @file     ADC.h
N * @version  V2.1
N * $Revision: 7 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series ADC Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "M051Series.h"
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup ADC_FUNC ADC Device Function Interface
N  * @{
N  */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADCR Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCR_ADEN_CONVERTER_DISABLE   (0UL<<ADC_ADCR_ADEN_Pos)     /*!< ADC Converter Disable          */
N#define ADC_ADCR_ADEN_CONVERTER_ENABLE    (1UL<<ADC_ADCR_ADEN_Pos)     /*!< ADC Converter Enable           */
N
N#define ADC_ADCR_ADMD_SINGLE            (0UL<<ADC_ADCR_ADMD_Pos)     /*!< Single mode                */
N#define ADC_ADCR_ADMD_BURST             (1UL<<ADC_ADCR_ADMD_Pos)     /*!< Burst mode                 */
N#define ADC_ADCR_ADMD_SINGLE_CYCLE      (2UL<<ADC_ADCR_ADMD_Pos)     /*!< Single cycle scan mode     */
N#define ADC_ADCR_ADMD_CONTINUOUS        (3UL<<ADC_ADCR_ADMD_Pos)     /*!< Continuous scan mode       */
N
N#define ADC_ADCR_DIFFEN_SINGLE_END      (0UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Single end input mode      */
N#define ADC_ADCR_DIFFEN_DIFFERENTIAL    (1UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Differential input type    */
N
N#define ADC_ADCR_DMOF_UNSIGNED_OUTPUT   (0UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define ADC_ADCR_DMOF_TWOS_COMPLEMENT   (1UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N#define ADC_ADCR_TRGEN_DISABLE          (0UL<<ADC_ADCR_TRGEN_Pos)    /*!< Enable or disable triggering of A/D conversion by external STADC pin.   */
N#define ADC_ADCR_TRGEN_ENABLE           (1UL<<ADC_ADCR_TRGEN_Pos)    /*!< Disable or disable triggering of A/D conversion by external STADC pin.  */
N
N#define ADC_ADCR_TRGS_STADC             (0UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by external STADC pin.*/
N
N#define ADC_ADCR_TRGCOND_LOW_LEVEL      (0UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Low level active     */
N#define ADC_ADCR_TRGCOND_HIGH_LEVEL     (1UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC High level active    */
N#define ADC_ADCR_TRGCOND_FALLING_EDGE   (2UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Falling edge active  */
N#define ADC_ADCR_TRGCOND_RISING_EDGE    (3UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Rising edge active   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCHER Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL         (0<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the external analog input                   */
N#define ADC_ADCHER_PRESEL_INT_BANDGAP              (1<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the internal bandgap voltage                */
N#define ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR   (2<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the output of internal temperature sensor   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCMPR Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPD(x)                    ((x) << ADC_ADCMPR_CMPD_Pos)          /*!< Compare value for compare function            */
N#define ADC_ADCMPR_CMPMATCNT(x)               (((x)-1) << ADC_ADCMPR_CMPMATCNT_Pos) /*!< Match count for compare function              */
N#define ADC_ADCMPR_CMPCH(x)                   ((x) << ADC_ADCMPR_CMPCH_Pos)  /*!< Compare channel for compare function                 */
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0<<ADC_ADCMPR_CMPCOND_Pos)    /*!< The compare condition is "less than".                */
N#define ADC_ADCHER_CMPCOND_GREATER_OR_EQUAL   (1<<ADC_ADCMPR_CMPCOND_Pos)    /*!< The compare condition is "greater than or equal to". */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Operation Mode Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SINGLE_MODE         0   /*!< ADC single mode            */
N#define ADC_BURST_MODE          1   /*!< ADC burst mode             */
N#define ADC_SINGLE_CYCLE_MODE   2   /*!< ADC single-cycle scan mode */
N#define ADC_CONTINUOUS_MODE     3   /*!< ADC continuous scan mode   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Trigger Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LOW_LEVEL      0   /*!< ADC external trigger condition is low level trigger    */
N#define ADC_HIGH_LEVEL     1   /*!< ADC external trigger condition is high level trigger   */
N#define ADC_FALLING_EDGE   2   /*!< ADC external trigger condition is falling edge trigger */
N#define ADC_RISING_EDGE    3   /*!< ADC external trigger condition is rising edge trigger  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Compare Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LESS_THAN          0   /*!< ADC compare condition is "less than the compare value"                */
N#define ADC_GREATER_OR_EQUAL   1   /*!< ADC compare condition is "greater than or equal to the compare value" */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Constant Definitions of ADC Channel 7 Input Source                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_CH7_EXT_INPUT_SIGNAL         0   /*!< External input signal       */
N#define ADC_CH7_INT_BANDGAP              1   /*!< Internal band-gap voltage   */
N#define ADC_CH7_INT_TEMPERATURE_SENSOR   2   /*!< Internal temperature sensor */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @details     ADC start convert
N */
N#define _ADC_START_CONVERT()                (ADC->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N * @details     ADC stop convert
N */
N#define _ADC_STOP_CONVERT()                 (ADC->ADCR &= ~ADC_ADCR_ADST_Msk)
N
N/**
N * @details     ADC convert enable
N */
N#define _ADC_CONVERT_ENABLE()               (ADC->ADCR |= ADC_ADCR_ADEN_Msk)
N
N/**
N * @details     ADC convert disable
N */
N#define _ADC_CONVERTER_DISABLE()              (ADC->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N * @details     Enable external trigger  
N */
N#define _ADC_ENABLE_EXT_TRG()               (ADC->ADCR |= ADC_ADCR_TRGEN_Msk)
N
N/**
N * @details     Disable external trigger  
N */
N#define _ADC_DISABLE_EXT_TRG()              (ADC->ADCR &= ~ADC_ADCR_TRGEN_Msk)
N
N/**
N * @details     Enable ADC interrupt  
N */
N#define _ADC_ENABLE_ADC_INT()                   (ADC->ADCR |= ADC_ADCR_ADIE_Msk)
N
N/**
N * @details     Disable ADC interrupt  
N */
N#define _ADC_DISABLE_ADC_INT()                  (ADC->ADCR &= ~ADC_ADCR_ADIE_Msk)
N
N/**
N * @brief       Set ADC ADMD bit field
N *
N * @param[in]   Mode        A/D Converter Operation Mode, should be:
N *                          -  ADC_SINGLE_MODE       : Single mode
N *                          -  ADC_BURST_MODE        : Burst mode
N *                          -  ADC_SINGLE_CYCLE_MODE : Single cycle scan mode
N *                          -  ADC_CONTINUOUS_MODE   : Continuous scan mode 
N * @return      None
N *
N * @details     Set ADC A/D convert opreration mode
N */
N#define _ADC_SET_OPMODE(Mode)               (ADC->ADCR = ((ADC->ADCR & ~ADC_ADCR_ADMD_Msk) | ((Mode)<<ADC_ADCR_ADMD_Pos)))
N
N/**
N * @brief       Get ADC ADMD bit field
N *
N * @param[in]   None
N * @return      Mode        A/D Converter Operation Mode, should be:
N *                          -  ADC_SINGLE_MODE        : Single mode
N *                          -  ADC_BURST_MODE         : Burst mode
N *                          -  ADC_SINGLE_CYCLE_MODE  : Single cycle scan mode
N *                          -  ADC_CONTINUOUS_MODE    : Continuous scan mode
N *
N * @details     Get ADC convert opreration mode
N */
N#define _ADC_GET_OPMODE()                   ((ADC->ADCR & ADC_ADCR_ADMD_Msk)>>ADC_ADCR_ADMD_Pos)
N
N/**
N * @brief       Set ADC DIFFEN bit field
N *
N * @param[in]   None
N * @return      None
N *
N * @details     Configure the ADC analog input as differential input
N */
N#define _ADC_SET_DIFFERENTIAL_INPUT_MODE()           (ADC->ADCR |= ADC_ADCR_DIFFEN_Msk)
N
N/**
N * @brief       Set ADC DIFFEN bit field
N *
N * @param[in]   None
N * @return      None
N *
N * @details     Configure the ADC analog input as single-end input
N */
N#define _ADC_SET_SINGLE_END_INPUT_MODE()           (ADC->ADCR = ((ADC->ADCR & ~ADC_ADCR_DIFFEN_Msk)))
N
N/**
N * @brief       Set ADC TRGCOND bit field
N *
N * @param[in]   TrgCond     External trigger condition , should be:            
N *                          -  ADC_LOW_LEVEL    : STADC Low level active
N *                          -  ADC_HIGH_LEVEL   : STADC High level active
N *                          -  ADC_FALLING_EDGE : STADC Falling edge active
N *                          -  ADC_RISING_EDGE  : STADC Rising edge active
N * @return      None
N *
N * @details     Set ADC external trigger condition
N */
N#define _ADC_SET_TRG_COND(TrgCond)          (ADC->ADCR = ((ADC->ADCR &~ADC_ADCR_TRGCOND_Msk)|((TrgCond)<<ADC_ADCR_TRGCOND_Pos)))
N
N/**
N * @brief       Get converstion data of specified channel 
N *
N * @param[in]   Ch         ADC Channel , should be:
N *                          -  0-7
N * @return      16-bit data 
N *
N * @details     Read RSLT bit field to get conversion data 
N */
N#define _ADC_GET_CONVERSION_DATA(Ch)        ((ADC->ADDR[(Ch)] & ADC_ADDR_RSLT_Msk)>>ADC_ADDR_RSLT_Pos)
N
N/**
N * @brief       Get data overrun flag 
N *
N * @param[in]   Ch         ADC Channel , should be:
N *                          -  0-7
N * @retval      1: The data overrun flag of The specified channel is set.
N * @retval      0: The data overrun flag of The specified channel is cleared.
N *
N * @details     Read OVERRUN bit field to get specified channel status
N */
N#define _ADC_IS_DATA_OVERRUN(Ch)            ((ADC->ADSR & (1<<((Ch)+ADC_ADSR_OVERRUN_Pos)))?1:0)
N
N/**
N * @brief       Get data valid flag 
N *
N * @param[in]   Ch         ADC Channel , should be:
N *                          -  0-7
N * @retval      1: The data valid flag of The specified channel is set.
N * @retval      0: The data valid flag of The specified channel is cleared.
N *
N * @details     Read VALID bit field to get specified channel status
N */
N#define _ADC_IS_DATA_VALID(Ch)              ((ADC->ADSR & (1<<((Ch)+ADC_ADSR_VALID_Pos)))?1:0)
N
N/**
N * @details     Check if ADC conversion done or not
N */
N#define _ADC_IS_COVERSION_DONE()            ((ADC->ADSR & ADC_ADSR_ADF_Msk) >> ADC_ADSR_ADF_Pos)
N
N/**
N * @details     A while loop to check if ADC conversion done or not. Exit the loop if ADC coversion is done
N */
N#define _ADC_WAIT_COVERSION_DONE()          while(!_ADC_IS_COVERSION_DONE())
N
N/**
N * @details     Enable specified comparator interrupt
N */
N#define _ADC_ENABLE_CMP_INT(Ch)         (ADC->ADCMPR[(Ch)] |= ADC_ADCMPR_CMPIE_Msk)
N
N/**
N * @details     Disable specified comparator interrupt
N */
N#define _ADC_DISABLE_CMP_INT(Ch)        (ADC->ADCMPR[(Ch)] &= ~ADC_ADCMPR_CMPIE_Msk)
N
N/**
N * @details     Enable compare function
N */
N#define _ADC_ENABLE_CMP(Ch)             (ADC->ADCMPR[(Ch)] |= ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @details     Disable compare function
N */
N#define _ADC_DISABLE_CMP(Ch)            (ADC->ADCMPR[(Ch)] &= ~ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @details     Set comparison data
N */
N#define _ADC_SET_CMP_DATA(Ch, CmpData)   (ADC->ADCMPR[(Ch)] = ((ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPD_Msk)|((CmpData)<<ADC_ADCMPR_CMPD_Pos)))
N
N/**
N * @details     Set comparator match count
N */
N#define _ADC_SET_CMP_MATCH_CNT(Ch, CmpCnt)    (ADC->ADCMPR[(Ch)] = ((ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPMATCNT_Msk) | (((CmpCnt)-1)<<ADC_ADCMPR_CMPMATCNT_Pos)))
N
N/**
N * @details     Set compare channel 
N */
N#define _ADC_SET_CMP_CHANNEL(Ch, X)      (ADC->ADCMPR[(Ch)] = (ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPCH_Msk) | ((X)<<ADC_ADCMPR_CMPCH_Pos))
N
N/**
N * @brief       Set compare condition 
N *
N * @param[in]   Ch         Comparator Channel , should be:
N *                          -  0-1
N * @param[in]   Cond       Compare Condition , should be:
N *                          - ADC_LESS_THAN         : The compare condition is "less than the compare value"
N *                          - ADC_GREATER_OR_EQUAL  : The compare condition is "greater than or equal to the compare value"
N * @return      None
N *
N * @details     Set the compare condition of the specified comparator
N */
N#define _ADC_SET_CMP_COND(Ch, Cond)         (ADC->ADCMPR[(Ch)] = ((ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPCOND_Msk) | ((Cond)<<ADC_ADCMPR_CMPCOND_Pos)))
N
N/**
N * @brief       Set comparator 0 for compare configuration
N *
N * @param[in]   CmpCh      Compare ADC Channel , should be:
N *                          -  0-7
N * @param[in]   CmpCond    Compare Condition , should be:
N *                          - ADC_LESS_THAN         : The compare condition is "less than the compare value"
N *                          - ADC_GREATER_OR_EQUAL  : The compare condition is "greater than or equal to the compare value"
N * @param[in]   CmpData    Compare Data Value , should be:
N *                          -  0-0xFFF
N * @param[in]   CmpMatchCount
N *                         Compare match count, should be:
N *                          -  1-16
N * @return      None
N *
N * @details     Set comparator 0 parameters including compare channel, condition, data and match count.
N */
N#define _ADC_SET_CMP0(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[0] = (ADC->ADCMPR[0] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) | \
N                                                               ((CmpData)<<ADC_ADCMPR_CMPD_Pos) | \
N                                                               (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) | \
N                                                               ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) | \
N                                                               ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
X#define _ADC_SET_CMP0(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[0] = (ADC->ADCMPR[0] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) |                                                                ((CmpData)<<ADC_ADCMPR_CMPD_Pos) |                                                                (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) |                                                                ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) |                                                                ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @brief       Set comparator 1 for compare configuration
N *
N * @param[in]   CmpCh      Compare ADC Channel , should be:
N *                          -  0-7
N * @param[in]   CmpCond    Compare Condition , should be:
N *                          - ADC_LESS_THAN         : The compare condition is "less than the compare value"
N *                          - ADC_GREATER_OR_EQUAL  : The compare condition is "greater than or equal to the compare value"
N * @param[in]   CmpData    Compare Data Value , should be:
N *                          -  0-0xFFF
N * @param[in]   CmpMatchCount
N *                         Compare match count, should be:
N *                          -  1-16
N * @return      None
N *
N * @details     Set comparator 1 parameters including compare channel, condition, data and match count.
N */
N#define _ADC_SET_CMP1(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[1] = (ADC->ADCMPR[1] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) | \
N                                                               ((CmpData)<<ADC_ADCMPR_CMPD_Pos) | \
N                                                               (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) | \
N                                                               ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) | \
N                                                               ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
X#define _ADC_SET_CMP1(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[1] = (ADC->ADCMPR[1] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) |                                                                ((CmpData)<<ADC_ADCMPR_CMPD_Pos) |                                                                (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) |                                                                ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) |                                                                ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @brief       Use bitwise to set ADC Channel
N *
N * @param[in]   Bitwise     ADC Channel configure, should be:
N *                          -  0-0xFF
N * @return      None
N *
N * @details     The function is used to set ADC channel groups.
N *
N */
N#define _ADC_SET_CHANNEL(Bitwise)          (ADC->ADCHER |= ((ADC->ADCHER&~ADC_ADCHER_CHEN_Msk)|(Bitwise)))
N
N/**
N * @brief       Enable specified ADC channel
N *
N * @param[in]   Ch         ADC Channel , should be:
N *                          -  0-7
N * @return      None
N *
N * @details     The function is used to enable single ADC channel.
N */
N#define _ADC_ENABLE_CHANNEL(Ch)          (ADC->ADCHER |= ((ADC->ADCHER&~ADC_ADCHER_CHEN_Msk)|(1<<(Ch))))
N
N/**
N * @brief       Disable specified ADC channel
N *
N * @param[in]   Ch         ADC Channel , should be:
N *                          -  0-7
N * @return      None
N *
N * @details     The function is used to disable single ADC channel.
N */
N#define _ADC_DISABLE_CHANNEL(Ch)         (ADC->ADCHER &= ~(1<<(Ch)))
N
N/**
N * @brief       Select the source of the analog input channel 7
N *
N * @param[in]   Option        Analog input select, should be:
N *                          -  ADC_CH7_EXT_INPUT_SIGNAL        : the external analog input 
N *                          -  ADC_CH7_INT_BANDGAP             : the internal bandgap voltage  
N *                          -  ADC_CH7_INT_TEMPERATURE_SENSOR  : the output of internal temperature sensor 
N * @return      None
N *
N * @details     Select the source of the analog input channel 7
N */
N#define _ADC_CONFIG_CH7(Option)              (ADC->ADCHER = (ADC->ADCHER &~(ADC_ADCHER_PRESEL_Msk))|((Option)<<ADC_ADCHER_PRESEL_Pos))
N
N/**
N * @details    Get current converse channel
N */
N#define _ADC_GET_CURRENT_COVERSION_CHANNEL()    ((ADC->ADSR & ADC_ADSR_CHANNEL_Msk) >> ADC_ADSR_CHANNEL_Pos)
N
N/**
N * @details    Check if ADC is busy or not
N */
N#define _ADC_IS_BUSY()                      ((ADC->ADSR & ADC_ADSR_BUSY_Msk) >> ADC_ADSR_BUSY_Pos)
N
N/**
N * @details    Get specified comparator channel compare flag
N */
N#define _ADC_GET_CMP_FLAG(ADCCMP_CH)        ((ADC->ADSR & (1<<(ADC_ADSR_CMPF0_Pos+(ADCCMP_CH)))) >> (ADC_ADSR_CMPF0_Pos+(ADCCMP_CH)))
N
N/**
N * @details     ADC IP reset 
N */
N__INLINE void ADC_ResetIP()
X__inline void ADC_ResetIP()
N{
N    SYS->IPRSTC2 |= (1<<SYS_IPRSTC2_ADC_RST_Pos) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |= (1<<28) ;
N    SYS->IPRSTC2 &= ~(1<<(SYS_IPRSTC2_ADC_RST_Pos)) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(1<<(28)) ;
N} 
N
N/**
N * @details     Enable ADC IP clock
N */
N#define _ADC_ENABLE_CLOCK()   (SYSCLK->APBCLK |= SYSCLK_APBCLK_ADC_EN_Msk) 
N
N/**
N * @details     Disable ADC IP clock
N */
N#define _ADC_DISABLE_CLOCK()  (SYSCLK->APBCLK &= ~SYSCLK_APBCLK_ADC_EN_Msk) 
N
N/**
N * @brief      Return the A/D conversion rate (sample/second)
N *
N * @param      None
N *
N * @return     Conversion rate
N *
N * @details    The conversion rate depends on the clock source of ADC clock.
N *             In NuMicro M05xxAx Series (Ex. M0516LAN), it needs about 27 ADC clocks to complete
N *             an A/D conversion.
N */
Nstatic __INLINE uint32_t ADC_GetConversionRate_M05xxxAN()
Xstatic __inline uint32_t ADC_GetConversionRate_M05xxxAN()
N{
N    uint32_t u32AdcClkSrcSel;
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};    
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};    
N    
N    u32ClkTbl[1] = PllClock;
N    u32AdcClkSrcSel = ((SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_ADC_S_Msk) >> SYSCLK_CLKSEL1_ADC_S_Pos);
X    u32AdcClkSrcSel = ((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (3ul << 2)) >> 2);
N    return   ((u32ClkTbl[u32AdcClkSrcSel]) / (((SYSCLK->CLKDIV & SYSCLK_CLKDIV_ADC_N_Msk)>>SYSCLK_CLKDIV_ADC_N_Pos)+ 1) / 27);
X    return   ((u32ClkTbl[u32AdcClkSrcSel]) / (((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKDIV & (0xFFul << 16))>>16)+ 1) / 27);
N}
N
N/**
N * @brief      Return the A/D conversion rate (sample/second)
N *
N * @param      None
N *
N * @return     Conversion rate
N *
N * @details    The conversion rate depends on the clock source of ADC clock.
N *             In NuMicro M05xxBx Series (Ex. M0516LBN), it only needs 21 ADC
N *             clocks to complete an A/D conversion when the ADC clock source is HCLK.
N */
Nstatic __INLINE uint32_t ADC_GetConversionRate_M05xxxBN()
Xstatic __inline uint32_t ADC_GetConversionRate_M05xxxBN()
N{
N    uint32_t u32AdcClkSrcSel;
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};    
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};    
N    
N    u32ClkTbl[1] = PllClock;
N    u32ClkTbl[2] = SystemCoreClock;
N    u32AdcClkSrcSel = ((SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_ADC_S_Msk) >> SYSCLK_CLKSEL1_ADC_S_Pos);
X    u32AdcClkSrcSel = ((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (3ul << 2)) >> 2);
N    return   ((u32ClkTbl[u32AdcClkSrcSel]) / (((SYSCLK->CLKDIV & SYSCLK_CLKDIV_ADC_N_Msk)>>SYSCLK_CLKDIV_ADC_N_Pos)+ 1) / 21);
X    return   ((u32ClkTbl[u32AdcClkSrcSel]) / (((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKDIV & (0xFFul << 16))>>16)+ 1) / 21);
N}
N
N/**
N * @details     Set ADC clock source  
N */
N#define _ADC_SET_CLK_SRC(ClockSrc)     (SYSCLK->CLKSEL1 = (SYSCLK->CLKSEL1 &~SYSCLK_CLKSEL1_ADC_S_Msk)|((ClockSrc)<<SYSCLK_CLKSEL1_ADC_S_Pos))
N
N/**
N * @details     Set ADC clock divisor. It could be 1~256. 
N */
N#define _ADC_SET_CLK_DIV(Divisor)      (SYSCLK->CLKDIV  = (SYSCLK->CLKDIV & ~SYSCLK_CLKDIV_ADC_N_Msk)|(SYSCLK_CLKDIV_ADC(Divisor)))
N
N/**
N * @details     Get the status of the ADC interrupt flag
N */
N#define _ADC_GET_ADC_INT_FLAG()    ((ADC->ADSR & ADC_ADSR_ADF_Msk)>>ADC_ADSR_ADF_Pos)
N
N/**
N * @details     Get the status of the ADC CMP0 interrupt flag
N */
N#define _ADC_GET_CMP0_INT_FLAG()    _ADC_GET_CMP_FLAG(0)
N
N/**
N * @details     Get the status of the ADC CMP1 interrupt flag
N */
N#define _ADC_GET_CMP1_INT_FLAG()    _ADC_GET_CMP_FLAG(1)
N
N/**
N * @details     Clear the ADC interrupt flag
N */
N#define _ADC_CLEAR_ADC_INT_FLAG()   (ADC->ADSR = ADC_ADSR_ADF_Msk)
N
N/**
N * @details     Clear the ADC CMP0 interrupt flag
N */
N#define _ADC_CLEAR_CMP0_INT_FLAG()  (ADC->ADSR = ADC_ADSR_CMPF0_Msk)
N
N/**
N * @details     Clear the ADC CMP1 interrupt flag
N */
N#define _ADC_CLEAR_CMP1_INT_FLAG()  (ADC->ADSR = ADC_ADSR_CMPF1_Msk)
N
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* (ONLY in M05xxxAN)                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Enable self-calibaration function
N */
N#define _ADC_ENABLE_SELF_CALIBRATION()      (ADC->ADCALR |= ADC_ADCALR_CALEN_Msk)
N
N/**
N * @details     Disable self-calibaration function
N */
N#define _ADC_DISABLE_SELF_CALIBRATION()     (ADC->ADCALR &= ~ADC_ADCALR_CALEN_Msk)
N
N/**
N * @details     Check if calibaration done or not.
N */
N#define _ADC_IS_CALIBRATION_DONE()          ((ADC->ADCALR & ADC_ADCALR_CALDONE_Msk)>>ADC_ADCALR_CALDONE_Pos)
N
N/**
N  * @} End of ADC Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif
L 6184 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "EBI.h"
L 1 "..\..\LibM051Series\StdDriver\inc\EBI.h" 1
N/**************************************************************************//**
N * @file     EBI.h
N * @version  V2.1
N * $Revision: 4 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series External Bus Interface Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __EBI_H__
N#define __EBI_H__
N
N#include "M051Series.h"
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup EBI_FUNC EBI Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Miscellaneous Constant Definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_START_BASE_ADDR         0x60000000UL /*!< EBI start base address */
N#define EBI_MAX_SIZE                0x20000UL     /*!< Max. EBI size          */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EBICON Constant Definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_EBICON_MCLKDIV_1        0x00000000UL /*!< EBI output clock(MCLK) is HCLK/1 */
N#define EBI_EBICON_MCLKDIV_2        0x00000100UL /*!< EBI output clock(MCLK) is HCLK/2 */
N#define EBI_EBICON_MCLKDIV_4        0x00000200UL /*!< EBI output clock(MCLK) is HCLK/4 */
N#define EBI_EBICON_MCLKDIV_8        0x00000300UL /*!< EBI output clock(MCLK) is HCLK/8 */
N#define EBI_EBICON_MCLKDIV_16       0x00000400UL /*!< EBI output clock(MCLK) is HCLK/16 */
N#define EBI_EBICON_MCLKDIV_32       0x00000500UL /*!< EBI output clock(MCLK) is HCLK/32 */
N#define EBI_EBICON_ExttALE(x)       (((x)-1) << EBI_EBICON_ExttALE_Pos) /*!< ALE width(tALE) is (x)*MCLK. It could be 1~8 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EXTIME Constant Definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_EXTIME_ExttACC(x)       (((x)-1) << EBI_EXTIME_ExttACC_Pos) /*!< Data Access Time(tACC) is (x)*MCLK. It could be 1~16 */
N#define EBI_EXTIME_ExttAHD(x)       (((x)-1) << EBI_EXTIME_ExttAHD_Pos) /*!< Data Access Hold Time(tAHD) is (x)*MCLK. It could be 1~8 */
N#define EBI_EXTIME_ExtIW2X(x)       ((x) << EBI_EXTIME_ExtIW2X_Pos)     /*!< Idle State Cycle After Write(IW2X) is (x)*MCLK. It could be 0~15 */
N#define EBI_EXTIME_ExtIR2R(x)       ((x) << EBI_EXTIME_ExtIR2R_Pos)     /*!< Idle State Cycle Between Read-Read(IR2R) is (x)*MCLK. It could be 0~15 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EBI Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Enable EBI function
N */             
N#define _EBI_ENABLE_EBI()           (EBI->EBICON |= EBI_EBICON_ExtEN_Msk)    
N
N
N/**
N * @details     Disable EBI function
N */             
N#define _EBI_DISABLE_EBI()          (EBI->EBICON &= ~EBI_EBICON_ExtEN_Msk)
N
N
N/**
N * @details     Set EBI data width is 8-bit
N */             
N#define _EBI_SET_DATAWIDTH_8BIT()   (EBI->EBICON &= ~EBI_EBICON_ExtBW16_Msk)
N
N
N/**
N * @details     Set EBI data width is 16-bit
N */             
N#define _EBI_SET_DATAWIDTH_16BIT()  (EBI->EBICON |= EBI_EBICON_ExtBW16_Msk)
N
N
N/**
N * @details     Set EBI ALE time.  1 <= x <= 8
N */             
N#define _EBI_SET_ExttALE(x)         (EBI->EBICON = ((EBI->EBICON & ~EBI_EBICON_ExttALE_Msk) | EBI_EBICON_ExttALE(x)))  
N
N
N/**
N * @details     Set EBI MCLK divider. x = 1, 2, 4, 8, 16 or 32
N */             
N#define _EBI_SET_MCLKDIV(x)         (EBI->EBICON = ((EBI->EBICON & ~EBI_EBICON_MCLKDIV_Msk) | (EBI_EBICON_MCLKDIV_##x)))
N
N
N/**
N * @details     Set EBI ACC time. 1 <= x <= 16
N */             
N#define _EBI_SET_ExttACC(x)         (EBI->EXTIME = ((EBI->EXTIME & ~EBI_EXTIME_ExttACC_Msk) | EBI_EXTIME_ExttACC(x)))  
N
N
N/**
N * @details     Set EBI AHD time. 1 <= x <= 8
N */             
N#define _EBI_SET_ExttAHD(x)         (EBI->EXTIME = ((EBI->EXTIME & ~EBI_EXTIME_ExttAHD_Msk) | EBI_EXTIME_ExttAHD(x)))  
N
N
N/**
N * @details     Set Idle State Cycle After Write. 0 <= x <= 15
N */             
N#define _EBI_SET_ExtIW2X(x)         (EBI->EXTIME = ((EBI->EXTIME & ~EBI_EXTIME_ExtIW2X_Msk) | EBI_EXTIME_ExtIW2X(x)))  
N
N
N/**
N * @details     Set Idle State Cycle Between Read-Read. 0 <= x <= 15
N */             
N#define _EBI_SET_ExtIR2R(x)         (EBI->EXTIME = ((EBI->EXTIME & ~EBI_EXTIME_ExtIR2R_Msk) | EBI_EXTIME_ExtIR2R(x))) 
N
N
N/**
N * @details     Get ALE time setting
N */             
N#define _EBI_GET_ExttALE()          (((EBI->EBICON & EBI_EBICON_ExttALE_Msk) >> EBI_EBICON_ExttALE_Pos) + 1)
N
N
N/**
N * @details     Get MCLK divider setting of EBICON register.
N */             
N#define _EBI_GET_MCLKDIV()          ((EBI->EBICON & EBI_EBICON_MCLKDIV_Msk) >> EBI_EBICON_MCLKDIV_Pos)
N
N
N/**
N * @details     Get ACC time setting
N */             
N#define _EBI_GET_ExttACC()          (((EBI->EXTIME & EBI_EXTIME_ExttACC_Msk) >> EBI_EXTIME_ExttACC_Pos) + 1)
N
N
N/**
N * @details     Get AHD time setting
N */             
N#define _EBI_GET_ExttAHD()          (((EBI->EXTIME & EBI_EXTIME_ExttAHD_Msk) >> EBI_EXTIME_ExttAHD_Pos) + 1)
N
N
N/**
N * @details     Get Idle State Cycle After Write
N */             
N#define _EBI_GET_ExtIW2X()          ((EBI->EXTIME & EBI_EXTIME_ExtIW2X_Msk) >> EBI_EXTIME_ExtIW2X_Pos)
N
N
N/**
N * @details     Get Idle State Cycle Between Read-Read
N */             
N#define _EBI_GET_ExtIR2R()          ((EBI->EXTIME & EBI_EXTIME_ExtIR2R_Msk) >> EBI_EXTIME_ExtIR2R_Pos)
N
N/**
N  * @} End of EBI Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif  // __EBI_H__
N
L 6185 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "FMC.h"
L 1 "..\..\LibM051Series\StdDriver\inc\FMC.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V2.1
N * $Revision: 4 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#include "M051Series.h"
N
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup FMC_FUNC FMC Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */  
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4 kBytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCON constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCON_BS_LDROM     0x2     /*!< ISPCON setting to select to boot from LDROM */
N#define FMC_ISPCON_BS_APROM     0x0     /*!< ISPCON setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ        0x00     /*!< ISP Command: Read Flash       */
N#define FMC_ISPCMD_PROGRAM     0x21     /*!< ISP Command: Program Flash    */
N#define FMC_ISPCMD_PAGE_ERASE  0x22     /*!< ISP Command: Page Erase Flash */
N#define FMC_ISPCMD_READ_UID    0x04     /*!< ISP Command: Read Unique ID   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define _FMC_ENABLE_ISP()          (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)  /*!< Enable ISP Function  */
N#define _FMC_DISABLE_ISP()         (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)  /*!< Disable ISP Function */
N#define _FMC_ENABLE_LD_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)  /*!< Enable LDROM Update Function   */
N#define _FMC_DISABLE_LD_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N#define _FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk) /*!< Enable CONFIG Update Function  */
N#define _FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk) /*!< Disable CONFIG Update Function */
N#define _FMC_ENABLE_AP_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)  /*!< Enable APROM Update Function   */
N#define _FMC_DISABLE_AP_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)  /*!< Disable APROM Update Function  */
N#define _FMC_ENABLE_LOW_FREQ_OPTIMIZE_MODE()  (FMC->FATCON |=  FMC_FATCON_LFOM_Msk) /*!< Enable Flash Access Low Frequency Optimization Mode when HCLK <= 25MHz */
N#define _FMC_DISABLE_LOW_FREQ_OPTIMIZE_MODE() (FMC->FATCON &= ~FMC_FATCON_LFOM_Msk) /*!< Disable Flash Access Low Frequency Optimization Mode */
N
N#define _FMC_SELECT_NEXT_BOOT(x)   (FMC->ISPCON = (FMC->ISPCON & ~FMC_ISPCON_BS_Msk) | (x << FMC_ISPCON_BS_Pos)) /*!< Select Next Booting, x = 0 or 1 */
N#define _FMC_GET_BOOT_STATUS()     ((FMC->ISPCON & FMC_ISPCON_BS_Msk)?1:0) /*!< Get MCU Booting Status */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N * 
N * @param[in]  u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32data  32-bit Data to program
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of TRM.
N *
N * @note   
N *             Please make sure that Register Write-Protection Function has been disabled 
N *             before using this function. User can check the status of 
N *             Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE void FMC_Write(uint32_t u32addr, uint32_t u32data)
Xstatic __inline void FMC_Write(uint32_t u32addr, uint32_t u32data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x21;
N    FMC->ISPADR = u32addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;
N    FMC->ISPDAT = u32data;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = u32data;
N    FMC->ISPTRG = 0x1;  
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;  
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N}
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N * 
N * @param[in]   u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N * @note   
N *              Please make sure that Register Write-Protection Function has been disabled 
N *              before using this function. User can check the status of 
N *              Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32addr)
N{ 
N    FMC->ISPCMD = FMC_ISPCMD_READ;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x00;
N    FMC->ISPADR = u32addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N    
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N * @brief      Flash page erase
N * 
N * @param[in]  u32addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG. 
N *             The page size is 512 bytes.
N *
N * @note   
N *             Please make sure that Register Write-Protection Function has been disabled 
N *             before using this function. User can check the status of 
N *             Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE void FMC_Erase(uint32_t u32addr)
Xstatic __inline void FMC_Erase(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x22;
N    FMC->ISPADR = u32addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N}
N
N/**
N * @brief       Read Unique ID
N * 
N * @param[in]   u8index  UID index. 0 = UID[0:31], 1 = UID[32:63], 2 = UID[64:95]
N *
N * @return      The 32-bit unique ID data of specified UID index
N *
N * @details     To read out 96-bit Unique ID.
N *
N * @note   
N *              Please make sure that Register Write-Protection Function has been disabled 
N *              before using this function. User can check the status of 
N *              Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8index)
N{ 
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;
N    FMC->ISPADR = (u8index << 2);
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (u8index << 2);
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N    
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @} End of FMC Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N
N#endif
N
L 6186 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "GPIO.h"
L 1 "..\..\LibM051Series\StdDriver\inc\GPIO.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V2.1
N * $Revision: 8 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series General Purpose I/O Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef _GPIO_H_
N#define _GPIO_H_
N
N#include "M051Series.h"
N
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup GPIO_FUNC GPIO Device Function Interface
N  * @{
N  */
N
N
N
N/* Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N   Example 1:
N   
N       P00 = 1; 
N   
N   It is used to set P0.0 to high;
N   
N   Example 2:
N   
N       if (P00)
N           P00 = 0;
N   
N   If P0.0 pin status is high, then set P0.0 data output to low.
N */
N#define GPIO_PIN_DATA(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x20*(port))) + ((pin)<<2))))   
N#define P00             GPIO_PIN_DATA(0, 0) /*!< Specify P00 Pin Data Input/Output */
N#define P01             GPIO_PIN_DATA(0, 1) /*!< Specify P01 Pin Data Input/Output */
N#define P02             GPIO_PIN_DATA(0, 2) /*!< Specify P02 Pin Data Input/Output */
N#define P03             GPIO_PIN_DATA(0, 3) /*!< Specify P03 Pin Data Input/Output */
N#define P04             GPIO_PIN_DATA(0, 4) /*!< Specify P04 Pin Data Input/Output */
N#define P05             GPIO_PIN_DATA(0, 5) /*!< Specify P05 Pin Data Input/Output */
N#define P06             GPIO_PIN_DATA(0, 6) /*!< Specify P06 Pin Data Input/Output */
N#define P07             GPIO_PIN_DATA(0, 7) /*!< Specify P07 Pin Data Input/Output */
N#define P10             GPIO_PIN_DATA(1, 0) /*!< Specify P10 Pin Data Input/Output */
N#define P11             GPIO_PIN_DATA(1, 1) /*!< Specify P11 Pin Data Input/Output */
N#define P12             GPIO_PIN_DATA(1, 2) /*!< Specify P12 Pin Data Input/Output */
N#define P13             GPIO_PIN_DATA(1, 3) /*!< Specify P13 Pin Data Input/Output */
N#define P14             GPIO_PIN_DATA(1, 4) /*!< Specify P14 Pin Data Input/Output */
N#define P15             GPIO_PIN_DATA(1, 5) /*!< Specify P15 Pin Data Input/Output */
N#define P16             GPIO_PIN_DATA(1, 6) /*!< Specify P16 Pin Data Input/Output */
N#define P17             GPIO_PIN_DATA(1, 7) /*!< Specify P17 Pin Data Input/Output */
N#define P20             GPIO_PIN_DATA(2, 0) /*!< Specify P20 Pin Data Input/Output */
N#define P21             GPIO_PIN_DATA(2, 1) /*!< Specify P21 Pin Data Input/Output */
N#define P22             GPIO_PIN_DATA(2, 2) /*!< Specify P22 Pin Data Input/Output */
N#define P23             GPIO_PIN_DATA(2, 3) /*!< Specify P23 Pin Data Input/Output */
N#define P24             GPIO_PIN_DATA(2, 4) /*!< Specify P24 Pin Data Input/Output */
N#define P25             GPIO_PIN_DATA(2, 5) /*!< Specify P25 Pin Data Input/Output */
N#define P26             GPIO_PIN_DATA(2, 6) /*!< Specify P26 Pin Data Input/Output */
N#define P27             GPIO_PIN_DATA(2, 7) /*!< Specify P27 Pin Data Input/Output */
N#define P30             GPIO_PIN_DATA(3, 0) /*!< Specify P30 Pin Data Input/Output */
N#define P31             GPIO_PIN_DATA(3, 1) /*!< Specify P31 Pin Data Input/Output */
N#define P32             GPIO_PIN_DATA(3, 2) /*!< Specify P32 Pin Data Input/Output */
N#define P33             GPIO_PIN_DATA(3, 3) /*!< Specify P33 Pin Data Input/Output */
N#define P34             GPIO_PIN_DATA(3, 4) /*!< Specify P34 Pin Data Input/Output */
N#define P35             GPIO_PIN_DATA(3, 5) /*!< Specify P35 Pin Data Input/Output */
N#define P36             GPIO_PIN_DATA(3, 6) /*!< Specify P36 Pin Data Input/Output */
N#define P37             GPIO_PIN_DATA(3, 7) /*!< Specify P37 Pin Data Input/Output */
N#define P40             GPIO_PIN_DATA(4, 0) /*!< Specify P40 Pin Data Input/Output */
N#define P41             GPIO_PIN_DATA(4, 1) /*!< Specify P41 Pin Data Input/Output */
N#define P42             GPIO_PIN_DATA(4, 2) /*!< Specify P42 Pin Data Input/Output */
N#define P43             GPIO_PIN_DATA(4, 3) /*!< Specify P43 Pin Data Input/Output */
N#define P44             GPIO_PIN_DATA(4, 4) /*!< Specify P44 Pin Data Input/Output */
N#define P45             GPIO_PIN_DATA(4, 5) /*!< Specify P45 Pin Data Input/Output */
N#define P46             GPIO_PIN_DATA(4, 6) /*!< Specify P46 Pin Data Input/Output */
N#define P47             GPIO_PIN_DATA(4, 7) /*!< Specify P47 Pin Data Input/Output */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT              0x0UL                  /*!< Input Mode */
N#define GPIO_PMD_OUTPUT             0x1UL                  /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN         0x2UL                  /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI              0x3UL                  /*!< Quasi-bidirectional Mode */
N#define GPIO_PMD_MODE(pin, mode)    ((mode) << ((pin)<<1)) /*!< Generate the PMD mode setting for each pin  */
N
N#define GPIO_PMD_PMD0_INPUT         0x0000UL /*!< PMD Setting of Pin 0 for Input Mode */
N#define GPIO_PMD_PMD0_OUTPUT        0x0001UL /*!< PMD Setting of Pin 0 for Output Mode */
N#define GPIO_PMD_PMD0_OPEN_DRAIN    0x0002UL /*!< PMD Setting of Pin 0 for Open-Drain Mode */
N#define GPIO_PMD_PMD0_QUASI         0x0003UL /*!< PMD Setting of Pin 0 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD1_INPUT         0x0000UL /*!< PMD Setting of Pin 1 for Input Mode */
N#define GPIO_PMD_PMD1_OUTPUT        0x0004UL /*!< PMD Setting of Pin 1 for Output Mode */
N#define GPIO_PMD_PMD1_OPEN_DRAIN    0x0008UL /*!< PMD Setting of Pin 1 for Open-Drain Mode */
N#define GPIO_PMD_PMD1_QUASI         0x000CUL /*!< PMD Setting of Pin 1 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD2_INPUT         0x0000UL /*!< PMD Setting of Pin 2 for Input Mode */
N#define GPIO_PMD_PMD2_OUTPUT        0x0010UL /*!< PMD Setting of Pin 2 for Output Mode */
N#define GPIO_PMD_PMD2_OPEN_DRAIN    0x0020UL /*!< PMD Setting of Pin 2 for Open-Drain Mode */
N#define GPIO_PMD_PMD2_QUASI         0x0030UL /*!< PMD Setting of Pin 2 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD3_INPUT         0x0000UL /*!< PMD Setting of Pin 3 for Input Mode */
N#define GPIO_PMD_PMD3_OUTPUT        0x0040UL /*!< PMD Setting of Pin 3 for Output Mode */
N#define GPIO_PMD_PMD3_OPEN_DRAIN    0x0080UL /*!< PMD Setting of Pin 3 for Open-Drain Mode */
N#define GPIO_PMD_PMD3_QUASI         0x00C0UL /*!< PMD Setting of Pin 3 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD4_INPUT         0x0000UL /*!< PMD Setting of Pin 4 for Input Mode */
N#define GPIO_PMD_PMD4_OUTPUT        0x0100UL /*!< PMD Setting of Pin 4 for Output Mode */
N#define GPIO_PMD_PMD4_OPEN_DRAIN    0x0200UL /*!< PMD Setting of Pin 4 for Open-Drain Mode */
N#define GPIO_PMD_PMD4_QUASI         0x0300UL /*!< PMD Setting of Pin 4 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD5_INPUT         0x0000UL /*!< PMD Setting of Pin 5 for Input Mode */
N#define GPIO_PMD_PMD5_OUTPUT        0x0400UL /*!< PMD Setting of Pin 5 for Output Mode */
N#define GPIO_PMD_PMD5_OPEN_DRAIN    0x0800UL /*!< PMD Setting of Pin 5 for Open-Drain Mode */
N#define GPIO_PMD_PMD5_QUASI         0x0C00UL /*!< PMD Setting of Pin 5 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD6_INPUT         0x0000UL /*!< PMD Setting of Pin 6 for Input Mode */
N#define GPIO_PMD_PMD6_OUTPUT        0x1000UL /*!< PMD Setting of Pin 6 for Output Mode */
N#define GPIO_PMD_PMD6_OPEN_DRAIN    0x2000UL /*!< PMD Setting of Pin 6 for Open-Drain Mode */
N#define GPIO_PMD_PMD6_QUASI         0x3000UL /*!< PMD Setting of Pin 6 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD7_INPUT         0x0000UL /*!< PMD Setting of Pin 7 for Input Mode */
N#define GPIO_PMD_PMD7_OUTPUT        0x4000UL /*!< PMD Setting of Pin 7 for Output Mode */
N#define GPIO_PMD_PMD7_OPEN_DRAIN    0x8000UL /*!< PMD Setting of Pin 7 for Open-Drain Mode */
N#define GPIO_PMD_PMD7_QUASI         0xC000UL /*!< PMD Setting of Pin 7 for Quasi-bidirectional Mode */
N                                            
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE               0UL               /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL              1UL               /*!< IMD Setting for Edge Level Mode */
N#define GPIO_IMD_MODE(pin, mode)    ((mode) << (pin)) /*!< Generate IMD Mode Setting for Pin */
N                                                        
N#define GPIO_IMD_IMD0_EDGE          0x00UL /*!< IMD Setting of Pin 0 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD1_EDGE          0x00UL /*!< IMD Setting of Pin 1 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD2_EDGE          0x00UL /*!< IMD Setting of Pin 2 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD3_EDGE          0x00UL /*!< IMD Setting of Pin 3 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD4_EDGE          0x00UL /*!< IMD Setting of Pin 4 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD5_EDGE          0x00UL /*!< IMD Setting of Pin 5 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD6_EDGE          0x00UL /*!< IMD Setting of Pin 6 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD7_EDGE          0x00UL /*!< IMD Setting of Pin 7 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD0_LEVEL         0x01UL /*!< IMD Setting of Pin 0 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD1_LEVEL         0x02UL /*!< IMD Setting of Pin 1 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD2_LEVEL         0x04UL /*!< IMD Setting of Pin 2 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD3_LEVEL         0x08UL /*!< IMD Setting of Pin 3 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD4_LEVEL         0x10UL /*!< IMD Setting of Pin 4 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD5_LEVEL         0x20UL /*!< IMD Setting of Pin 5 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD6_LEVEL         0x40UL /*!< IMD Setting of Pin 6 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD7_LEVEL         0x80UL /*!< IMD Setting of Pin 7 for Level Trigger Mode */ 
N
N                                    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IEN Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IEN_IF_EN(pin)         (1UL << (pin))      /*!< Generate IEN Setting of Specified Pin for Enable Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IR_EN(pin)         (1UL << ((pin)+16)) /*!< Generate IEN Setting of Specified Pin for Enable Rising/High Level Interrupt */ 
N
N#define GPIO_IEN_IF_EN0             0x00000001UL /*!< IEN Setting of Pin 0 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN1             0x00000002UL /*!< IEN Setting of Pin 1 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN2             0x00000004UL /*!< IEN Setting of Pin 2 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN3             0x00000008UL /*!< IEN Setting of Pin 3 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN4             0x00000010UL /*!< IEN Setting of Pin 4 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN5             0x00000020UL /*!< IEN Setting of Pin 5 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN6             0x00000040UL /*!< IEN Setting of Pin 6 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN7             0x00000080UL /*!< IEN Setting of Pin 7 for Eanble Falling/Low Level Interrupt */ 
N                                    
N#define GPIO_IEN_IR_EN0             0x00010000UL /*!< IEN Setting of Pin 0 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN1             0x00020000UL /*!< IEN Setting of Pin 1 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN2             0x00040000UL /*!< IEN Setting of Pin 2 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN3             0x00080000UL /*!< IEN Setting of Pin 3 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN4             0x00100000UL /*!< IEN Setting of Pin 4 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN5             0x00200000UL /*!< IEN Setting of Pin 5 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN6             0x00400000UL /*!< IEN Setting of Pin 6 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN7             0x00800000UL /*!< IEN Setting of Pin 7 for Eanble Rising/High Level Interrupt */ 
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISRC Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_ISRC_ISRC0             0x01UL /*!< ISRC Setting of Pin 0 for Indicates Pin 0 generate an interrupt */ 
N#define GPIO_ISRC_ISRC1             0x02UL /*!< ISRC Setting of Pin 1 for Indicates Pin 1 generate an interrupt */ 
N#define GPIO_ISRC_ISRC2             0x04UL /*!< ISRC Setting of Pin 2 for Indicates Pin 2 generate an interrupt */ 
N#define GPIO_ISRC_ISRC3             0x08UL /*!< ISRC Setting of Pin 3 for Indicates Pin 3 generate an interrupt */ 
N#define GPIO_ISRC_ISRC4             0x10UL /*!< ISRC Setting of Pin 4 for Indicates Pin 4 generate an interrupt */
N#define GPIO_ISRC_ISRC5             0x20UL /*!< ISRC Setting of Pin 5 for Indicates Pin 5 generate an interrupt */ 
N#define GPIO_ISRC_ISRC6             0x40UL /*!< ISRC Setting of Pin 6 for Indicates Pin 6 generate an interrupt */ 
N#define GPIO_ISRC_ISRC7             0x80UL /*!< ISRC Setting of Pin 7 for Indicates Pin 7 generate an interrupt */ 
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBNCECON_ICLK_ON           0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */ 
N#define GPIO_DBNCECON_ICLK_OFF          0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */ 
N
N#define GPIO_DBNCECON_DBCLKSRC_IRC10K   0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */ 
N#define GPIO_DBNCECON_DBCLKSRC_HCLK     0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the internal HCLK */ 
N
N#define GPIO_DBNCECON_DBCLKSEL_1        0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2        0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4        0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8        0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16       0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32       0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_64       0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_128      0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_256      0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_512      0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_1024     0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2048     0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4096     0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8192     0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16384    0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32768    0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBEN Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBEN_ENABLE(pin)       (1UL << (pin)) /*!< DBEN setting for enable specified pin de-bounce function */      
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DMASK Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DMASK_ENABLE(pin)      (1UL << (pin)) /*!< DMASK setting for mask specified pin DOUT function */      
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  OFFD Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_OFFD_ENABLE(pin)       (1UL << ((pin)+16)) /*!< OFFD setting for disable specified pin I/O digital input path */      
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING             0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING            0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE          0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH               0x01010000UL /*!< Interrupt enable by Level-High */    
N#define GPIO_INT_LOW                0x01000001UL /*!< Interrupt enable by Level-Level */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Macro Definitions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief       Set GPIO Pin Mode
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 7.
N * @param[in]   mode        The pin mode of specified GPIO pin. It could be GPIO_PMD_INPUT, GPIO_PMD_OUTPUT, GPIO_PMD_OPEN_DRAIN or GPIO_PMD_QUASI.
N *
N * @return      None
N *
N * @details     Set the pin mode of specified GPIO pin.
N */
N#define _GPIO_SET_PIN_MODE(PORT, pin, mode)     ((PORT)->PMD = ((PORT)->PMD & ~GPIO_PMD_MODE(pin, GPIO_PMD_QUASI)) | GPIO_PMD_MODE(pin, mode))
N
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define _GPIO_ENABLE_DIGITAL_PATH(PORT, pin)    ((PORT)->OFFD &= ~GPIO_OFFD_ENABLE(pin))
N
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define _GPIO_DISABLE_DIGITAL_PATH(PORT, pin)   ((PORT)->OFFD |= GPIO_OFFD_ENABLE(pin))
N
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define _GPIO_ENABLE_DEBOUNCE(PORT, pin)         ((PORT)->DBEN |= GPIO_DBEN_ENABLE(pin))
N
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define _GPIO_DISABLE_DEBOUNCE(PORT, pin)       ((PORT)->DBEN &= ~GPIO_DBEN_ENABLE(pin))
N
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   clksrc      The de-bounce counter clock source. It could be GPIO_DBNCECON_DBCLKSRC_HCLK or GPIO_DBNCECON_DBCLKSRC_IRC10K.
N * @param[in]   clksel      The de-bounce sampling cycle selectionn. It could be \n
N *                              GPIO_DBNCECON_DBCLKSEL_1, GPIO_DBNCECON_DBCLKSEL_2, GPIO_DBNCECON_DBCLKSEL_4, GPIO_DBNCECON_DBCLKSEL_8, \n
N *                              GPIO_DBNCECON_DBCLKSEL_16, GPIO_DBNCECON_DBCLKSEL_32, GPIO_DBNCECON_DBCLKSEL_64, GPIO_DBNCECON_DBCLKSEL_128, \n
N *                              GPIO_DBNCECON_DBCLKSEL_256, GPIO_DBNCECON_DBCLKSEL_512, GPIO_DBNCECON_DBCLKSEL_1024, GPIO_DBNCECON_DBCLKSEL_2048, \n
N *                              GPIO_DBNCECON_DBCLKSEL_4096, GPIO_DBNCECON_DBCLKSEL_8192, GPIO_DBNCECON_DBCLKSEL_16384, GPIO_DBNCECON_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBNCECON_DBCLKSRC_IRC10K, GPIO_DBNCECON_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *              and system will sampling interrupt input once per 1600 us.
N */
N#define _GPIO_SET_DEBOUNCE_TIME(clksrc, clksel)  (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | clksrc | clksel))
N
N
N/**
N * @brief       Get GPIO Pin Interrupt Status
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define _GPIO_GET_INT_STATUS(PORT, pin)          ((((PORT)->ISRC & (GPIO_ISRC_ISRC##pin)) == (GPIO_ISRC_ISRC##pin))? 1:0)
N
N
N/**
N * @brief       Clear GPIO Pin Interrupt Status
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define _GPIO_CLEAR_INT_STATUS(PORT, pin)          ((PORT)->ISRC = (GPIO_ISRC_ISRC##pin))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief       Enable GPIO interrupt
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N * @param[in]   u32Attribs  The interrupt attribute of specified GPIO pin. It could be \n
N *                          GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
Nstatic __INLINE void GPIO_EnableInt(GPIO_T *PORT, uint32_t u32Pin, uint32_t u32IntAttribs)
Xstatic __inline void GPIO_EnableInt(GPIO_T *PORT, uint32_t u32Pin, uint32_t u32IntAttribs)
N{
N    PORT->IMD |= (_GET_BYTE3(u32IntAttribs) << u32Pin);
X    PORT->IMD |= (((u32IntAttribs & (0xFF000000)) >> 24) << u32Pin);
N    PORT->IEN |= ((u32IntAttribs & 0xFFFFFFUL) << u32Pin);
N}
N
N
N/**
N * @brief       Disable GPIO interrupt
N *
N * @param[in]   PORT        GPIO port. It could be PORT0, PORT1, .. PORT4.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
Nstatic __INLINE void GPIO_DisableInt(GPIO_T *PORT, uint32_t u32Pin)
Xstatic __inline void GPIO_DisableInt(GPIO_T *PORT, uint32_t u32Pin)
N{
N    PORT->IMD &= ~((BIT0) << u32Pin);
X    PORT->IMD &= ~((0x00000001) << u32Pin);
N    PORT->IEN &= ~((0x00010001UL) << u32Pin);
N}
N
N
N/**
N  * @} End of GPIO Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif  // __GPIO_H__
L 6187 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "I2C.h"
L 1 "..\..\LibM051Series\StdDriver\inc\I2C.h" 1
N/**************************************************************************//**
N * @file     I2C.h   
N * @version  V2.1
N * $Revision: 4 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series I2C Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#include "M051Series.h"
N
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup I2C_FUNC I2C Device Function Interface
N  * @{
N  */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CON constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CON_STA_STO_SI        0x38UL /*!< I2CON setting for I2C control bits. It would set STA, STO and SI bits     */
N#define I2C_I2CON_STA_STO_SI_AA     0x3CUL /*!< I2CON setting for I2C control bits. It would set STA, STO, SI and AA bits */
N#define I2C_I2CON_STA_SI            0x28UL /*!< I2CON setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_I2CON_STA_SI_AA         0x2CUL /*!< I2CON setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_I2CON_STO_SI            0x18UL /*!< I2CON setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_I2CON_STO_SI_AA         0x1CUL /*!< I2CON setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_I2CON_SI                0x08UL /*!< I2CON setting for I2C control bits. It would set SI bit                   */
N#define I2C_I2CON_SI_AA             0x0CUL /*!< I2CON setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_I2CON_STA               0x20UL /*!< I2CON setting for I2C control bits. It would set STA bit                  */
N#define I2C_I2CON_AA                0x04UL /*!< I2CON setting for I2C control bits. It would set AA bit                   */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CLK constant definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CLK_DIV4(x)    ((x)-1)    /*!< I2CLK setting for I2C clock divide. I2C clock = APBCLK / (x*4). 5 <= x <= 256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macro                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Generate START signal to I2C bus
N *
N * @param[in]  port    I2C port 
N *
N * @return     None
N *
N * @details    This macro is used to generate START signal to specified I2C port 
N */
N#define _I2C_START(port) _I2C_SET_CONTROL_BITS(port, I2C_I2CON_STA_SI)
N
N/**
N * @brief      Waiting for I2C action done
N *
N * @param[in]  port    I2C port 
N *
N * @return     None
N *
N * @details    This function is used to wait I2C action done by polling SI bit of I2CON. 
N */
N#define _I2C_WAIT_READY(port) while(((port)->I2CON & I2C_I2CON_SI_Msk) == 0)
N
N/**
N * @brief      Generate STOP signal to I2C bus
N *
N * @param[in]  port    I2C port 
N *
N * @return     None
N *
N * @details    This macro is used to generate STOP signal to specified I2C port  
N */
N#define _I2C_STOP(port) _I2C_SET_CONTROL_BITS(port, I2C_I2CON_STO_SI)
N
N/**
N * @brief      Send a byte to I2C bus
N *
N * @param[in]  port    I2C port 
N * @param[in]  u8Data  The data to send to I2C bus. 
N *
N * @return     None
N *
N * @details    This macro is used to write a byte to specified I2C port  
N */
N#define _I2C_WRITE(port, u8Data) ((port)->I2CDAT = (u8Data));((port)->I2CON = I2C_I2CON_ENS1_Msk | I2C_I2CON_SI_Msk)
N
N/**
N * @brief      Read a byte from I2C bus and return ACK
N *
N * @param[in]  port    I2C port 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This macro is used to read a byte from specified I2C port and return ACK
N */
N#define _I2C_READ_ACK(port)         I2C_ReadAck(port)
N
N/**
N * @brief      Read a byte from I2C bus and return NAK
N *
N * @param[in]  port    I2C port 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This macro is used to read a byte from specified I2C port and return NAK
N */
N#define _I2C_READ_NAK(port)     I2C_ReadNak(port)
N
N
N/**
N * @brief      Set I2C Control Bits
N *
N * @param[in]  port    I2C port
N * @param[in]  u8Ctrl  I2C Control Bit. Including
N *                     -I2C_I2CON_STA_STO_SI   : Set STA, STO and SI bits
N *                     -I2C_I2CON_STA_STO_SI_AA: Set STA, STO, SI and AA bits 
N *                     -I2C_I2CON_STA_SI       : Set STA and SI bits      
N *                     -I2C_I2CON_STA_SI_AA    : Set STA, SI and AA bits
N *                     -I2C_I2CON_STO_SI       : Set STO and SI bits        
N *                     -I2C_I2CON_STO_SI_AA    : Set STO, SI and AA bits    
N *                     -I2C_I2CON_SI           : Set SI bit               
N *                     -I2C_I2CON_SI_AA        : Set SI and AA bits
N *                     -I2C_I2CON_STA          : Set STA bit               
N *                     -I2C_I2CON_AA           : Set AA bit
N *
N * @return     None
N *
N * @details    To set I2C control bits include STA, STO, SI and AA in I2C CONTROL REGISTER (I2CON)
N *
N * @note
N *             This function will enable EI bit. If user does not need to use interrupt, 
N *             user can disable corresponding NVIC bit of I2C.
N */
N#define _I2C_SET_CONTROL_BITS(port, u8Ctrl)     ((port)->I2CON = I2C_I2CON_EI_Msk | I2C_I2CON_ENS1_Msk | (u8Ctrl))
N
N/**
N * @brief      Get I2C Bus Clock 
N *
N * @param[in]  port    I2C port 
N *
N * @return     The actual I2C Bus clock in Hz
N *
N * @details    To get the actual I2C Bus Clock frequency.
N */
N#define _I2C_GET_BUS_CLOCK(port)         (SystemCoreClock/((((port)->I2CLK)+1)<<2))       
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR0
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR0). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_0(port, u8SlaveAddr)    ((port)->I2CADDR0 = ((port)->I2CADDR0 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR1
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR1). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_1(port, u8SlaveAddr)    ((port)->I2CADDR1 = ((port)->I2CADDR1 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR2
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address 
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR2). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_2(port, u8SlaveAddr)    ((port)->I2CADDR2 = ((port)->I2CADDR2 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR3
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR3). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_3(port, u8SlaveAddr)    ((port)->I2CADDR3 = ((port)->I2CADDR3 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM0
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR0
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM0). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_0(port, u8SlaAddrMsk)    ((port)->I2CADM0 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)     
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM1
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR1
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM1). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_1(port, u8SlaAddrMsk)    ((port)->I2CADM1 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)     
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM2
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR2
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM2). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_2(port, u8SlaAddrMsk)    ((port)->I2CADM2 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)     
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM3
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR3
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM3). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_3(port, u8SlaAddrMsk)    ((port)->I2CADM3 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)    
N
N
N#define _I2C_ENABLE_TIMEOUT_COUNTER(port)  ((port)->I2CTOC |=  I2C_I2CTOC_ENTI_Msk) /*!< Enable 14-bit Time-out Counter  */
N#define _I2C_DISABLE_TIMEOUT_COUNTER(port) ((port)->I2CTOC &= ~I2C_I2CTOC_ENTI_Msk) /*!< Disable 14-bit Time-out Counter */
N#define _I2C_ENABLE_GENERAL_CALL(port)    ((port)->I2CADDR0 |=  I2C_I2CADDR_GC_Msk) /*!< Enable General Call Mode  */
N#define _I2C_DISABLE_GENERAL_CALL(port)   ((port)->I2CADDR0 &= ~I2C_I2CADDR_GC_Msk) /*!< Disable General Call Mode */
N
N/**
N * @brief      Read a byte from I2C bus and return ACK
N *
N * @param[in]  port    I2C port. 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This function is used to read a byte from specified I2C port and return ACK
N */
Nstatic __INLINE uint8_t I2C_ReadAck(I2C_T *port)
Xstatic __inline uint8_t I2C_ReadAck(I2C_T *port)
N{
N    (port)->I2CDAT= 0xFF;
N    (port)->I2CON = I2C_I2CON_ENS1_Msk | I2C_I2CON_SI_Msk | I2C_I2CON_AA_Msk;
X    (port)->I2CON = (1ul << 6) | (1ul << 3) | (1ul << 2);
N    _I2C_WAIT_READY(port);
X    while(((port)->I2CON & (1ul << 3)) == 0);
N    return (port)->I2CDAT;
N}
N
N/**
N * @brief      Read a byte from I2C bus and return NAK
N *
N * @param[in]  port    I2C port. 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This function is used to read a byte from specified I2C port and return NAK
N */
Nstatic __INLINE uint8_t I2C_ReadNak(I2C_T *port)
Xstatic __inline uint8_t I2C_ReadNak(I2C_T *port)
N{
N    (port)->I2CDAT= 0xFF;
N    (port)->I2CON = I2C_I2CON_ENS1_Msk | I2C_I2CON_SI_Msk;
X    (port)->I2CON = (1ul << 6) | (1ul << 3);
N    _I2C_WAIT_READY(port);
X    while(((port)->I2CON & (1ul << 3)) == 0);
N    return (port)->I2CDAT;
N}
N
N
N/**
N * @brief      Set I2C Clock Divider
N *
N * @param[in]  tI2C         I2C port 
N * @param[in]  u32BusClock  The target I2C Bus Clock in Hz
N *
N * @return     None
N *                                
N * @details    To set proper clock divider in I2C CLOCK DIVIDED REGISTER (I2CLK) 
N *             according to the target I2C Bus Clock. I2C bus clock = PCLK / (4x(divider+1)).
N *
N * @note
N *             The maximum of I2C bus clock is 1 MHz and the minimum of the divider is 4.
N */
Nstatic __INLINE void I2C_SetBusClockFreq(I2C_T * tI2C, uint32_t u32BusClock)
Xstatic __inline void I2C_SetBusClockFreq(I2C_T * tI2C, uint32_t u32BusClock)
N{
N    uint32_t u32divider;     
N 
N    u32divider = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1);
N                        
N    tI2C->I2CLK = (u32divider & ~0xFF)? 0xFF:((u32divider & ~0x03)? u32divider: 4);
N}
N
N/**
N  * @} End of I2C Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif
N
L 6188 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "PWM.h"
L 1 "..\..\LibM051Series\StdDriver\inc\PWM.h" 1
N/**************************************************************************//**
N * @file     PWM.h
N * @version  V2.1
N * $Revision: 7 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series PWM Generator and Capture Timer Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N *
N ******************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__    
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Includes of system headers                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#include "M051Series.h"
N
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup PWM_FUNC PWM Device Function Interface
N  * @{
N  */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PPR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_PPR_CP01(x)     (((x)-1) << PWM_PPR_CP01_Pos) /*!< PPR setting for PWM01 clock prescale. x = 2 ~ 256 */
N#define PWM_PPR_CP23(x)     (((x)-1) << PWM_PPR_CP23_Pos) /*!< PPR setting for PWM23 clock prescale. x = 2 ~ 256 */
N#define PWM_PPR_DZI01(x)    ((x)<< PWM_PPR_DZI01_Pos)  /*!< PPR setting for PWM01 dead zone. x = 0 ~ 255 */
N#define PWM_PPR_DZI23(x)    ((x)<< PWM_PPR_DZI23_Pos)  /*!< PPR setting for PWM01 dead zone. x = 0 ~ 255 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CSR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CSR_DIV1    4         /*!< CSR setting for PWM Timer clock source divided by 1 */
N#define PWM_CSR_DIV2    0         /*!< CSR setting for PWM Timer clock source divided by 2 */
N#define PWM_CSR_DIV4    1         /*!< CSR setting for PWM Timer clock source divided by 4 */
N#define PWM_CSR_DIV8    2         /*!< CSR setting for PWM Timer clock source divided by 8 */
N#define PWM_CSR_DIV16   3         /*!< CSR setting for PWM Timer clock source divided by 16 */
N
N#define PWM_CSR_CSR0(x)     ((x) << PWM_CSR_CSR0_Pos) /*!< CSR setting for CSR0 */
N#define PWM_CSR_CSR1(x)     ((x) << PWM_CSR_CSR1_Pos) /*!< CSR setting for CSR1 */
N#define PWM_CSR_CSR2(x)     ((x) << PWM_CSR_CSR2_Pos) /*!< CSR setting for CSR2 */
N#define PWM_CSR_CSR3(x)     ((x) << PWM_CSR_CSR3_Pos) /*!< CSR setting for CSR3 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PCR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_PCR_CH0EN_ENABLE    (1UL << PWM_PCR_CH0EN_Pos) /*!< PCR setting for channel 0 Timer Enable */
N#define PWM_PCR_CH1EN_ENABLE    (1UL << PWM_PCR_CH1EN_Pos) /*!< PCR setting for channel 1 Timer Enable */
N#define PWM_PCR_CH2EN_ENABLE    (1UL << PWM_PCR_CH2EN_Pos) /*!< PCR setting for channel 2 Timer Enable */
N#define PWM_PCR_CH3EN_ENABLE    (1UL << PWM_PCR_CH3EN_Pos) /*!< PCR setting for channel 3 Timer Enable */
N#define PWM_PCR_CH0INV_ENABLE  (1UL << PWM_PCR_CH0INV_Pos) /*!< PCR setting for channel 0 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH1INV_ENABLE  (1UL << PWM_PCR_CH1INV_Pos) /*!< PCR setting for channel 1 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH2INV_ENABLE  (1UL << PWM_PCR_CH2INV_Pos) /*!< PCR setting for channel 2 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH3INV_ENABLE  (1UL << PWM_PCR_CH3INV_Pos) /*!< PCR setting for channel 3 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH0MOD_AUTO_RELOAD (1UL << PWM_PCR_CH0MOD_Pos) /*!< PCR setting for channel 0 Timer auto-reload mode */
N#define PWM_PCR_CH1MOD_AUTO_RELOAD (1UL << PWM_PCR_CH1MOD_Pos) /*!< PCR setting for channel 1 Timer auto-reload mode */
N#define PWM_PCR_CH2MOD_AUTO_RELOAD (1UL << PWM_PCR_CH2MOD_Pos) /*!< PCR setting for channel 2 Timer auto-reload mode */
N#define PWM_PCR_CH3MOD_AUTO_RELOAD (1UL << PWM_PCR_CH3MOD_Pos) /*!< PCR setting for channel 3 Timer auto-reload mode */
N#define PWM_PCR_CH0MOD_ONE_SHOT    0                           /*!< PCR setting for channel 0 Timer one-shot mode */
N#define PWM_PCR_CH1MOD_ONE_SHOT    0                           /*!< PCR setting for channel 1 Timer one-shot mode */
N#define PWM_PCR_CH2MOD_ONE_SHOT    0                           /*!< PCR setting for channel 2 Timer one-shot mode */
N#define PWM_PCR_CH3MOD_ONE_SHOT    0                           /*!< PCR setting for channel 3 Timer one-shot mode */
N#define PWM_PCR_DZEN01_ENABLE (1UL << PWM_PCR_DZEN01_Pos) /*!< PCR setting for Dead-Zone 0 Generator Enable/ */
N#define PWM_PCR_DZEN23_ENABLE (1UL << PWM_PCR_DZEN23_Pos) /*!< PCR setting for Dead-Zone 2 Generator Enable/ */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PIER constants definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_PIER_PWMIE0_ENABLE  (1UL << PWM_PIER_PWMIE0_Pos) /*!< PIER setting for channel 0 Timer period Interrupt Enable */
N#define PWM_PIER_PWMIE1_ENABLE  (1UL << PWM_PIER_PWMIE1_Pos) /*!< PIER setting for channel 1 Timer period Interrupt Enable */
N#define PWM_PIER_PWMIE2_ENABLE  (1UL << PWM_PIER_PWMIE2_Pos) /*!< PIER setting for channel 2 Timer period Interrupt Enable */
N#define PWM_PIER_PWMIE3_ENABLE  (1UL << PWM_PIER_PWMIE3_Pos) /*!< PIER setting for channel 3 Timer period Interrupt Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CCR0/CCR2 constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CCR0_INV0_ENABLE  (1UL << PWM_CCR0_INV0_Pos) /*!< CCR0 setting for Channel 0 Capture Inverter enable */
N#define PWM_CCR0_INV1_ENABLE  (1UL << PWM_CCR0_INV1_Pos) /*!< CCR0 setting for Channel 1 Capture Inverter enable */
N#define PWM_CCR2_INV2_ENABLE  (1UL << PWM_CCR2_INV2_Pos) /*!< CCR2 setting for Channel 2 Capture Inverter enable */
N#define PWM_CCR2_INV3_ENABLE  (1UL << PWM_CCR2_INV3_Pos) /*!< CCR2 setting for Channel 3 Capture Inverter enable */
N
N#define PWM_CCR0_CRL_IE0_ENABLE  (1UL << PWM_CCR0_CRL_IE0_Pos) /*!< CCR0 setting for Channel 0 Capture Rising Latch Interrupt Enable */
N#define PWM_CCR0_CRL_IE1_ENABLE  (1UL << PWM_CCR0_CRL_IE1_Pos) /*!< CCR0 setting for Channel 1 Capture Rising Latch Interrupt Enable */
N#define PWM_CCR2_CRL_IE2_ENABLE  (1UL << PWM_CCR2_CRL_IE2_Pos) /*!< CCR2 setting for Channel 2 Capture Rising Latch Interrupt Enable */
N#define PWM_CCR2_CRL_IE3_ENABLE  (1UL << PWM_CCR2_CRL_IE3_Pos) /*!< CCR2 setting for Channel 3 Capture Rising Latch Interrupt Enable */
N
N#define PWM_CCR0_CFL_IE0_ENABLE  (1UL << PWM_CCR0_CFL_IE0_Pos) /*!< CCR0 setting for Channel 0 Capture Falling Latch Interrupt Enable */
N#define PWM_CCR0_CFL_IE1_ENABLE  (1UL << PWM_CCR0_CFL_IE1_Pos) /*!< CCR0 setting for Channel 1 Capture Falling Latch Interrupt Enable */
N#define PWM_CCR2_CFL_IE2_ENABLE  (1UL << PWM_CCR2_CFL_IE2_Pos) /*!< CCR2 setting for Channel 2 Capture Falling Latch Interrupt Enable */
N#define PWM_CCR2_CFL_IE3_ENABLE  (1UL << PWM_CCR2_CFL_IE3_Pos) /*!< CCR2 setting for Channel 3 Capture Falling Latch Interrupt Enable */
N
N#define PWM_CCR0_CAPCH0EN_ENABLE  (1UL << PWM_CCR0_CAPCH0EN_Pos) /*!< CCR0 setting for Channel 0 Capture Function Enable */
N#define PWM_CCR0_CAPCH1EN_ENABLE  (1UL << PWM_CCR0_CAPCH1EN_Pos) /*!< CCR0 setting for Channel 1 Capture Function Enable */
N#define PWM_CCR2_CAPCH2EN_ENABLE  (1UL << PWM_CCR2_CAPCH2EN_Pos) /*!< CCR2 setting for Channel 2 Capture Function Enable */
N#define PWM_CCR2_CAPCH3EN_ENABLE  (1UL << PWM_CCR2_CAPCH3EN_Pos) /*!< CCR2 setting for Channel 3 Capture Function Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAPENR constants definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CAPENR_CINEN0_ENABLE  (1UL << PWM_CAPENR_CINEN0_Pos) /*!< CAPENR setting for Channel 0 Capture Input Enable */
N#define PWM_CAPENR_CINEN1_ENABLE  (1UL << PWM_CAPENR_CINEN1_Pos) /*!< CAPENR setting for Channel 1 Capture Input Enable */
N#define PWM_CAPENR_CINEN2_ENABLE  (1UL << PWM_CAPENR_CINEN2_Pos) /*!< CAPENR setting for Channel 2 Capture Input Enable */
N#define PWM_CAPENR_CINEN3_ENABLE  (1UL << PWM_CAPENR_CINEN3_Pos) /*!< CAPENR setting for Channel 3 Capture Input Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  POE constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_POE_PWM0_ENABLE  (1UL << PWM_POE_PWM0_Pos) /*!< POE setting for Channel 0 PWM Output Enable */
N#define PWM_POE_PWM1_ENABLE  (1UL << PWM_POE_PWM1_Pos) /*!< POE setting for Channel 1 PWM Output Enable */
N#define PWM_POE_PWM2_ENABLE  (1UL << PWM_POE_PWM2_Pos) /*!< POE setting for Channel 2 PWM Output Enable */
N#define PWM_POE_PWM3_ENABLE  (1UL << PWM_POE_PWM3_Pos) /*!< POE setting for Channel 3 PWM Output Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWM Group channel numebr constants definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CH0     0x0            /*!< PWM Group A/B channel 0 */
N#define PWM_CH1     0x1            /*!< PWM Group A/B channel 1 */
N#define PWM_CH2     0x2            /*!< PWM Group A/B channel 2 */
N#define PWM_CH3     0x3            /*!< PWM Group A/B channel 3 */
N
N#define PWM_CCR_MASK    0x000F000F          /*!< PWM CCR0/CCR2 bit0~3 and bit16~19 mask */ 
N
N
N/**
N * @brief      Set timer pre-scale for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @param[in]  u32Prescaler   PWM timer prescaler value(0 ~ 0xFF)
N *
N * @return     None
N *
N * @details    This function is used to set timer pre-scale for specified channel
N *
N * @note       - If u32Prescaler = 0, corresponding PWM-timer will be stopped
N *             - If u32Prescaler = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N 
N */
N#define _PWM_SET_TIMER_PRESCALE(PWM,u32Ch,u32Prescaler)\
N{\
N    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_CP01_Msk<<(((u32Ch)/2)*8))\
N                                 |((u32Prescaler)<<(PWM_PPR_CP01_Pos+(((u32Ch)/2)*8)));\
N}
X#define _PWM_SET_TIMER_PRESCALE(PWM,u32Ch,u32Prescaler){    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_CP01_Msk<<(((u32Ch)/2)*8))                                 |((u32Prescaler)<<(PWM_PPR_CP01_Pos+(((u32Ch)/2)*8)));}
N
N
N
N
N/**
N * @brief      Get timer pre-scale for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @return     Pre-scaler value (0~0xFF)
N *
N * @details    This function is used to get timer pre-scale for specified channel
N *
N * @note       - If retuened Pre-scaler value = 0, it means corresponding PWM-timer stop
N *             - If retuened Pre-scaler value = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N */
N#define _PWM_GET_TIMER_PRESCALE(PWM,u32Ch) (((PWM)->PPR&(PWM_PPR_CP01_Msk<<(((u32Ch)/2)*8)))>>(PWM_PPR_CP01_Pos+(((u32Ch)/2)*8)))
N
N
N
N
N/**
N * @brief      Set PWM dead-zone length for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH2   
N * @param[in]  u32DeadZoneLen PWM dead-zone length (0 - 0xFF)
N *
N * @return     None
N *
N * @details    This function is used to set PWM dead-zone length for specified channel.\n
N *             The unit time of dead zone length = [(prescale+1)*(clock source divider)]/PWMxy_CLK ,\n
N *             where xy, could be 01, 23 depends on selected PWM channel for PWM group A/B.
N *
N * @note       - Channel 0 and channel 1 are complementary pair and share the same dead-zone length.
N *             - Channel 2 and channel 3 are complementary pair and share the same dead-zone length. 
N *
N */
N#define _PWM_SET_PWM_DEADZONE_LENGTH(PWM,u32Ch,u32DeadZoneLen)\
N{\
N    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_DZI01_Msk<<(((u32Ch)/2)*8))\
N                                 |((u32DeadZoneLen)<<(PWM_PPR_DZI01_Pos+(((u32Ch)/2)*8)));\
N}
X#define _PWM_SET_PWM_DEADZONE_LENGTH(PWM,u32Ch,u32DeadZoneLen){    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_DZI01_Msk<<(((u32Ch)/2)*8))                                 |((u32DeadZoneLen)<<(PWM_PPR_DZI01_Pos+(((u32Ch)/2)*8)));}
N
N
N
N/**
N * @brief       Get PWM dead-zone length for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH2   
N *
N * @return     Specified channel PWM dead-zone length (0 - 0xFF)
N *
N * @details    This function is used to get PWM dead-zone length for specified channel.
N *
N *             The unit time of dead zone length = [(prescale+1)*(clock source divider)]/PWMxy_CLK , \n
N *             where xy, could be 01, 23, depends on selected PWM channel for PWM group A/B..
N *
N * @note       - Channel 0 and channel 1 are complementary pair and share the same dead-zone length.
N *             - Channel 2 and channel 3 are complementary pair and share the same dead-zone length.  
N */
N#define _PWM_GET_PWM_DEADZONE_LENGTH(PWM,u32Ch) (((PWM)->PPR&(PWM_PPR_DZI01_Msk<<(((u32Ch)/2)*8)))>>(PWM_PPR_DZI01_Pos+(((u32Ch)/2)*8)))
N
N
N
N
N/**
N * @brief       Set Timer clock source divider selection for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @param[in]  u32ClockDivSel Timer clock source divider selection
N *                            - PWM_CSR_DIV1 (4)
N *                            - PWM_CSR_DIV2 (0) 
N *                            - PWM_CSR_DIV4 (1) 
N *                            - PWM_CSR_DIV8 (2) 
N *                            - PWM_CSR_DIV16(3)   
N *
N * @return     None
N *
N * @details    This function is used to set Timer clock source divider selection for specified channel
N *
N */
N#define _PWM_SET_TIMER_CLOCK_DIV(PWM,u32Ch,u32ClockDivSel)\
N{\
N    (PWM)->CSR = (PWM)->CSR&~(PWM_CSR_CSR0_Msk<<((u32Ch)*4))\
N                                 |((u32ClockDivSel)<<(PWM_CSR_CSR0_Pos+((u32Ch)*4)));\
N}
X#define _PWM_SET_TIMER_CLOCK_DIV(PWM,u32Ch,u32ClockDivSel){    (PWM)->CSR = (PWM)->CSR&~(PWM_CSR_CSR0_Msk<<((u32Ch)*4))                                 |((u32ClockDivSel)<<(PWM_CSR_CSR0_Pos+((u32Ch)*4)));}
N
N
N/**
N * @brief      Get timer clock source divider selection for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @retval     4              Input clock divided by 1
N * @retval     0              Input clock divided by 2
N * @retval     1              Input clock divided by 4
N * @retval     2              Input clock divided by 8
N * @retval     3              Input clock divided by 16    
N *
N * @details    This function is used to get timer clock source divider selection for specified channel
N *
N */
N#define _PWM_GET_TIMER_CLOCK_DIV(PWM,u32Ch) (((PWM)->CSR&(PWM_CSR_CSR0_Msk<<((u32Ch)*4)))>>(PWM_CSR_CSR0_Pos+((u32Ch)*4)))
N
N
N
N
N/**
N * @brief      Enable timer for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable timer for specified channel
N *
N */
N#define _PWM_ENABLE_TIMER(PWM,u32Ch) (PWM)->PCR|= (PWM_PCR_CH0EN_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Disable timer for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable timer for specified channel
N *
N */
N#define _PWM_DISABLE_TIMER(PWM,u32Ch) (PWM)->PCR&= ~(PWM_PCR_CH0EN_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Enable PWM output inveter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable PWM output inveter for specified channel
N *
N */
N#define _PWM_ENABLE_PWM_INV(PWM,u32Ch) (PWM)->PCR|= (PWM_PCR_CH0INV_Msk<<((u32Ch)*8))
N
N
N
N/**
N * @brief      Disable PWM output inveter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable PWM output inveter for specified channel
N *
N */
N#define _PWM_DISABLE_PWM_INV(PWM,u32Ch) (PWM)->PCR&= ~(PWM_PCR_CH0INV_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Set timer auto-reolad mode for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer auto-reolad mode for specified channel
N *
N * @note       If user changes timer mode from auto-reload to one-shot or from one-shot to auto-reload mode,\n
N *             it will cause CNR0 and CMR0 be clear.
N *
N */
N#define _PWM_SET_TIMER_AUTO_RELOAD_MODE(PWM,u32Ch) (PWM)->PCR |= (PWM_PCR_CH0MOD_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Set timer One-shot mode for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer One-shot mode for specified channel
N *
N * @note       - If user changes timer mode from auto-reload to one-shot or from one-shot to auto-reload mode,\n
N *             it will cause CNR0 and CMR0 be clear.
N *             - After PWM waveform generated once in PWM one-shot mode, CNR and CMR settings will be cleared and\n
N *               PWM-Timer will stop automatically.
N *               The following procedure is recommended for re-starting PWM single-shot waveform.
N *               Step 1: Setup comparator register (CMR) for setting PWM duty.
N *               Step 2: Setup PWM down-counter register (CNR) for setting PWM period. After setup CNR, PWM wave will be generated once again.
N *
N */
N#define _PWM_SET_TIMER_ONE_SHOT_MODE(PWM,u32Ch) (PWM)->PCR &= ~(PWM_PCR_CH0MOD_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Enable PWM Dead-Zone generator for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH2   
N * @return     None
N *
N * @details    This function is used to enable PWM Dead-Zone generator for specified channel pair
N *
N * @note       - When Channel 0 Dead-Zone Generator is enabled, channel 0 and channel 1 becomes a complementary pair.  
N *             - When Channel 2 Dead-Zone Generator is enabled, channel 2 and channel 3 becomes a complementary pair.  
N *
N */
N#define _PWM_ENABLE_PWM_DEADZONE(PWM,u32Ch) (PWM)->PCR|=(PWM_PCR_DZEN01_Msk<<((u32Ch)/2))
N
N
N
N
N/**
N * @brief      Disable PWM Dead-Zone generator for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable PWM Dead-Zone generator for specified channel pair
N *
N */
N#define _PWM_DISABLE_PWM_DEADZONE(PWM,u32Ch) (PWM)->PCR&=~(PWM_PCR_DZEN01_Msk<<((u32Ch)/2))
N
N
N
N
N/**
N * @brief      Set timer loaded value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3  
N * @param[in]  u32LoadedVal   Timer loaded value(0~0xFFFF)
N *     
N * @return     None
N *
N * @details    This function is used to set timer loaded value(CNR) for specified channel.\n
N *             Loaded value determines the PWM period.
N *
N * @note       - If u32LoadedVal=0, PWM timer counter will stop.   
N *
N */
N#define _PWM_SET_TIMER_LOADED_VALUE(PWM,u32Ch,u32LoadedVal)\
N{\
N     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CNR0) + (u32Ch)*12))) = (u32LoadedVal));\
N}
X#define _PWM_SET_TIMER_LOADED_VALUE(PWM,u32Ch,u32LoadedVal){     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CNR0) + (u32Ch)*12))) = (u32LoadedVal));}
N
N
N
N/**
N * @brief      Get timer loaded value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     Timer loaded value (0 - 0xFFFF)
N *
N * @details    This function is used to get timer loaded value for specified channel
N *
N */
N#define _PWM_GET_TIMER_LOADED_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CNR0) + (u32Ch)*12))))
N
N
N
N
N/**
N * @brief      Set PWM Comparator value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3  
N * @param[in]  u32Compatator  PWM Comparator value (0 - 0xFFFF)
N *  
N * @return     None
N *
N * @details    This function is used to set PWM Comparator value for specified channel
N *
N */
N#define _PWM_SET_PWM_COMP_VALUE(PWM,u32Ch,u32Compatator)\
N{\
N     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CMR0) + (u32Ch)*12))) = (u32Compatator));\
N}
X#define _PWM_SET_PWM_COMP_VALUE(PWM,u32Ch,u32Compatator){     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CMR0) + (u32Ch)*12))) = (u32Compatator));}
N
N
N
N/**
N * @brief      Get PWM Comparator value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     PWM Comparator value (0 - 0xFFFF)
N *
N * @details    This function is used to get PWM Comparator value for specified channel
N *
N */
N#define _PWM_GET_PWM_COMP_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CMR0) + (u32Ch)*12))))
N
N
N
N
N/**
N * @brief      Get timer current counter value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3 
N * @return     Timer current counter value (0 - 0xFFFF)      
N *
N * @details    This function is used to get timer current counter value(PDR) for specified channel.\n
N *             User can monitor PDR to know the current value in 16-bit counter.
N *
N */
N#define _PWM_GET_TIMER_CURRENT_COUNTER_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->PDR0)) + (u32Ch)*12)))
N
N
N
N
N/**
N * @brief      Enable timer period interrupt for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable timer period interrupt for specified channel
N *
N */
N#define _PWM_ENABLE_TIMER_PERIOD_INT(PWM,u32Ch) ((PWM)->PIER|= (PWM_PIER_PWMIE0_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief       Disable timer period interrupt for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable timer period interrupt for specified channel
N *
N */
N#define _PWM_DISABLE_TIMER_PERIOD_INT(PWM,u32Ch) ((PWM)->PIER&= ~(PWM_PIER_PWMIE0_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief       Get timer period interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @retval      0             The specified channel timer interrupt flag is not set 
N * @retval      1             The specified channel timer interrupt flag is set
N *
N * @details    This function is used to get timer period interrupt flag for specified channel
N *
N */
N#define _PWM_GET_TIMER_PERIOD_INT_FLAG(PWM,u32Ch) (((PWM)->PIIR&(PWM_PIIR_PWMIF0_Msk<<(u32Ch)))?1:0)
N
N
N/**
N * @brief      Clear timer period interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to clear timer period interrupt flag for specified channel
N *
N */
N#define _PWM_CLEAR_TIMER_PERIOD_INT_FLAG(PWM,u32Ch) ((PWM)->PIIR = (PWM_PIIR_PWMIF0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief      Enable capture input inverter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable capture input inverter for specified channel
N *
N *
N */
N#define _PWM_ENABLE_CAP_INV(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_INV(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief      Disable capture input inverter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable capture input inverter for specified channel
N *
N *
N */
N#define _PWM_DISABLE_CAP_INV(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_INV(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Enable capture rising latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable capture rising latch interrupt for specified channel
N *
N *
N */
N#define _PWM_ENABLE_CAP_RISING_INT(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_RISING_INT(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Disable capture rising latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture rising latch interrupt for specified channel
N *
N *
N */
N#define _PWM_DISABLE_CAP_RISING_INT(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_RISING_INT(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Enable capture falling latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable capture falling latch interrupt for specified channel
N *
N *
N */
N#define _PWM_ENABLE_CAP_FALLING_INT(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_FALLING_INT(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Disable capture falling latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture falling latch interrupt for specified channel
N *
N *
N */
N#define _PWM_DISABLE_CAP_FALLING_INT(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_FALLING_INT(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N/**
N * @brief       Enable capture function for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable capture function for specified channel
N *
N * @note        When capture function enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch). 
N *
N */
N#define _PWM_ENABLE_CAP_FUNC(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_FUNC(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Disable capture function for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture function for specified channel
N *
N * @note        When capture function disabled, Capture does not update CRLR and CFLR, and disable specified channel Interrupt.
N *
N */
N#define _PWM_DISABLE_CAP_FUNC(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_FUNC(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Get capture interrupt flag for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @retval      0             The specified channel capture interrupt flag is not set 
N * @retval      1             The specified channel capture interrupt flag is set
N *
N * @details     This function is used to get capture interrupt flag for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_INT_FLAG(PWM,u32Ch) ((u32Ch)<2)?\
N        (((PWM)->CCR0&(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16)))?1:0):\
N        (((PWM)->CCR2&(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)))?1:0)
X#define _PWM_GET_CAP_INT_FLAG(PWM,u32Ch) ((u32Ch)<2)?        (((PWM)->CCR0&(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16)))?1:0):        (((PWM)->CCR2&(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)))?1:0)
N
N/**
N * @brief      Clear capture interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to clear capture interrupt flag for specified channel
N *
N * @note       Write 1 to clear this bit
N *
N */
N#define _PWM_CLR_CAP_INT_FLAG(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_CLR_CAP_INT_FLAG(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)));}
N
N/**
N * @brief       Get capture rising latched indicator for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @retval      0             The specified channel capture falling rising indicator is not set 
N * @retval      1             The specified channel capture falling rising indicator is set
N *
N * @details     This function is used to get capture rising latched indicator for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_RISING_INDICATOR(PWM,u32Ch) ((u32Ch)<2)?\
N    (((PWM)->CCR0&(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16)))?1:0):\
N    (((PWM)->CCR2&(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)\
N
X#define _PWM_GET_CAP_RISING_INDICATOR(PWM,u32Ch) ((u32Ch)<2)?    (((PWM)->CCR0&(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16)))?1:0):    (((PWM)->CCR2&(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)
N
N
N
N/**
N * @brief      Clear capture rising latched indicator for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to clear capture rising latched indicator for specified channel
N *
N *
N */
N#define _PWM_CLR_CAP_RISING_INDICATOR(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_CLR_CAP_RISING_INDICATOR(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)));}
N        
N
N
N
N/**
N * @brief      Get capture falling latched indicator for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3    
N * @retval      0        The specified channel capture falling latched indicator is not set 
N * @retval      1        The specified channel capture falling latched indicator is set
N *
N * @details     This function is used to get capture falling latched indicator for specified channel
N *
N */
N#define _PWM_GET_CAP_FALLING_INDICATOR(PWM,u32Ch) ((u32Ch)<2)?\
N    (((PWM)->CCR0&(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16)))?1:0):\
N    (((PWM)->CCR2&(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)
X#define _PWM_GET_CAP_FALLING_INDICATOR(PWM,u32Ch) ((u32Ch)<2)?    (((PWM)->CCR0&(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16)))?1:0):    (((PWM)->CCR2&(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)
N
N
N
N
N/**
N * @brief       Clear capture falling latched indicator for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to clear capture falling latched indicator for specified channel
N *
N *
N */
N#define _PWM_CLR_CAP_FALLING_INDICATOR(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_CLR_CAP_FALLING_INDICATOR(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Get capture rising latch register value for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      Capture rising latch register value 
N *
N * @details     This function is used to get capture rising latch register value for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_RISING_LATCH_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CRLR0) + (u32Ch)*8))))
N
N
N
N
N/**
N * @brief      Get capture falling latch register value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     Capture falling latch register value 
N *
N * @details    This function is used to get capture falling latch register value for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_FALLING_LATCH_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CFLR0) + (u32Ch)*8))))
N
N
N
N
N/**
N * @brief      Enable capture input path for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable capture input path for specified channel
N *
N *
N */
N#define _PWM_ENABLE_CAP_IN(PWM,u32Ch) ((PWM)->CAPENR |= (PWM_CAPENR_CINEN0_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief       Disable capture input path for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture input path for specified channel
N *
N *
N */
N#define _PWM_DISABLE_CAP_IN(PWM,u32Ch) ((PWM)->CAPENR&= ~(PWM_CAPENR_CINEN0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief       Enable PWM output path for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable PWM output path for specified channel
N *
N *
N */
N#define _PWM_ENABLE_PWM_OUT(PWM,u32Ch) ((PWM)->POE |= (PWM_POE_PWM0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief      Disable PWM output path for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable PWM output path for specified channel.
N *
N *
N */
N#define _PWM_DISABLE_PWM_OUT(PWM,u32Ch) ((PWM)->POE&= ~(PWM_POE_PWM0_Msk<<(u32Ch)))
N
N
N
N
N
N/**
N * @brief      Reset PWM controller for specified group
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B     
N * @return     None
N *                                                           
N * @details    The function is used to reset PWM controller for specified group
N *
N * @note       PWM channel 0~3 in each group share the same PWM reset controller.
N */ 
N__INLINE void PWM_ResetPwmController(PWM_T* PWM)
X__inline void PWM_ResetPwmController(PWM_T* PWM)
N{
N    SYS->IPRSTC2 |= (SYS_IPRSTC2_PWM03_RST_Msk<<(((PWM)==PWMA)?0:1));
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |= ((1ul << 20)<<(((PWM)==((PWM_T *) ((( uint32_t)0x40000000) + 0x40000)))?0:1));
N    SYS->IPRSTC2 &= ~((SYS_IPRSTC2_PWM03_RST_Msk<<(((PWM)==PWMA)?0:1)));
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(((1ul << 20)<<(((PWM)==((PWM_T *) ((( uint32_t)0x40000000) + 0x40000)))?0:1)));
N}  
N
N
N
N
N/**
N * @brief      Get PWM Clock Source Frequency
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3  
N * @return     PWM clock source frequency
N * @details    Get the PWM clock source frequency for specified channel.
N *
N * @note       - PWM channel 0 and channel 1 share the same clock source setting. 
N *             - PWM channel 2 and channel 3 share the same clock source setting. 
N */
N__INLINE uint32_t PWM_GetTimerClockSource(PWM_T* PWM, uint32_t u32Ch)
X__inline uint32_t PWM_GetTimerClockSource(PWM_T* PWM, uint32_t u32Ch)
N{
N    uint8_t     u8EngineClk;
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};
N    
N    u32ClkTbl[2] = SystemCoreClock;        
N    u8EngineClk = ((PWM)==PWMA)?((SYSCLK->CLKSEL1&(SYSCLK_CLKSEL1_PWM01_S_Msk<<(((u32Ch)/2)*2)))
X    u8EngineClk = ((PWM)==((PWM_T *) ((( uint32_t)0x40000000) + 0x40000)))?((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1&((3ul << 28)<<(((u32Ch)/2)*2)))
N                               >>(SYSCLK_CLKSEL1_PWM01_S_Pos+((u32Ch)/2)*2)):
X                               >>(28+((u32Ch)/2)*2)):
N                              ((SYSCLK->CLKSEL2&(SYSCLK_CLKSEL2_PWM45_S_Msk<<(((u32Ch)/2)*2)))
X                              ((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL2&((3ul << 4)<<(((u32Ch)/2)*2)))
N                               >>(SYSCLK_CLKSEL2_PWM45_S_Pos+((u32Ch)/2)*2));                                             
X                               >>(4+((u32Ch)/2)*2));                                             
N    return u32ClkTbl[u8EngineClk];    
N}
N
N
N/**
N  * @} End of PWM Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif	//__PWM_H__
N
N
N
L 6189 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "SPI.h"
L 1 "..\..\LibM051Series\StdDriver\inc\SPI.h" 1
N/**************************************************************************//**
N * @file     SPI.h
N * @version  V2.1
N * $Revision: 4 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series SPI Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "M051Series.h"
N
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup SPI_FUNC SPI Device Function Interface
N  * @{
N  */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_CNTRL constant definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_CNTRL_VARCLK_EN              (1UL << 23) /*!< SPI_CNTRL setting for enable variable clock function */
N#define SPI_CNTRL_REORDER_ON_SUSPEND_ON  (1UL << 19) /*!< SPI_CNTRL setting for enable both byte reorder and byte suspend */
N#define SPI_CNTRL_REORDER_ON_SUSPEND_OFF (2UL << 19) /*!< SPI_CNTRL setting for enable byte reorder but disable byte suspend */
N#define SPI_CNTRL_REORDER_OFF_SUSPEND_ON (3UL << 19) /*!< SPI_CNTRL setting for disable byte reorder but enable byte suspend */
N#define SPI_CNTRL_MASTER_MODE            (0UL << 18) /*!< SPI_CNTRL setting for SPI master mode */
N#define SPI_CNTRL_SLAVE_MODE             (1UL << 18) /*!< SPI_CNTRL setting for SPI slave mode */
N#define SPI_CNTRL_IE_EN                  (1UL << 17) /*!< SPI_CNTRL setting for eanble interrupt */
N#define SPI_CNTRL_IF                     (1UL << 16) /*!< SPI_CNTRL interrupt flag */
N#define SPI_CNTRL_SP_CYCLE(x)            ((x) << 12) /*!< SPI_CNTRL setting for suspend interverl. it could be 0~15 */
N#define SPI_CNTRL_CLK_IDLE_HIGH          (1UL << 11) /*!< SPI_CNTRL setting for clock idle high */
N#define SPI_CNTRL_CLK_IDLE_LOW           (0)         /*!< SPI_CNTRL setting for clock idle low */
N#define SPI_CNTRL_LSB_FIRST              (1UL << 10) /*!< SPI_CNTRL setting for data format as LSB first */
N#define SPI_CNTRL_MSB_FIRST              (0)         /*!< SPI_CNTRL setting for data format as MSB first */
N#define SPI_CNTRL_TX_NUM(x)              (((x) - 1) <<  8)   /*!< SPI_CNTRL setting for burst transfer count. It could be 1 or 2 */
N#define SPI_CNTRL_TX_BIT_LEN(x)          ((((x)!=32)?(x):0) << 3) /*!< SPI_CNTRL setting for bit length of a transfer. it could be 8~32 */
N#define SPI_CNTRL_TX_RISING              (0)         /*!< SPI_CNTRL setting for output data at SPICLK rising edge */
N#define SPI_CNTRL_TX_FALLING             (4)         /*!< SPI_CNTRL setting for TX output data at SPICLK falling edge */
N#define SPI_CNTRL_RX_RISING              (0)         /*!< SPI_CNTRL setting for RX latch data at SPICLK rising edge */
N#define SPI_CNTRL_RX_FALLING             (2)         /*!< SPI_CNTRL setting for RX latch data at SPICLK falling edge */
N#define SPI_CNTRL_GO_BUSY                (1)         /*!< SPI_CNTRL setting for trigger SPI */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_DIVIDER constant definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_DIVIDER_DIV(x)  (x)         /*!< SPI_DIVIDER setting for SPI master clock divider. It could be 0~255 */
N#define SPI_DIVIDER_DIV2(x) ((x) << 16) /*!< SPI_DIVIDER setting for SPI master clock divider2 of varialbe clock function. It could be 0~255 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_SSR constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_SSR_SLAVE_FALLING_EDGE_TRIGGER (0x0)  /*!< SPI_SSR setting for falling edge trigger in SPI slave mode */
N#define SPI_SSR_SLAVE_RISING_EDGE_TRIGGER  (0x4)  /*!< SPI_SSR setting for rising edge trigger in SPI slave mode */
N#define SPI_SSR_SLAVE_LOW_LEVEL_ACTIVE     (0x10) /*!< SPI_SSR setting for low level active in SPI slave mode */
N#define SPI_SSR_SLAVE_HIGH_LEVEL_ACTIVE    (0x14) /*!< SPI_SSR setting for high level active in SPI slave mode */
N#define SPI_SSR_HW_AUTO_ACTIVE_LOW         (0x9)  /*!< SPI_SSR setting for SPI master SS signal is controled by hardware automatically and active low */
N#define SPI_SSR_HW_AUTO_ACTIVE_HIGH        (0xD)  /*!< SPI_SSR setting for SPI master SS signal is controled by hardware automatically active high */
N#define SPI_SSR_SW_SS_PIN_LOW              (0x1)  /*!< SPI_SSR setting to force SPI master SS signal to low by software */
N#define SPI_SSR_SW_SS_PIN_HIGH             (0x0)  /*!< SPI_SSR setting to force SPI master SS signal to high by software */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_CNTRL2 constant definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_CNTRL2_3WIRE_START_INTSTS                    (1UL << 11) /*!< SPI_CNTRL2 3-wire mode start interrupt flag */
N#define SPI_CNTRL2_3WIRE_START_INT_EN                    (1UL << 10) /*!< SPI_CNTRL2 setting for 3-wire mode start interrupt enable */
N#define SPI_CNTRL2_3WIRE_ABORT                           (1UL << 9)  /*!< SPI_CNTRL2 setting for 3-wire mode transfer abort */
N#define SPI_CNTRL2_3WIRE_MODE_EN                         (1UL << 8)  /*!< SPI_CNTRL2 setting for 3-wire mode enable */
N#define SPI_CNTRL2_DIV_ONE_EN                            (1)         /*!< SPI_CNTRL2 setting for DIV_ONE feature enable */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @details    Configure the user-specified SPI port as a master
N */
N#define _SPI_SET_MASTER_MODE(port) ((port)->CNTRL &= (~SPI_CNTRL_SLAVE_MODE))
N
N/**
N * @details    Configure the user-specified SPI port as a slave
N */
N#define _SPI_SET_SLAVE_MODE(port) ((port)->CNTRL |= SPI_CNTRL_SLAVE_MODE)
N
N/**
N * @details    Configure the transfer bit length of the user-specified SPI port
N */
N#define _SPI_SET_TRANSFER_BIT_LENGTH(port, x) ((port)->CNTRL = ((port)->CNTRL & SPI_CNTRL_TX_BIT_LEN_Msk) | SPI_CNTRL_TX_BIT_LEN(x))
N
N/**
N * @details    Enable the automatic slave select function of the user-specified SPI port
N */
N#define _SPI_ENABLE_HW_AUTO_SLAVE_SELECT(port) ((port)->SSR |= SPI_SSR_AUTOSS_Msk)
N
N/**
N * @details    Disable the automatic slave select function of the user-specified SPI port
N */
N#define _SPI_DISABLE_HW_AUTO_SLAVE_SELECT(port) ((port)->SSR &= (~SPI_SSR_AUTOSS_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE1(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_TX_NEG_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE2(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_RX_NEG_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE5(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE6(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk))
N
N/**
N * @details    Configure the user-specified SPI port as LSB-first transfer type
N */
N#define _SPI_SET_TRANSFER_LSB_FIRST(port) ((port)->CNTRL |= SPI_CNTRL_LSB_FIRST)
N
N/**
N * @details    Configure the user-specified SPI port as MSB-first transfer type
N */
N#define _SPI_SET_TRANSFER_MSB_FIRST(port) ((port)->CNTRL &= (~SPI_CNTRL_LSB_FIRST))
N
N/**
N * @details    Enable byte-reordering function and byte-suspend function
N */
N#define _SPI_SET_REORDER_ON_SUSPEND_ON(port) ((port)->CNTRL = (port)->CNTRL & (~SPI_CNTRL_REORDER_Msk) | SPI_CNTRL_REORDER_ON_SUSPEND_ON)
N
N/**
N * @details    Enable byte-reordering function and disable byte-suspend function
N */
N#define _SPI_SET_REORDER_ON_SUSPEND_OFF(port) ((port)->CNTRL = (port)->CNTRL & (~SPI_CNTRL_REORDER_Msk) | SPI_CNTRL_REORDER_ON_SUSPEND_OFF)
N
N/**
N * @details    Disable byte-reordering function and enable byte-suspend function
N */
N#define _SPI_SET_REORDER_OFF_SUSPEND_ON(port) ((port)->CNTRL = (port)->CNTRL & (~SPI_CNTRL_REORDER_Msk) | SPI_CNTRL_REORDER_OFF_SUSPEND_ON)
N
N/**
N * @details    Disable byte-reordering function and byte-suspend function
N */
N#define _SPI_SET_REORDER_OFF_SUSPEND_OFF(port) ((port)->CNTRL = (port)->CNTRL & (~SPI_CNTRL_REORDER_Msk))
N
N/**
N * @details    Configure the suspend interval of the user-specified SPI port. The x seeting can be 0-0xF.
N */
N#define _SPI_SET_SUSPEND_CYCLE(port, x) ((port)->CNTRL = ((port)->CNTRL & SPI_CNTRL_SP_CYCLE_Msk) | SPI_CNTRL_SP_CYCLE(x))
N
N/**
N * @details    Configure the user-specified SPI port as a low-level-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_LOW_LEVEL_ACTIVE(port) ((port)->SSR = (port)->SSR & (~(SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk)) | SPI_SSR_SS_LTRIG_Msk)
N
N/**
N * @details    Configure the user-specified SPI port as a high-level-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_HIGH_LEVEL_ACTIVE(port) ((port)->SSR |= (SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk))
N
N/**
N * @details    Configure the user-specified SPI port as a falling-edge-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_FALLING_EDGE_ACTIVE(port) ((port)->SSR &= (~(SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk)))
N
N/**
N * @details    Configure the user-specified SPI port as a rising-edge-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_RISING_EDGE_ACTIVE(port) ((port)->SSR = (port)->SSR & (~(SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk)) | SPI_SSR_SS_LVL_Msk)
N
N/**
N * @details    Get the level trigger Accomplish flag of the user-specified SPI port
N */
N#define _SPI_GET_SLAVE_LEVEL_TRIG_SUCCESS_FLAG(port) (((port)->SSR & SPI_SSR_LTRIG_FLAG_Msk)>>SPI_SSR_LTRIG_FLAG_Pos)
N
N/**
N * @details    Set the slave select control bit to 1
N */
N#define _SPI_SET_SLAVE_SELECT_CNTRL_BIT(port) ((port)->SSR |= SPI_SSR_SSR_Msk)
N
N/**
N * @details    Clear the slave select control bit to 0
N */
N#define _SPI_CLR_SLAVE_SELECT_CNTRL_BIT(port) ((port)->SSR &= (~SPI_SSR_SSR_Msk))
N
N/**
N * @details    Get the SPI busy status of the user-specified SPI port
N */
N#define _SPI_GET_BUSY_STATUS(port) ((port)->CNTRL & SPI_CNTRL_GO_BUSY_Msk)
N
N/**
N * @details    Set the SPI GO_BUSY bit of the user-specified SPI port
N */
N#define _SPI_SET_GO(port) ((port)->CNTRL |= SPI_CNTRL_GO_BUSY_Msk)
N
N/**
N * @details    Clear the SPI GO_BUSY bit of the user-specified SPI port
N */
N#define _SPI_CLR_GO(port) ((port)->CNTRL &= (~SPI_CNTRL_GO_BUSY_Msk))
N
N/**
N * @details    Enable the burst transfer mode of the user-specified SPI port
N */
N#define _SPI_ENABLE_BURST_MODE(port) ((port)->CNTRL |= (1<<SPI_CNTRL_TX_NUM_Pos))
N
N/**
N * @details    Disable the burst transfer mode of the user-specified SPI port
N */
N#define _SPI_DISABLE_BURST_MODE(port) ((port)->CNTRL &= (~SPI_CNTRL_TX_NUM_Msk))
N
N/**
N * @details    Set the SPI DIVIDER of the user-specified SPI port
N */
N#define _SPI_SET_ENGINE_CLK_DIVIDER(port, x) ((port)->DIVIDER = (port)->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk) | (x))
N
N/**
N * @details    Set the SPI DIVIDER2 of the user-specified SPI port
N */
N#define _SPI_SET_DIVIDER2(port, x) ((port)->DIVIDER = (port)->DIVIDER & (~SPI_DIVIDER_DIVIDER2_Msk) | ((x)<<SPI_DIVIDER_DIVIDER2_Pos))
N
N/**
N * @details    Enable the SPI variable clock function of the user-specified SPI port
N */
N#define _SPI_ENABLE_VARIABLE_CLOCK_FUNCTION(port) ((port)->CNTRL |= SPI_CNTRL_VARCLK_EN_Msk)
N
N/**
N * @details    Disable the SPI variable clock function of the user-specified SPI port
N */
N#define _SPI_DISABLE_VARIABLE_CLOCK_FUNCTION(port) ((port)->CNTRL &= (~SPI_CNTRL_VARCLK_EN_Msk))
N
N/**
N * @details    Enable the SPI unit transfer interrupt
N */
N#define _SPI_ENABLE_UNIT_TRANSFER_INT(port) ((port)->CNTRL |= SPI_CNTRL_IE_Msk)
N
N/**
N * @details    Disable the SPI unit transfer interrupt
N */
N#define _SPI_DISABLE_UNIT_TRANSFER_INT(port) ((port)->CNTRL &= (~SPI_CNTRL_IE_Msk))
N
N/**
N * @details    Clear the SPI unit transfer interrupt flag
N */
N#define _SPI_CLR_UNIT_TRANS_INT_FLAG(port) ((port)->CNTRL |= SPI_CNTRL_IF_Msk  )
N
N/**
N * @details    Get the SPI unit transfer interrupt flag
N */
N#define _SPI_GET_UNIT_TRANS_INT_FLAG(port) (((port)->CNTRL & SPI_CNTRL_IF_Msk)>>SPI_CNTRL_IF_Pos )
N
N/**
N * @details    Get the SPI Rx0 data
N */
N#define _SPI_GET_RX0_DATA(port) ((port)->RX[0])
N
N/**
N * @details    Get the SPI Rx1 data
N */
N#define _SPI_GET_RX1_DATA(port) ((port)->RX[1])
N
N/**
N * @details    Write data to the SPI Tx buffer0
N */
N#define _SPI_WRITE_TX_BUFFER0(port, x) ((port)->TX[0] = (x))
N
N/**
N * @details    Write data to the SPI Tx buffer1
N */
N#define _SPI_WRITE_TX_BUFFER1(port, x) ((port)->TX[1] = (x))
N
N/**
N * @details    Enable the SPI DIV-ONE function
N */
N#define _SPI_ENABLE_DIV_ONE(port) ((port)->CNTRL2 |= SPI_CNTRL2_DIV_ONE_Msk)
N
N/**
N * @details    Disable the SPI DIV-ONE function
N */
N#define _SPI_DISABLE_DIV_ONE(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_DIV_ONE_Msk))
N
N/**
N * @details    Enable the SPI 3-wire mode
N */
N#define _SPI_ENABLE_3WIRE_MODE(port) ((port)->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N * @details    Disable the 3-wire mode
N */
N#define _SPI_DISABLE_3WIRE_MODE(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_NOSLVSEL_Msk))
N
N/**
N * @details    Abort the SPI transfer when the 3-wire mode is enabled
N */
N#define _SPI_ABORT_3WIRE_TRANSFER(port) ((port)->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk)
N
N/**
N * @details    Enable the SPI 3-wire mode start interrupt
N */
N#define _SPI_ENABLE_3WIRE_START_INT(port) ((port)->CNTRL2 |= SPI_CNTRL2_SSTA_INTEN_Msk)
N
N/**
N * @details    Disable the SPI 3-wire mode start interrupt
N */
N#define _SPI_DISABLE_3WIRE_START_INT(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_SSTA_INTEN_Msk))
N
N/**
N * @details    Get the SPI 3-wire mode start interrupt flag
N */
N#define _SPI_GET_3WIRE_START_INT_FLAG(port) (((port)->CNTRL2 & SPI_CNTRL2_SLV_START_INTSTS_Msk)>>SPI_CNTRL2_SLV_START_INTSTS_Pos )
N
N/**
N * @details    Clear the SPI 3-wire mode start interrupt flag
N */
N#define _SPI_CLR_3WIRE_START_INT_FLAG(port) ((port)->CNTRL2 |= SPI_CNTRL2_SLV_START_INTSTS_Msk  )
N
N
N
N
N/**
N * @brief      Get SPI clock1 frequency (Hz).
N *
N * @param[in]  pSpiPort   Specify the SPI port.
N *
N * @return     SPI clock1 frequency.
N *
N * @details    This function calculates the clock rate of clock1 (SPI engine clock).
N *
N */
Nstatic __INLINE uint32_t SPI_GetClock1Freq(SPI_T * pSpiPort)
Xstatic __inline uint32_t SPI_GetClock1Freq(SPI_T * pSpiPort)
N{
N    return (SystemCoreClock>>1)/((pSpiPort->DIVIDER & 0xFFFF)+1);
N}
N
N/**
N * @brief      Get SPI clock2 frequency (Hz).
N *
N * @param[in]  pSpiPort   Specify the SPI port.
N *
N * @return     SPI clock2 frequency.
N *
N * @details    This function calculates the clock rate of clock2.
N *
N */
Nstatic __INLINE uint32_t SPI_GetClock2Freq(SPI_T * pSpiPort)
Xstatic __inline uint32_t SPI_GetClock2Freq(SPI_T * pSpiPort)
N{
N    return (SystemCoreClock>>1)/(((pSpiPort->DIVIDER & 0xFFFF0000)>>16)+1);
N}
N
N/**
N  * @} End of SPI Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif
N
L 6190 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "TIMER.h"
L 1 "..\..\LibM051Series\StdDriver\inc\TIMER.h" 1
N/**************************************************************************//**
N * @file     TIMER.h
N * @version  V2.1
N * $Revision: 6 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series Timer Controller and Watchdog Timer Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#include "M051Series.h"
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup TIMER_FUNC TIMER Device Function Interface
N  * @{
N  */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TCSR Constants Definitions                                                                              */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define TIMER_TCSR_CEN_ENABLE           0x40000000UL /*!< Enable Timer to start counting         */
N#define TIMER_TCSR_CEN_DISABLE          0x00000000UL /*!< Disable Timer to stop/suspend counting */
N#define TIMER_TCSR_IE_ENABLE            0x20000000UL /*!< Enable Timer Interrupt function  */
N#define TIMER_TCSR_IE_DISABLE           0x00000000UL /*!< Disable Timer Interrupt function */
N#define TIMER_TCSR_MODE_ONESHOT         0x00010000UL /*!< Specify Timer One-Shot mode and enable TDR            */
N#define TIMER_TCSR_MODE_PERIODIC        0x08010000UL /*!< Specify Timer Periodic mode and enable TDR            */
N#define TIMER_TCSR_MODE_TOGGLE          0x10010000UL /*!< Specify Timer Toggle mode and enable TDR              */
N#define TIMER_TCSR_MODE_CONTINUOUS      0x18010000UL /*!< Specify Timer Continuous Counting mode and enable TDR */
N#define TIMER_TCSR_CRST                 0x04000000UL /*!< Reset Timer          */
N#define TIMER_TCSR_CTB_ENABLE           0x01000000UL /*!< Enable Counter Mode  */
N#define TIMER_TCSR_CTB_DISABLE          0x00000000UL /*!< Disable Counter Mode */
N#define TIMER_TCSR_PRESCALE(x)          ((x)-1)      /*!< TCSR setting for prescale. 1 <= x <= 256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TEXCON Constants Definitions                                                                            */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define TIMER_TEXCON_TCDB_ENABLE        0x80UL /*!< Enable Timer Counter pin de-bounce  */
N#define TIMER_TEXCON_TCDB_DISABLE       0x00UL /*!< Disable Timer Counter pin de-bounce */
N#define TIMER_TEXCON_TEXDB_ENABLE       0x40UL /*!< Enable Timer Capture pin de-bounce  */
N#define TIMER_TEXCON_TEXDB_DISABLE      0x00UL /*!< Disable Timer Capture pin de-bounce */
N#define TIMER_TEXCON_TEXIEN_ENABLE      0x20UL /*!< Enable Timer Capture pin interrupt  */
N#define TIMER_TEXCON_TEXIEN_DISABLE     0x00UL /*!< Disable Timer Capture pin interrupt */
N#define TIMER_TEXCON_MODE_RESET_COUNT   0x10UL /*!< Transition on Timer Capture pin is using to reset the timer counter    */
N#define TIMER_TEXCON_MODE_CAP           0x00UL /*!< Transition on Timer Capture pin is using as the Timer Capture function */
N#define TIMER_TEXCON_TEXEN_ENABLE       0x08UL /*!< Enable Timer Capture pin function   */
N#define TIMER_TEXCON_TEXEN_DISABLE      0x00UL /*!< Disable Timer Capture pin function  */
N#define TIMER_TEXCON_TEX_EDGE_BOTH      0x04UL /*!< Capture pin will generate a detected signal both on 0 to 1 and 1 to 0 transition. */
N#define TIMER_TEXCON_TEX_EDGE_RISING    0x02UL /*!< Capture pin will generate a detected signal only on 0 to 1 transition.            */
N#define TIMER_TEXCON_TEX_EDGE_FALLING   0x00UL /*!< Capture pin will generate a detected signal only on 1 to 0 transition.            */
N#define TIMER_TEXCON_TX_PHASE_RISING    0x01UL /*!< Counter pin will generate a count when transition from 0 to 1 on Counter pin */
N#define TIMER_TEXCON_TX_PHASE_FALLING   0x00UL /*!< Counter pin will generate a count when transition from 1 to 0 on Counter pin */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TIMER Macro Definitions                                                                                 */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Predefined timer TCSR setting for enable periodic timer but disable interrupt. 1 <= x <= 256
N */
N#define TIMER_TCSR_INIT(x)              (TIMER_TCSR_MODE_PERIODIC | TIMER_TCSR_CEN_Msk | TIMER_TCSR_PRESCALE(x))
N
N
N/**
N * @details     Predefined timer TCSR setting for enable periodic timer and enable interrupt. 1 <= x <= 256
N */
N#define TIMER_TCSR_INIT_IE(x)           (TIMER_TCSR_MODE_PERIODIC | TIMER_TCSR_CEN_Msk | TIMER_TCSR_IE_Msk | TIMER_TCSR_PRESCALE(x))
N
N
N/**
N * @brief       Start Timer Counting
N *
N * @param[in]   TIMER       TIMER port. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N * @param[in]   tcsr        TCSR register settings of specified TIMER port.
N * @param[in]   presacle    Timer clock input will be divided by presacle).
N *
N * @return      None
N *
N * @details     To start Timer counting by TCSR settings.
N */
N#define _TIMER_START(TIMER, tcsr, presacle)     ((TIMER)->TCSR = ((tcsr) | TIMER_TCSR_PRESCALE(presacle) | TIMER_TCSR_CEN_ENABLE))    
N
N
N/**
N * @brief       Enable Timer Capture Function
N *
N * @param[in]   TIMER       TIMER port. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N * @param[in]   texcon      TEXCON register settings of specified TIMER port.
N *
N * @return      None
N *
N * @details     To enable Timer capture function to get current TDR or reset Timer counter when transition on external capture pin.
N */
N#define _TIMER_ENABLE_CAPTURE(TIMER, texcon)     ((TIMER)->TEXCON = ((texcon) | TIMER_TEXCON_TEXEN_ENABLE))    
N
N
N/**
N * @details     To reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_RESET(TIMER)                     ((TIMER)->TCSR = TIMER_TCSR_CRST)    
N
N
N/**
N * @details     Set Timer Compared Value for specified Timer channel. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_SET_CMP_VALUE(TIMER, value)      ((TIMER)->TCMPR = value)    
N
N
N/**
N * @details     Get Timer Compare Match Interrupt Flag. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_CMP_INT_FLAG(TIMER)          (((((TIMER)->TISR) & TIMER_TISR_TIF_Msk) == TIMER_TISR_TIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear Timer Compare Match Interrupt Flag to 0. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_CLEAR_CMP_INT_FLAG(TIMER)        ((TIMER)->TISR = TIMER_TISR_TIF_Msk)
N                                               
N
N/**
N * @details     Get Timer TDR value. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_TDR(TIMER)                   ((TIMER)->TDR)
N
N
N/**
N * @details     Get Timer Capture Data value. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_TCAP(TIMER)                   ((TIMER)->TCAP)
N
N
N/**
N * @details     Get Interrupt Flag for Capture pin. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_CAP_INT_FLAG(TIMER)          (((((TIMER)->TEXISR) & TIMER_TEXISR_TEXIF_Msk) == TIMER_TEXISR_TEXIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear Interrupt Flag to 0 for Capture pin. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_CLEAR_CAP_INT_FLAG(TIMER)        ((TIMER)->TEXISR = TIMER_TEXISR_TEXIF_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCR Constants Definitions                                                                              */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_WTCR_COMMON(x)          (WDT_WTCR_WTE_Msk | WDT_WTCR_WTIF_Msk | WDT_WTCR_WTR_Msk | ((x) << WDT_WTCR_WTIS_Pos))
N
N#define WDT_WTCR_WAKEUP_INT_2POW4   (WDT_WTCR_COMMON(0) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^04 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW6   (WDT_WTCR_COMMON(1) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^06 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW8   (WDT_WTCR_COMMON(2) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^08 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW10  (WDT_WTCR_COMMON(3) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^10 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW12  (WDT_WTCR_COMMON(4) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^12 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW14  (WDT_WTCR_COMMON(5) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^14 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW16  (WDT_WTCR_COMMON(6) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^16 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW18  (WDT_WTCR_COMMON(7) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^18 * WDT clock */
N
N#define WDT_WTCR_INT_2POW4          (WDT_WTCR_COMMON(0) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^04 * WDT clock */
N#define WDT_WTCR_INT_2POW6          (WDT_WTCR_COMMON(1) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^06 * WDT clock */
N#define WDT_WTCR_INT_2POW8          (WDT_WTCR_COMMON(2) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^08 * WDT clock */
N#define WDT_WTCR_INT_2POW10         (WDT_WTCR_COMMON(3) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^10 * WDT clock */
N#define WDT_WTCR_INT_2POW12         (WDT_WTCR_COMMON(4) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^12 * WDT clock */
N#define WDT_WTCR_INT_2POW14         (WDT_WTCR_COMMON(5) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^14 * WDT clock */
N#define WDT_WTCR_INT_2POW16         (WDT_WTCR_COMMON(6) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^16 * WDT clock */
N#define WDT_WTCR_INT_2POW18         (WDT_WTCR_COMMON(7) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^18 * WDT clock */
N
N#define WDT_WTCR_INT_RESET_2POW4    (WDT_WTCR_COMMON(0) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^04 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW6    (WDT_WTCR_COMMON(1) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^06 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW8    (WDT_WTCR_COMMON(2) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^08 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW10   (WDT_WTCR_COMMON(3) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^10 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW12   (WDT_WTCR_COMMON(4) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^12 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW14   (WDT_WTCR_COMMON(5) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^14 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW16   (WDT_WTCR_COMMON(6) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^16 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW18   (WDT_WTCR_COMMON(7) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^18 * WDT clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WDT Macro Definitions                                                                                   */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Get WDT Timeout Reset Flag
N */
N#define _WDT_GET_RESET_FLAG()               ((((WDT->WTCR) & WDT_WTCR_WTRE_Msk) == WDT_WTCR_WTRE_Msk)? 1:0)
N
N
N/**
N * @details     Clear WDT Timeout Reset Flag to 0
N */
N#define _WDT_CLEAR_RESET_FLAG()             (WDT->WTCR |= WDT_WTCR_WTRE_Msk)
N
N
N/**
N * @details     Get WDT Timeout Interrupt Flag
N */
N#define _WDT_GET_TIMEOUT_INT_FLAG()         ((((WDT->WTCR) & WDT_WTCR_WTIF_Msk) == WDT_WTCR_WTIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear WDT Timeout Interrupt Flag to 0
N */
N#define _WDT_CLEAR_TIMEOUT_INT_FLAG()       (WDT->WTCR |= WDT_WTCR_WTIF_Msk)
N
N
N/**
N * @details     Get WDT Timeout Wake-up Flag
N */
N#define _WDT_GET_TIMEOUT_WAKEUP_FLAG()      ((((WDT->WTCR) & WDT_WTCR_WTWKF_Msk) == WDT_WTCR_WTWKF_Msk)? 1:0)
N
N
N/**
N * @details     Clear WDT Timeout Wake-up Flag to 0
N */
N#define _WDT_CLEAR_TIMEOUT_WAKEUP_FLAG()    (WDT->WTCR |= WDT_WTCR_WTWKF_Msk)
N
N
N/**
N * @details     Enable WDT to start counting
N */
N#define _WDT_ENABLE_COUNTING()              (WDT->WTCR |= WDT_WTCR_WTE_Msk)
N
N
N/**
N * @details     Disable WDT to stop counting
N */
N#define _WDT_DISABLE_COUNTING()             (WDT->WTCR &= ~WDT_WTCR_WTE_Msk)
N
N
N/**
N * @details     Reset the contents of WDT
N */
N#define _WDT_RESET()                        (WDT->WTCR |= WDT_WTCR_WTR_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief       Get Timer Clock Source Frequency
N *
N * @param[in]   eTimerCH    E_TMR0 / E_TMR1 / E_TMR2 / E_TMR3
N *
N * @return      Timer clock frequency (Hz)
N *
N * @details     Get the specified Timer clock source frequency.
N */
Nstatic __INLINE uint32_t TIMER_GetClockFreq(uint32_t eTimerCH)
Xstatic __inline uint32_t TIMER_GetClockFreq(uint32_t eTimerCH)
N{
N    uint8_t u8TMRClkSrcSel;
N    uint32_t u32ClkSrcTbl[] = {__XTAL, 0, 0, 0, 0, __IRC10K, 0, __IRC22M};
X    uint32_t u32ClkSrcTbl[] = {(12000000UL), 0, 0, 0, 0, (10000UL), 0, (22118400UL)};
N        
N    u32ClkSrcTbl[2] = SystemCoreClock;
N
N    u8TMRClkSrcSel = (SYSCLK->CLKSEL1 >> (8+(eTimerCH*4))) & 0x7;
X    u8TMRClkSrcSel = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 >> (8+(eTimerCH*4))) & 0x7;
N
N    return u32ClkSrcTbl[u8TMRClkSrcSel]; 
N}
N
N
N/**
N * @brief       Calculate Timer Initial Value
N *
N * @param[in]   u32ClockValue   Input the Timer clock frequency (Hz)
N * @param[in]   u32TicksPerSec  Specify the ticks per second
N *
N * @return      Return 32 bits unsigned integer where \n
N *                  bits [ 0:23] - TCMP of Timer Compare Register, the range is 0 ~ 0xFFFFFF. \n
N *                  bits [24:31] - PRESCALE of Timer Control Register, the range is 0 ~ 0xFF.
N *
N * @details     Calculate the Timer Compare Value and pre-scale counter of Timer. \n
N *              The target Timer clock input is divided by (PRESCALE + 1).
N */
Nstatic __INLINE uint32_t TIMER_CalInitValue(uint32_t u32ClockFreq, uint32_t u32TicksPerSec)
Xstatic __inline uint32_t TIMER_CalInitValue(uint32_t u32ClockFreq, uint32_t u32TicksPerSec)
N{
N    uint32_t u32Prescale;
N    uint32_t u32FinalTCMPR;
N
N    for (u32Prescale=1; u32Prescale<256; u32Prescale++)
N    {
N        u32FinalTCMPR = u32ClockFreq / (u32TicksPerSec*u32Prescale);
N
N        /* The TCMPR value must > 1 */
N        if ((u32FinalTCMPR > 1) && (u32FinalTCMPR < 0x1000000))
N            return (((u32Prescale-1) << 24) | u32FinalTCMPR);
N    }
N    
N    return (uint32_t)-1;
N}
N
N/**
N  * @} End of TIMER Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif  // __TIMER_H__ 
L 6191 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "UART.h"
L 1 "..\..\LibM051Series\StdDriver\inc\UART.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V2.00
N * $Revision: 5 $
N * $Date: 12/08/10 3:12p $
N * @brief    M051 Series UART Interface Controller Driver Header File
N *
N * @note                                                                              
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N#include "M051Series.h"
N
N
N/** @addtogroup M051_FUNC M051 Function Interface
N  * @{
N  */
N
N/** @addtogroup UART_FUNC UART Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE      (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FCR_RFITL_4BYTES     (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FCR_RFITL_8BYTES     (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FCR_RFITL_14BYTES    (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE      (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 bit */
N#define UART_FCR_RTS_TRI_LEV_4BYTES     (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bits */
N#define UART_FCR_RTS_TRI_LEV_8BYTES     (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bits */
N#define UART_FCR_RTS_TRI_LEV_14BYTES    (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5     (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6     (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7     (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8     (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Tigger   */
N#define UART_RTS_IS_LOW_LEV_TRG  (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Tigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART  (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN   (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set LIN Funciton             */
N#define UART_FUNC_SEL_IrDA  (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485 (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* BAUD constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0                                 (0)
N#define UART_BAUD_MODE2                                 (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk)
N
N
N/**
N * @brief      Compute Baud Rate Divider Settings by mode 0
N *
N * @param[in]  u32SrcFreq      UART clock source(UART_S) divides by UART divider(UART_N)
N * @param[in]  u32BaudRate     Target bitrate (Hz)
N *    
N * @return     None
N *    
N * @details    The function is used to get baud-rate divider settings by mode 0  based on your settings.\n
N *    
N *             Example: UART clock source from PLL(48MHz) and UART clock divider is set 2.\n 
N *                      If desired baudrate is 115200, you can call UART_BAUD_DIV_MODE2(24000000,115200);
N *                           
N */
N#define UART_BAUD_DIV_MODE0(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-2)
N
N/**
N * @brief      Compute Baud Rate Divider Settings by mode 2
N *
N * @param[in]  u32SrcFreq      UART clock source(UART_S) was divided by UART divider(UART_N)
N * @param[in]  u32BaudRate     Target bitrate (Hz)
N *    
N * @return     None
N *    
N * @details    The function is used to get baud rate divider settings by mode 2 based on your settings.\n
N *    
N *             Example: UART clock source from PLL(48MHz) and UART clock divider is set 2.\n 
N *                      If desired baudrate is 115200, you can call UART_BAUD_DIV_MODE2(24000000,115200);
N *                           
N */
N
N#define UART_BAUD_DIV_MODE2(u32SrcFreq, u32BaudRate)    (((u32SrcFreq) / u32BaudRate)-2)     
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Data Transmit/Receive                                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Send one data byte from specify uart port
N *
N * @param[in]  UART         Structure pointer of UART Channel selected, should be:
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u8Data       Data byte to transmit 
N *                          
N * @return     None
N *
N * @details    The function is used to send UART data.\n
N *             Example: _UART_SENDBYTE(UART0,0x55)
N */
N#define _UART_SENDBYTE(UART,u8Data)   ((UART)->THR = (u8Data))
N
N/**
N * @brief      Receive one data byte from specify uart port
N *
N * @param[in]  UART         Structure pointer of UART Channel selected, should be: 
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @return     The oldest data byte in RX FIFO 
N *
N * @details    The function is used to get one data byte from RX FIFO of specified UART port.\n
N *             Example: _UART_RECEIVEBYTE(UART0,u8Data)
N */
N#define _UART_RECEIVEBYTE(UART,u8Data)  ((u8Data) = (UART)->RBR)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Baud Rate Relative                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Get UART Clock Source Freq. (Hz)
N *
N * @param[in]  None  
N *
N * @return     UART Clock Source Freq.
N *
N * @details    The function will read UART_S bit field in CLKSEL1 register to determine UART clock source freq.\n
N *             Before calling the function, please use SystemCoreClockUpdate to update system clock freq.
N */
N
Nstatic __INLINE uint32_t UART_GetClockFreq()
Xstatic __inline uint32_t UART_GetClockFreq()
N{
N    uint8_t u8UartClkSrcSel;
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};    
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};    
N    u32ClkTbl[1] = PllClock;
N    u8UartClkSrcSel = (SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_UART_S_Msk) >> SYSCLK_CLKSEL1_UART_S_Pos;
X    u8UartClkSrcSel = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (3ul << 24)) >> 24;
N    return u32ClkTbl[u8UartClkSrcSel];
N}
N
N/**
N * @brief      Get UART Clock Divider. (Hz)
N *
N * @param[in]  None  
N *
N * @return     UART Clock Divider.
N *
N * @details    The function will read UART_N bit field in CLKDIV register to determine current UART clock divider.
N *             
N */
N
Nstatic __INLINE uint32_t UART_GetClockDivider()
Xstatic __inline uint32_t UART_GetClockDivider()
N{
N    return ((SYSCLK->CLKDIV & SYSCLK_CLKDIV_UART_N_Msk) >> SYSCLK_CLKDIV_UART_N_Pos) + 1;
X    return ((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKDIV & (0xFul << 8)) >> 8) + 1;
N}
N
N
N/**
N * @brief      Using Baud Rate Equation Mode 0 to get divisor.     (DIV_X_EN=0, DIV_X_ONE=0) 
N *
N * @param[in]  u32BaudRate  Baud rate setting for UART   
N *
N * @return     UART baud rate divisor.
N *
N * @details    The function will get UART baud rate divisor by equation. (UART_CLK / [16 * (A+2)])
N *             
N */
Nstatic __INLINE uint32_t UART_GetDivisor_ByMode0(uint32_t u32BaudRate)
Xstatic __inline uint32_t UART_GetDivisor_ByMode0(uint32_t u32BaudRate)
N{
N    return ((((UART_GetClockFreq()/UART_GetClockDivider()) / u32BaudRate + 1) >> 4) -2) ;
N}
N
N
N/**
N * @brief      Using Baud Rate Equation Mode 1 to get divisor. (DIV_X_EN=1, DIV_X_ONE=0) 
N *
N * @param[in]  u32BaudRate  Baud rate setting for UART   
N * @param[in]  u8Divider_X  Divider X
N *
N * @return     UART baud rate divisor.
N *
N * @details    The function will get UART baud rate divisor by equation. (UART_CLK / [(B+1) * (A+2)] )
N *             
N */                      
Nstatic __INLINE uint32_t UART_GetDivisor_ByMode1(uint32_t u32BaudRate,uint8_t u8Divider_X)
Xstatic __inline uint32_t UART_GetDivisor_ByMode1(uint32_t u32BaudRate,uint8_t u8Divider_X)
N{
N    return ((((UART_GetClockFreq()/UART_GetClockDivider()) / u32BaudRate + 1) / u8Divider_X) -2) ;
N}                                        
N
N/**
N * @brief      Using Baud Rate Equation Mode 2 to get divisor.(DIV_X_EN=1, DIV_X_ONE=1) 
N *
N * @param[in]  u32BaudRate  Baud rate setting for UART   
N *
N * @return     UART baud rate divisor.
N *
N * @details    The function will get UART baud rate divisor by equation. (UART_CLK / 1 * (A+2)] )
N *             
N */
Nstatic __INLINE uint32_t UART_GetDivisor_ByMode2(uint32_t u32BaudRate)
Xstatic __inline uint32_t UART_GetDivisor_ByMode2(uint32_t u32BaudRate)
N{
N    return (((UART_GetClockFreq()/UART_GetClockDivider() * 2) / u32BaudRate + 1) >> 1);
N}
N
N/**
N * @brief      Set UART Baud Rate
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u32BaudRate  Baud rate setting for UART 
N *                          - Bit per sec. : ex.115200
N * @return     None
N *
N * @details    The function uses mode 2 (DIV_X_EN=1, DIV_X_ONE=1) to set baud rate.\n
N *             Example: UART_SetBaudRate(UART0, 115200)
N */
Nstatic __INLINE void UART_SetBaudRate(UART_T *UART, uint32_t u32BaudRate)
Xstatic __inline void UART_SetBaudRate(UART_T *UART, uint32_t u32BaudRate)
N{
N    UART->BAUD = UART_BAUD_MODE2 | UART_GetDivisor_ByMode2(u32BaudRate); 
X    UART->BAUD = ((1ul << 29) | (1ul << 28)) | UART_GetDivisor_ByMode2(u32BaudRate); 
N}
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* FORMAT CONTROL                                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Set UART line control 
N *
N * @param[in]  UART         Structure pointer of UART Channel selected,should be:  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u32PortSettings  Line control value: Use "|" to combine your settings
N *                          - Word Length Select : eg. UART_WORD_LEN_5 
N *                          - Parity Bit         : eg. UART_PARITY_NONE
N *                          - Stop Bit           : eg. UART_STOPBIT_1
N * @return     None
N *
N * @details    The function is used to set UART data format (Word Length Select /Parity Bit/Stop Bit).\n
N *             Example: _UART_SET_DATA_FORMAT(UART0, UART_WORD_LEN_5 | UART_PARITY_NONE | UART_STOPBIT_1)
N */
N#define _UART_SET_DATA_FORMAT(UART, u32PortSettings)  ((UART)->LCR = (u32PortSettings))
N
N
N
N/**
N * @brief      Set UART transmit delay time 
N *
N * @param[in]  UART         Structure pointer of UART Channel selected,should be:  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  DelayTime  N-th uart bit-time between each transmission
N *                                                                
N * @return     None
N *
N * @details    The function is used to set N-th uart bit-time between each transmission. \n
N *             Example: _UART_SET_TX_DELAYTIME(UART0, 10)
N */
N
N#define _UART_SET_TX_DELAYTIME(UART,DelayTime)    ((UART)->TOR = ((UART)->TOR &~UART_TOR_DLY_Msk)|((DelayTime)<<UART_TOR_DLY_Pos))  
N
N
N
N/**
N * @brief      Set time-out counter
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u32Count     TimeOutCounter:  0~255
N *
N * @return     None
N *                                                           
N * @details    The function is used to access TOR[7:0] to control timeout counter.\n
N *             When there is un-read data in rx-fifo and IER[11] is set, the counter will start up-count.\n
N *             Until the counter each the value, the time-out event will happened.\n
N *             Example: UART_SetTimeOutCounter(UART0, 128)
N *
N * @note       Per count is according to bitrate settings.
N */
N                               
Nstatic __INLINE void UART_SetTimeOutCounter(UART_T* UART,uint32_t u32Count)
Xstatic __inline void UART_SetTimeOutCounter(UART_T* UART,uint32_t u32Count)
N{
N    (UART)->TOR = ((UART)->TOR & ~UART_TOR_TOIC_Msk)| (u32Count);
X    (UART)->TOR = ((UART)->TOR & ~(0xFFul << 0))| (u32Count);
N    (UART)->IER |= UART_IER_TIME_OUT_EN_Msk;
X    (UART)->IER |= (1ul << 11);
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* FIFO Control                                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Check specified uart port transmission is over. 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @retval     0 = The transmission is not over. 
N * @retval     1 = The transmission is over. 
N *
N * @details    The function is used to read FSR[28] to check the TX_FIFO and TX_Shift_Reigster is empty.\n
N *             Example: _UART_IS_TX_EMPTY(UART0)
N */
N
N#define _UART_IS_TX_EMPTY(UART)    (((UART)->FSR & UART_FSR_TE_FLAG_Msk)>>UART_FSR_TE_FLAG_Pos) 
N
N
N/**
N * @brief      Wait specified uart port transmission is over 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @return     None 
N *
N * @details    The function is used to polling FSR[28] and waiting the TX_FIFO and 
N *             TX_Shift_Reigster is empty. Wait FSR[28] bit is set to exit the while loop.\n
N *             Example: _UART_WAIT_TX_EMPTY(UART0)
N */
N#define _UART_WAIT_TX_EMPTY(UART)        while(!((((UART)->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N
N
N                                              
N/**
N * @brief      Check RDA_IF is set or not
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     0 = the number of bytes in the RX FIFO is less than the RFITL  
N * @retval     1 = The number of bytes in the RX FIFO equals or larger than RFITL
N *
N * @details    The function is used to read RDA_IF to check the number of bytes in the RX FIFO.
N *             
N *             Example: _UART_IS_RX_READY(UART0)
N */
N
N#define _UART_IS_RX_READY(UART)    (((UART)->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N * @brief      Check there is un-read data in RX FIFO
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     The number of N data bytes in RX FIFO.
N *
N * @details    The function is used to read FSR[13:8] RX FIFO POINTER to check 
N *             there is un-read data int RX_FIFO.\n
N *             Example: _UART_GET_RX_POINTER(UART0)
N */
N#define _UART_GET_RX_POINTER(UART)    (((UART)->FSR & UART_FSR_RX_POINTER_Msk) >> UART_FSR_RX_POINTER_Pos)
N
N
N/**
N * @brief      Check there is un-transmited data in TX FIFO
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     The number of N data bytes in TX FIFO.
N *
N * @details    The function is used to read FSR[21:16] TX FIFO POINTER to check 
N *             there is un-transmited data int TX_FIFO.\n
N *             Example: _UART_GET_TX_POINTER(UART0)
N */
N#define _UART_GET_TX_POINTER(UART)    (((UART)->FSR & UART_FSR_TX_POINTER_Msk) >> UARTFSR_TX_POINTER_Pos)
N
N
N/**
N * @brief      Check TX FIFO is full or not 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     1 = TX FIFO is full
N * @retval     0 = TX FIFO is not full
N *
N * @details    The function is used to read FSR[23] to check tx fifo is full or not.
N *             If writing data to tx fifo when it is full,buffer error will happen.
N *             Example: _UART_IS_TX_FULL(UART0)
N */
N#define _UART_IS_TX_FULL(UART)   (((UART)->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N * @brief      Check RX FIFO is full or not 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     1 = RX FIFO is full
N * @retval     0 = RX FIFO is not full
N *
N * @details    The function is used to read FSR[15] to check rx fifo is full or not.
N *             If receving a new data to rx fifo when it is full,buffer error will happen.
N *             Example: _UART_IS_RX_FULL(UART0)
N */
N
N#define _UART_IS_RX_FULL(UART)   (((UART)->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N * @brief      Reset TX/RX FIFO
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  uPara      Reset FIFO Select  (Uses "OR" to add your settings)
N *                          - UART_FCR_TFR_Msk : TX FIFO 
N *                          - UART_FCR_RFR_Msk : RX FIFO 
N * @return     None
N *
N * @details    The function is used to write FCR[2:1] to reset TX or RX FIFO.\n
N *             Example: _UART_FLUSH_FIFO(UART0,UART_TX_FIFO|UART_RX_FIFO)
N *
N * @note       After user call the function, data in tx or rx fifo in specified UART port will be cleared.
N */
N
N#define _UART_FLUSH_FIFO(UART,uPara)    ((UART)->FCR |= (uPara))
N
N
N/**
N * @brief      Set Rx trigger level
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eLevel       Rx trigger level
N *                          - UART_FCR_RFITL_1BYTE   : RDA Trigger Level is 1 byte   
N *                          - UART_FCR_RFITL_4BYTES  : RDA Trigger Level is 4 byte  
N *                          - UART_FCR_RFITL_8BYTES  : RDA Trigger Level is 8 byte 
N *                          - UART_FCR_RFITL_14BYTES : RDA Trigger Level is 14 byte 
N * @return     None
N *                                                           
N * @details    The function is used to access FCR[7:4] to control rx trigger level.\n
N *             Example: _UART_SET_RX_TRG_LEV(UART0, UART_RX_TRG_LEV_8)
N *
N * @note       Rx trigger level will effort RDA_IF and RDA_INT.
N */
N#define _UART_SET_RX_TRG_LEV(UART,eLevel)    ((UART)->FCR = ((UART)->FCR & ~UART_FCR_RFITL_Msk)| (eLevel))
N
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Interrupt Control                                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Enable specified interrupt
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eIntTypeSel  Interrupt type select
N *                          - UART_IER_LIN_IEN_Msk     : LIN Rx break interrupt  
N *                          - UART_IER_BUF_ERR_IEN_Msk : Buffur Error interrupt   
N *                          - UART_IER_RTO_IEN_Msk     : Rx time-out interrupt       
N *                          - UART_IER_MOS_IEN_Msk     : Modem interrupt           
N *                          - UART_IER_RLS_IEN_Msk     : Rx Line status interrupt                              
N *                          - UART_IER_THRE_IEN_Msk    : Tx empty interrupt          
N *                          - UART_IER_RDA_IEN_Msk     : Rx ready interrupt           
N *
N * @return     None
N *                                                           
N * @details    The function is used to enable specified UART interrupt.\n
N *             Example: _UART_ENABLE_INT(UART0,(eDRVUART_RDA_INT | eDRVUART_RLS_INT)
N *             
N * @note       When enable eDRVUART_THRE_INT interrupt source, the interrup will happen continouly if
N *             TX_FIFO is empty. Remind you that be careful to use it.\n  
N *             Please reference TRM to get more information.
N *
N */
N
N#define _UART_ENABLE_INT(UART,eIntTypeSel)    ((UART)->IER |= (eIntTypeSel))
N
N
N/**
N * @brief      Disable specified interrupt  
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eIntTypeSel  Interrupt type select
N *                          - UART_IER_LIN_IEN_Msk     : LIN Rx break interrupt  
N *                          - UART_IER_BUF_ERR_IEN_Msk : Buffur Error interrupt   
N *                          - UART_IER_RTO_IEN_Msk     : Rx time-out interrupt       
N *                          - UART_IER_MOS_IEN_Msk     : Modem interrupt           
N *                          - UART_IER_RLS_IEN_Msk     : Rx Line status interrupt                              
N *                          - UART_IER_THRE_IEN_Msk    : Tx empty interrupt          
N *                          - UART_IER_RDA_IEN_Msk     : Rx ready interrupt           
N * @return     None
N *                                                           
N * @details    The function is used to disable UART specified interrupt.\n
N *             Example: _UART_DISABLE_INT(UART0,(UART_RDA_INT | UART_RLS_INT)
N */
N#define _UART_DISABLE_INT(UART,eIntSel)    ((UART)->IER &= ~ (eIntSel))
N
N
N/**
N * @brief      Get specified interrupt flag/status
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eIntTypeFlag  Interrupt Type Flag,should be
N *                          - UART_LIN_INT_FLAG      : LIN Rx break interrupt flag    
N *                          - UART_BUFERR_INT_FLAG   : Buffur Error interrupt flag    
N *                          - UART_TOUT_INT_FLAG     : Rx time-out interrupt flag     
N *                          - UART_MOS_INT_FLAG      : Modem interrupt flag           
N *                          - UART_RLS_INT_FLAG      : Rx Line status interrupt flag 
N *                          - UART_THRE_INT_FLAG     : Tx empty interrupt flag        
N *                          - UART_RDA_INT_FLAG      : Rx ready interrupt flag     
N *
N * @retval     0 = The specified interrupt is not happened. 
N * @retval     1 = The specified interrupt is happened.
N *                                                           
N * @details    The function is used to read ISR[7:0] to get interrupt status.\n
N *             Example: _UART_GET_INT_FLAG(UART0,UART_RLS_INT)
N *
N */                                                                                      
N#define _UART_GET_INT_FLAG(UART,eIntTypeFlag) (((UART)->ISR & (eIntTypeFlag))?1:0)
N
N
N
N/**
N * @brief      Clear RLS interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access PEF/FEF/BIF BIT to clear RLS interrupt flag.\n
N *             Example: _UART_CLEAR_RLS_INT_FLAG(UART0)
N *
N */  
N#define _UART_CLEAR_RLS_INT_FLAG(UART)  ((UART)->FSR |= (UART_FSR_PEF_Msk|UART_FSR_FEF_Msk|UART_FSR_BIF_Msk))
N
N
N /**
N * @brief      Clear Modem interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access DCTSF to clear Modem interrupt flag.\n
N *             Example: _UART_CLEAR_MODEM_INT_FLAG(UART0)
N *
N */  
N#define _UART_CLEAR_MODEM_INT_FLAG(UART)  ((UART)->MSR |= UART_MSR_DCTSF_Msk)
N
N /**
N * @brief      Clear LIN Rx break interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access LIN Rx break interrupt flag
N *             to clear Modem interrupt flag.\n
N *             Example: _UART_CLEAR_LIN_RXBREAK_INT_FLAG(UART0)
N */ 
N#define _UART_CLEAR_LIN_RXBREAK_INT_FLAG(UART)   ((UART)->ISR |= UART_ISR_LIN_RX_BREAK_IF_Msk)
N
N /**
N * @brief      Clear buffur error interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access RX_OVER_IF and TX_OVER_IF to clear buffur error interrupt flag.\n
N *             Example: _UART_CLEAR_BUFERR_INT_FLAG(UART0)
N *
N */
N#define _UART_CLEAR_BUFERR_INT_FLAG(UART)  ((UART)->FSR |= UART_FSR_RX_OVER_IF_Msk | UART_FSR_TX_OVER_IF_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Flow Control                                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Set RTS Trigger Level
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eActLevel    RTS Active Level  
N *                          - UART_RTS_IS_HIGH_LEV_TRG : High Level trigger(Default)  
N *                          - UART_RTS_IS_LOW_LEV_TRG  : Low Level trigger 
N *
N * @param[in]  eTRGLevel    RTS Trigger Level Select
N *                          - UART_FCR_RTS_TRI_LEV_1BYTE   : RTS Trigger Level is 1 byte 
N *                          - UART_FCR_RTS_TRI_LEV_4BYTES  : RTS Trigger Level is 4 bytes 
N *                          - UART_FCR_RTS_TRI_LEV_8BYTES  : RTS Trigger Level is 8 bytes 
N *                          - UART_FCR_RTS_TRI_LEV_14BYTES : RTS Trigger Level is 14 bytes
N *
N * @return     None                                                            
N *                                                           
N * @details    The function is used to set RTS trigger level 1,4,8,14 bytes. It is used to autoflow control.\n
N *             Example: UART_SetRTS_TrgLev(UART0,UART_RTS_IS_HIGH_LEV_TRG,UART_RTS_TRG_LEV_1)
N *
N * @details    Default State: RTS is high level active. 
N */  
N                         
N__INLINE void UART_SetRTS_TrgLev(UART_T* UART,uint32_t eActLevel,uint32_t eTRG_Level)
X__inline void UART_SetRTS_TrgLev(UART_T* UART,uint32_t eActLevel,uint32_t eTRG_Level)
N{
N    (UART)->MCR = ((UART)->MCR & ~UART_MCR_LEV_RTS_Msk     | (eActLevel ));
X    (UART)->MCR = ((UART)->MCR & ~(1ul << 9)     | (eActLevel ));
N    (UART)->FCR = ((UART)->FCR & ~UART_FCR_RTS_TRI_LEV_Msk | (eTRG_Level));
X    (UART)->FCR = ((UART)->FCR & ~(0xFul << 16) | (eTRG_Level));
N}
N
N/**
N * @brief      Enable RTS/CTS Auto Flow Control
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  eFlowCtl     Flow Control Select
N *                          - UART_IER_AUTO_RTS_EN_Msk : RTS Auto Flow Control 
N *                          - UART_IER_AUTO_CTS_EN_Msk : CTS Auto Flow Control 
N * @return     None
N *                                                           
N * @details    The function is used to set AutoFlow Control RTS/CTS function.\n
N *             Example: _UART_ENABLE_AUTOFLOW(UART0,UART_AUTO_RTS)
N *
N */  
N#define _UART_ENABLE_AUTOFLOW(UART,eFlowCtl)     ((UART)->IER |= (eFlowCtl))
N
N
N/**
N * @brief      Disable RTS/CTS Auto Flow Control
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  eFlowCtl     Flow Control Select
N *                          - UART_IER_AUTO_RTS_EN_Msk : RTS Auto Flow Control 
N *                          - UART_IER_AUTO_CTS_EN_Msk : CTS Auto Flow Control 
N * @return     None
N *                                                           
N * @details    The function is used to disable AutoFlow Control RTS/CTS function.\n
N *             Example: _UART_DISABLE_AUTOFLOW(UART0,UART_AUTO_RTS)
N *
N */    
N#define _UART_DISABLE_AUTOFLOW(UART,eFlowCtl)   ((UART)->IER &= ~(eFlowCtl))
N
N
N
N/**
N * @brief      Get RTS Pin value
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @retval     1 = RTS pin value is HIGH
N * @retval     0 = RTS pin value is LOW
N *                                                           
N * @details    The function is used to get RTS pin value.
N *             Example: _UART_GET_RTSPIN(UART0)
N *
N */
N#define _UART_GET_RTSPIN(UART)   (((UART)->MCR & UART_MCR_RTS_ST_Msk)>> UART_MCR_RTS_ST_Pos)
N
N/**
N * @brief      Get CTS Pin value
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @retval     1 = CTS pin value is HIGH
N * @retval     0 = CTS pin value is LOW
N *                                                           
N * @details    The function is used to get CTS pin value.
N *             Example: _UART_GET_CTSPIN(UART0)
N *
N */
N#define _UART_GET_CTSPIN(UART)   (((UART)->MSR & UART_MSR_CTS_ST_Msk)>> UART_MSR_CTS_ST_Pos)
N
N
N/**
N * @brief      Get LEV_RTS bit settings
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @retval     1 = LEV_RTS bit is set
N * @retval     0 = LEV_RTS bit is clear
N *                                                           
N * @details    The function is used to get LEV_RTS bit settings.
N *             Example: _UART_GET_LEVRTS(UART0)
N *
N */
N#define _UART_GET_LEVRTS(UART)   (((UART)->MCR & UART_MCR_LEV_RTS_Msk)>> UART_MCR_LEV_RTS_Pos)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function Switch                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Switch Function 
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  eFuncSel     Function Select  
N *                          - FUNC_UART : UART function 
N *                          - FUNC_IrDA : IrDA function
N *                          - FUNC_RS485: RS485 function 
N *                          - FUNC_LIN  : LIN function                                    
N.* @return     None
N * @details    The function is used to uart function to Uart,IrDA,RS485 or LIN.\n
N *             Example: _UART_SEL_FUNC(UART_PORT0,FUNC_IrDA)
N *
N */  
N
N#define _UART_SEL_FUNC(UART,eFuncSel)   ((UART)->FUNSEL = (eFuncSel))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* IrDA Function                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Initialize IrDA TX configuration
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  bIsInvTx     Invert Tx signal or not   
N *                          - TRUE  : Invert tx signal     
N *                          - FALSE : No invert tx signal  
N *
N * @return     None
N *                                                           
N * @details    The function is used to intialize IrDA TX. It wll switch IrDA mode and 
N *             configure invert tx signal or nor.\n                                              
N *             Example: _UART_SET_IrDA_TXMODE(UART0,FALSE)
N *
N */  
N
N#define _UART_SET_IrDA_TXMODE(UART,bIsInvTx)    ((UART)->IRCR = UART_IRCR_TX_SELECT_Msk|((bIsInvTx)<<UART_IRCR_INV_TX_Pos))
N
N
N/**
N * @brief      Initialize IrDA RX configuration
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  bIsInvRx     Invert Rx signal or not
N *                          - TRUE  : Invert rx signal     
N *                          - FALSE : No invert rx signal  
N * @return     None
N *                                                           
N * @details    The function is used to intialize IrDA RX. It wll switch IrDA mode and 
N *             configure invert rx signal or nor.\n                                              
N *             Example: _UART_SET_IrDA_RXMODE(UART_PORT0,FALSE)
N *
N */  
N
N#define _UART_SET_IrDA_RXMODE(UART,bIsInvRx)    ((UART)->IRCR = (bIsInvRx)<<UART_IRCR_INV_RX_Pos)
N
N
N// /*---------------------------------------------------------------------------------------------------------*/
N// /* RS485 Function                                                                                          */
N// /*---------------------------------------------------------------------------------------------------------*/
N// /**
N//  * @brief      Initialize RS485 configuration
N//  *
N//  * @param[in]  UART         Structure pointer of UART Channel
N//  *                          - UART0 : UART Channel 0
N//  *                          - UART1 : UART Channel 1
N//  * @param[in]  u8Mode       Operation Mode : RS485 operation. 
N//  *                          - UART_RS485_AUD : Set Auto Direction Mode
N//  *                          - UART_RS485_AAD : Set RS485 Auto Address Detection Operation Mode
N//  *                          - UART_RS485_NMM : Set RS485 Normal Multi-drop Operation Mode
N//  *
N//  * @param[in]  u8Para       A parameter is valid if operation mode is UART_RS485_AAD, u8Para will be accress settings.
N//  *
N//  * @return     None
N//  *                                                           
N//  * @details    The function is used to intialize RS485. It wll set operation mode and access\n
N//  *             Example: UART_RS485Init(UART0,UART_RS485_AAD|UART_RS485_AUD,0xC0)
N//  *
N//  */                                                                                      
N
N// __INLINE void UART_RS485Init(UART_T* UART,uint32_t u32Mode,uint32_t u32Para)
N// {
N//     (UART)->MCR &= ~UART_MCR_LEV_RTS_Msk;
N
N//     (UART)->ALT_CSR  =  (u32Mode)| (((u32Mode)&UART_ALT_CSR_RS485_AAD_Msk)?(((u32Para)<<UART_ALT_CSR_ADDR_MATCH_Pos)|UART_ALT_CSR_RS485_ADD_EN_Msk):0);
N// }
N
N// // New add @ 2012.05.31
N// ////////////////////////////////////////////////////////////////
N// __INLINE void UART_RS485_AADInit(UART_T* UART,uint32_t u32AddrMatch)
N// {
N//     //RX_DIS do not care 
N//     
N//     (UART)->ALT_CSR  =  UART_ALT_CSR_RS485_AAD_Msk | ((u32AddrMatch)<< UART_ALT_CSR_ADDR_MATCH_Pos)  ;
N// }
N
N// __INLINE void UART_RS485_NMMMInit(UART_T* UART,uint32_t u32Para)
N// {
N//     (UART)->FCR |= UART_FCR_RX_DIS_Msk;
N
N//     (UART)->ALT_CSR  =  UART_ALT_CSR_RS485_NMM_Msk   ;
N// }
N
N
N/**
N * @brief      Enable Rx receive function in RS485 mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to set Rx disable function.\n
N *             Example: _UART_RS485_SET_RXDISABLE(UART0)
N *
N */                                                                                      
N#define _UART_RS485_SET_RXDISABLE(UART)    ((UART)->FCR|= UART_FCR_RX_DIS_Msk)
N
N
N/**
N * @brief      Disable Rx receive function in RS485 mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to Clear Rx disable function.\n
N *             Example: _UART_RS485_CLEAR_RXDISABLE(UART0)
N *
N */                                                                                      
N#define _UART_RS485_CLEAR_RXDISABLE(UART)   ((UART)->FCR&= ~UART_FCR_RX_DIS_Msk) 
N
N
N/**
N * @brief      Enable or Disable Rx receive function in RS485 mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  bIsEnable    Control RX_DISABLE function 
N *                          - TRUE : Enable Rx disable receive function    
N *                          - FALSE : Disable Rx disable receive function 
N * @return     None
N *                                                           
N * @details    The function is used to control Rx disable function.\n
N *             Example: _UART_RS485_RXDISABLE(UART0,TRUE)
N *
N */                                                                                      
N
N#define _UART_RS485_RXDISABLE(UART,bIsEnable)  (bIsEnable)?_UART_RS485_SET_RXDISABLE((UART)):_UART_RS485_CLEAR_RXDISABLE((UART))
N
N
N/**
N * @brief      Clear RS-485 Address Byte Detection Flag
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to write RS485_ADD_DETF_Msk bit is '1' to this bit
N *             Example: _UART_RS485_CLEAR_ADD_DETF(UART0)
N *
N */                                                                                      
N
N#define _UART_RS485_CLEAR_ADD_DETF(UART)   ((UART)->FSR  |= UART_FSR_RS485_ADD_DETF_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* LIN Function                                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Set LIN master mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  BreakLength  Break Length Setting: 
N *                          - 0~15
N * @return     None
N *                                                           
N * @details    The function is used to control UART to be LIN master.\n
N *             Before sending header field,please remember to enable the function.\n
N *             After sending a header to bus,LIN_TX_EN is cleared automatically.\n
N *             Example: _UART_SET_LIN_TXMODE(UART0,12)
N *
N */                                                                                      
N#define _UART_SET_LIN_TXMODE(UART,BreakLength) ((UART)->ALT_CSR = (BreakLength) | UART_ALT_CSR_LIN_TX_EN_Msk)
N
N/**
N * @brief      Set LIN slave mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  BreakLength  Break Length Setting: 
N *                          - 0~15
N * @return     None
N *                                                           
N * @details    The function is used to control UART to be LIN slave.\n 
N *             Example: _UART_SET_LIN_RXMODE(UART0,12)
N *
N */                                                                                      
N
N#define _UART_SET_LIN_RXMODE(UART,BreakLength) ((UART)->ALT_CSR = (BreakLength) | UART_ALT_CSR_LIN_RX_EN_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART Clock Control                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/                                                                                     
N/**
N * @brief      Enable UART APB Clock 
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to access APBCLK to enable UART APB Clock.
N *             Before using UART, please call the function firstly.\n
N *             Example: _UART_ENABLE_CLOCK(UART0)
N *
N */ 
N#define _UART_ENABLE_CLOCK(UART)   (SYSCLK->APBCLK  |= ( 1<< (SYSCLK_APBCLK_UART0_EN_Pos + (((UART)==(UART0))?0:1))))
N  
N/**
N * @brief      Disable UART APB Clock 
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to access APBCLK to disable UART APB Clock.\n
N *             Example: _UART_DISABLE_CLOCK(UART0)
N *
N */ 
N#define _UART_DISABLE_CLOCK(UART)   (SYSCLK->APBCLK &=~((1<< (SYSCLK_APBCLK_UART0_EN_Pos + (((UART)==(UART0))?0:1)))))
N
N
N/**
N * @brief      Reset UART IP
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to access IPRSTC2 to reset UART IP.\n
N *             Example: UART_ResetIP(UART0)
N *
N */ 
N__INLINE void UART_ResetIP(UART_T* UART)
X__inline void UART_ResetIP(UART_T* UART)
N{
N    SYS->IPRSTC2 |= 1<< (SYS_IPRSTC2_UART0_RST_Pos+ ((UART)==UART0)?0:1) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |= 1<< (16+ ((UART)==((UART_T *) ((( uint32_t)0x40000000) + 0x50000)))?0:1) ;
N    SYS->IPRSTC2 &= ~(1<< (SYS_IPRSTC2_UART0_RST_Pos+ ((UART)==UART0)?0:1)) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(1<< (16+ ((UART)==((UART_T *) ((( uint32_t)0x40000000) + 0x50000)))?0:1)) ;
N}     
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Break Control                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/ 
N/**
N * @brief      Set break control bit
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to set BCB bit and force TXD pin to low state.\n
N *             Example: _UART_FORCE_BREAK(UART0)
N *
N */ 
N#define _UART_FORCE_BREAK(UART)           ((UART)->LCR |= UART_LCR_BCB_Msk)
N
N/**
N * @brief      Clear break control bit
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to clear BCB bit and force TXD pin return normal state.\n
N *             Example: _UART_CLEAR_BREAK(UART0)
N *
N */ 
N#define _UART_CLEAR_BREAK(UART)           ((UART)->LCR &= ~UART_LCR_BCB_Msk)
N
N
N
N
N__INLINE int32_t UART_Write(UART_T *UART,uint8_t *pu8TxBuf,uint32_t u32WriteBytes)
X__inline int32_t UART_Write(UART_T *UART,uint8_t *pu8TxBuf,uint32_t u32WriteBytes)
N{
N    uint32_t  u32Count, u32delayno;
N
N    for (u32Count=0; u32Count != u32WriteBytes; u32Count++)
N    {
N       u32delayno = 0;
N       while (((UART)->FSR & UART_FSR_TE_FLAG_Msk) == 0)  /* Wait Tx empty and Time-out manner */
X       while (((UART)->FSR & (1ul << 28)) == 0)   
N       {
N            u32delayno++;
N            if ( u32delayno >= 0x40000000 )             
N               return FALSE;               
X               return 0;               
N       }
N       _UART_SENDBYTE((UART),pu8TxBuf[u32Count]);        /* Send UART Data from buffer */
X       (((UART))->THR = (pu8TxBuf[u32Count]));         
N    }
N    return TRUE;
X    return 1;
N}
N
N__INLINE int32_t UART_Read(UART_T *UART,uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
X__inline int32_t UART_Read(UART_T *UART,uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
N{
N    uint32_t u32Count, u32delayno;
N
N    for (u32Count=0; u32Count != u32ReadBytes; u32Count++)
N    {
N         u32delayno = 0;
N         while ((UART)->FSR & UART_FSR_RX_EMPTY_Msk)
X         while ((UART)->FSR & (1ul << 14))
N         {
N            u32delayno++;        
N            if ( u32delayno >= 0x40000000 )        
N                return FALSE;               
X                return 0;               
N         }
N         _UART_RECEIVEBYTE((UART),pu8RxBuf[u32Count]);          /* Get Data from UART RX  */
X         ((pu8RxBuf[u32Count]) = ((UART))->RBR);           
N    }
N    return TRUE;
X    return 1;
N}
N
N/**
N  * @} End of UART Device Function Interface
N  */ 
N
N/**
N  * @} End of M051 Function Interface
N  */ 
N
N
N#endif
N
N
N
N
N
N
N
N
N
N
N
L 6192 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "ram.h"
L 1 "..\..\Project\ram.h" 1
N
N#ifndef  __RAM_H__
N#define  __RAM_H__
N#include "ucos_ii.h"
N#include "app_cfg.h"
N
N#include <stdio.h>
N#include "M051Series.h"
N#include "initialization.h"
L 1 "..\..\Project\initialization.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2010 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef _INITIALIZATION_H
N#define _INITIALIZATION_H
N
Nextern void SYS_Init(void);
Nextern void UART0_Init(void);
Nextern void UART1_Init(void);
Nextern void GPIO_Init(void);
Nextern void TMR0_Init(void);
Nextern void TMR1_Init(void);
Nextern void PWMA_Init(void);
Nextern void PWMB_Init(void);
Nextern void CKO_Init(void);
Nextern void ADC_Init(void);
Nextern void SPI0_Init(void);
Nextern void SPI1_Init(void);
N
N#endif
N
L 10 "..\..\Project\ram.h" 2
Nextern OS_STK          AppTaskStartStk[APP_TASK_START_STK_SIZE];
Xextern OS_STK          AppTaskStartStk[30];
Nextern OS_STK          AppTaskTestStk[APP_TASK_Test_SIZE];
Xextern OS_STK          AppTaskTestStk[30];
Nvoid  AppTaskStart              (void        *p_arg);
Nvoid  AppTest                   (void        *p_arg);
Nvoid  AppTest1                   (void        *p_arg);
N#endif
L 6193 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "uart_ad.h"
L 1 "..\..\Project\uart_ad.h" 1
N
N#ifndef  __uart_H__
N#define  __uart_H__
Nvoid usart1_init(UART_T* UART);
Nvoid usart1_send(unsigned char data);
Nvoid usart1_sendbuf(unsigned char n);
Nvoid T_set_mode(void);
Nvoid T_set_mode1(void);
N#endif
L 6194 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#include "rambuf.h"
L 1 "..\..\Project\rambuf.h" 1
N#ifndef  __rambuf_H__
N#define  __rambuf_H__
Nextern unsigned char sendbuf[10],sendlen,sendlenn;
Nvoid raminit(void);
Nunsigned short CRC16_M(volatile unsigned char *puchMsg,unsigned short usDataLen );
N#endif
L 6195 "..\..\LibM051Series\CMSIS\DeviceSupport\M051Series.h" 2
N#endif
N                                                                                                 
N
L 11 "..\main.c" 2
N#include "initialization.h"
N#define DBG_PRINTF      printf
Nuint32_t msTicks = 0; /* Variable to store millisecond ticks */
N#define PLLCON_SETTING      SYSCLK_PLLCON_50MHz_XTAL
N#define PLL_CLOCK           50000000
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* MAIN function                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
Nint main(void)
N{
N	INT8U  os_err;
N
N	SystemInit();
N	SystemCoreClockUpdate();
N// 	SYS_Init();
N	_GPIO_SET_PIN_MODE(P0, 1, GPIO_PMD_OUTPUT);
X	((((GPIO_T *) (((( uint32_t)0x50000000) + 0x4000) )))->PMD = ((((GPIO_T *) (((( uint32_t)0x50000000) + 0x4000) )))->PMD & ~((0x3UL) << ((1)<<1))) | ((0x1UL) << ((1)<<1)));
N	P36 = 0;
X	(*((volatile uint32_t *)(((((( uint32_t)0x50000000) + 0x4000) + 0x200)+(0x20*(3))) + ((6)<<2)))) = 0;
N	usart1_init(UART1);
X	usart1_init(((UART_T *) ((( uint32_t)0x40100000) + 0x50000)));
N	OSInit();	//Initialize "uC/OS-II, The Real-Time Kernel"
N	
N	OSTaskCreateExt((void (*)(void *)) AppTaskStart,            /* Create the start task                                */
N				(void           *) 0,
N				(OS_STK         *)&AppTaskStartStk[APP_TASK_START_STK_SIZE - 1],
X				(OS_STK         *)&AppTaskStartStk[30 - 1],
N				(INT8U           ) APP_TASK_START_PRIO,
X				(INT8U           ) 4,
N				(INT16U          ) APP_TASK_START_PRIO,
X				(INT16U          ) 4,
N				(OS_STK         *)&AppTaskStartStk[0],
N				(INT32U          ) APP_TASK_START_STK_SIZE,
X				(INT32U          ) 30,
N				(void           *) 0,
N				(INT16U          )(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
X				(INT16U          )(0x0001u | 0x0002u));
N
N#if (OS_TASK_NAME_EN > 0)
X#if (1u > 0)
N    OSTaskNameSet((INT8U     )APP_TASK_START_PRIO,
X    OSTaskNameSet((INT8U     )4,
N                  (INT8U    *)"Start_Task",
N                  (INT8U    *)&os_err);
N#endif
N
N	OSStart();  //Start multitasking (i.e. give control to uC/OS-II)
N	raminit();
N	while(1)
N	{
N		 OSTimeDly(500);
N	}
N	
N}
N
N
N
N
N
N
